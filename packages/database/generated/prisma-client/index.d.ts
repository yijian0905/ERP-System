
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * Tenant represents a company/organization using the ERP system
 * All data is isolated by tenant_id (Row-Level Security pattern)
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * User belongs to a tenant with role-based access
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * Refresh tokens for JWT authentication
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model PlatformAdmin
 * Platform administrators - ERP company staff who manage all tenants
 * NOT to be confused with tenant Users who use the ERP system
 */
export type PlatformAdmin = $Result.DefaultSelection<Prisma.$PlatformAdminPayload>
/**
 * Model PlatformAdminRefreshToken
 * Refresh tokens for platform admin JWT authentication
 */
export type PlatformAdminRefreshToken = $Result.DefaultSelection<Prisma.$PlatformAdminRefreshTokenPayload>
/**
 * Model Role
 * Custom roles per tenant (e.g., Warehouse Manager, HR Manager)
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * Permissions define what actions can be performed
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * Junction table for Role-Permission many-to-many relationship
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model License
 * License information for tenant feature access
 */
export type License = $Result.DefaultSelection<Prisma.$LicensePayload>
/**
 * Model Category
 * Product categories for organization
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * Products in the catalog
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Warehouse
 * Warehouses/Locations for inventory storage
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model InventoryItem
 * Inventory items - tracks stock levels per product per warehouse
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model InventoryMovement
 * Inventory movements - tracks all stock changes
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model Customer
 * Customers for sales orders and invoices
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Supplier
 * Suppliers for purchase orders
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model SupplierProduct
 * Supplier-Product relationship with pricing
 */
export type SupplierProduct = $Result.DefaultSelection<Prisma.$SupplierProductPayload>
/**
 * Model Order
 * Orders - both Sales Orders and Purchase Orders
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * Order line items
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Invoice
 * Invoices generated from orders
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * Invoice line items
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * Payments received
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model AuditLog
 * Audit logs for tracking all data changes
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Asset
 * Assets - categorized into Current Assets and Fixed Assets
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model EInvoice
 * E-Invoice record for LHDN MyInvois integration
 */
export type EInvoice = $Result.DefaultSelection<Prisma.$EInvoicePayload>
/**
 * Model EInvoiceItem
 * E-Invoice line items with LHDN-specific fields
 */
export type EInvoiceItem = $Result.DefaultSelection<Prisma.$EInvoiceItemPayload>
/**
 * Model EInvoiceLog
 * E-Invoice activity log for audit trail
 */
export type EInvoiceLog = $Result.DefaultSelection<Prisma.$EInvoiceLogPayload>
/**
 * Model LhdnToken
 * LHDN API token cache (tenant-level)
 */
export type LhdnToken = $Result.DefaultSelection<Prisma.$LhdnTokenPayload>
/**
 * Model LhdnCredential
 * LHDN API credentials per tenant
 */
export type LhdnCredential = $Result.DefaultSelection<Prisma.$LhdnCredentialPayload>
/**
 * Model TenantCapability
 * Tenant capabilities - controls feature access
 * Codes: erp_core, forecasting, ai_chat, ai_agent, automation_rules
 */
export type TenantCapability = $Result.DefaultSelection<Prisma.$TenantCapabilityPayload>
/**
 * Model PrintAudit
 * Print audit logs for tracking all print events (Enterprise feature)
 */
export type PrintAudit = $Result.DefaultSelection<Prisma.$PrintAuditPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TenantStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  TRIAL: 'TRIAL',
  EXPIRED: 'EXPIRED'
};

export type TenantStatus = (typeof TenantStatus)[keyof typeof TenantStatus]


export const LicenseTier: {
  L1: 'L1',
  L2: 'L2',
  L3: 'L3'
};

export type LicenseTier = (typeof LicenseTier)[keyof typeof LicenseTier]


export const AuthPolicyPrimary: {
  password: 'password',
  sso: 'sso'
};

export type AuthPolicyPrimary = (typeof AuthPolicyPrimary)[keyof typeof AuthPolicyPrimary]


export const AuthPolicyMfa: {
  off: 'off',
  optional: 'optional',
  required: 'required'
};

export type AuthPolicyMfa = (typeof AuthPolicyMfa)[keyof typeof AuthPolicyMfa]


export const AuthPolicyIdentifier: {
  email: 'email',
  username: 'username'
};

export type AuthPolicyIdentifier = (typeof AuthPolicyIdentifier)[keyof typeof AuthPolicyIdentifier]


export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  USER: 'USER',
  VIEWER: 'VIEWER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ProductStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DISCONTINUED: 'DISCONTINUED',
  OUT_OF_STOCK: 'OUT_OF_STOCK'
};

export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus]


export const WarehouseType: {
  WAREHOUSE: 'WAREHOUSE',
  STORE: 'STORE',
  VIRTUAL: 'VIRTUAL'
};

export type WarehouseType = (typeof WarehouseType)[keyof typeof WarehouseType]


export const MovementType: {
  PURCHASE: 'PURCHASE',
  SALE: 'SALE',
  TRANSFER_IN: 'TRANSFER_IN',
  TRANSFER_OUT: 'TRANSFER_OUT',
  ADJUSTMENT: 'ADJUSTMENT',
  RETURN_IN: 'RETURN_IN',
  RETURN_OUT: 'RETURN_OUT',
  DAMAGE: 'DAMAGE',
  EXPIRED: 'EXPIRED',
  INITIAL: 'INITIAL'
};

export type MovementType = (typeof MovementType)[keyof typeof MovementType]


export const CustomerType: {
  INDIVIDUAL: 'INDIVIDUAL',
  COMPANY: 'COMPANY',
  GOVERNMENT: 'GOVERNMENT',
  NONPROFIT: 'NONPROFIT'
};

export type CustomerType = (typeof CustomerType)[keyof typeof CustomerType]


export const OrderType: {
  SALES: 'SALES',
  PURCHASE: 'PURCHASE',
  RETURN: 'RETURN',
  TRANSFER: 'TRANSFER'
};

export type OrderType = (typeof OrderType)[keyof typeof OrderType]


export const OrderStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  PROCESSING: 'PROCESSING',
  SHIPPED: 'SHIPPED',
  DELIVERED: 'DELIVERED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  ON_HOLD: 'ON_HOLD'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const InvoiceType: {
  INVOICE: 'INVOICE',
  CREDIT_NOTE: 'CREDIT_NOTE',
  DEBIT_NOTE: 'DEBIT_NOTE',
  PROFORMA: 'PROFORMA'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  SENT: 'SENT',
  VIEWED: 'VIEWED',
  PARTIAL: 'PARTIAL',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED',
  VOID: 'VOID'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const PaymentType: {
  RECEIVED: 'RECEIVED',
  REFUND: 'REFUND',
  CREDIT: 'CREDIT',
  ADVANCE: 'ADVANCE'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const PaymentMethod: {
  CASH: 'CASH',
  CHECK: 'CHECK',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  DIGITAL_WALLET: 'DIGITAL_WALLET',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const AssetType: {
  CURRENT: 'CURRENT',
  FIXED: 'FIXED'
};

export type AssetType = (typeof AssetType)[keyof typeof AssetType]


export const AssetCategory: {
  IT_EQUIPMENT: 'IT_EQUIPMENT',
  FURNITURE: 'FURNITURE',
  VEHICLE: 'VEHICLE',
  MACHINERY: 'MACHINERY',
  OFFICE_EQUIPMENT: 'OFFICE_EQUIPMENT',
  CASH: 'CASH',
  ACCOUNTS_RECEIVABLE: 'ACCOUNTS_RECEIVABLE',
  INVENTORY: 'INVENTORY',
  INVESTMENTS: 'INVESTMENTS',
  OTHER: 'OTHER'
};

export type AssetCategory = (typeof AssetCategory)[keyof typeof AssetCategory]


export const AssetStatus: {
  ACTIVE: 'ACTIVE',
  MAINTENANCE: 'MAINTENANCE',
  DISPOSED: 'DISPOSED',
  RESERVED: 'RESERVED',
  RETIRED: 'RETIRED'
};

export type AssetStatus = (typeof AssetStatus)[keyof typeof AssetStatus]


export const DepreciationMethod: {
  STRAIGHT_LINE: 'STRAIGHT_LINE',
  DECLINING_BALANCE: 'DECLINING_BALANCE',
  NONE: 'NONE'
};

export type DepreciationMethod = (typeof DepreciationMethod)[keyof typeof DepreciationMethod]


export const EInvoiceType: {
  INVOICE: 'INVOICE',
  CREDIT_NOTE: 'CREDIT_NOTE',
  DEBIT_NOTE: 'DEBIT_NOTE',
  REFUND_NOTE: 'REFUND_NOTE',
  SELF_BILLED: 'SELF_BILLED',
  SELF_BILLED_CREDIT_NOTE: 'SELF_BILLED_CREDIT_NOTE',
  SELF_BILLED_DEBIT_NOTE: 'SELF_BILLED_DEBIT_NOTE',
  SELF_BILLED_REFUND_NOTE: 'SELF_BILLED_REFUND_NOTE'
};

export type EInvoiceType = (typeof EInvoiceType)[keyof typeof EInvoiceType]


export const EInvoiceStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  SUBMITTED: 'SUBMITTED',
  VALID: 'VALID',
  INVALID: 'INVALID',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED',
  ERROR: 'ERROR'
};

export type EInvoiceStatus = (typeof EInvoiceStatus)[keyof typeof EInvoiceStatus]


export const LhdnEnvironment: {
  SANDBOX: 'SANDBOX',
  PRODUCTION: 'PRODUCTION'
};

export type LhdnEnvironment = (typeof LhdnEnvironment)[keyof typeof LhdnEnvironment]

}

export type TenantStatus = $Enums.TenantStatus

export const TenantStatus: typeof $Enums.TenantStatus

export type LicenseTier = $Enums.LicenseTier

export const LicenseTier: typeof $Enums.LicenseTier

export type AuthPolicyPrimary = $Enums.AuthPolicyPrimary

export const AuthPolicyPrimary: typeof $Enums.AuthPolicyPrimary

export type AuthPolicyMfa = $Enums.AuthPolicyMfa

export const AuthPolicyMfa: typeof $Enums.AuthPolicyMfa

export type AuthPolicyIdentifier = $Enums.AuthPolicyIdentifier

export const AuthPolicyIdentifier: typeof $Enums.AuthPolicyIdentifier

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ProductStatus = $Enums.ProductStatus

export const ProductStatus: typeof $Enums.ProductStatus

export type WarehouseType = $Enums.WarehouseType

export const WarehouseType: typeof $Enums.WarehouseType

export type MovementType = $Enums.MovementType

export const MovementType: typeof $Enums.MovementType

export type CustomerType = $Enums.CustomerType

export const CustomerType: typeof $Enums.CustomerType

export type OrderType = $Enums.OrderType

export const OrderType: typeof $Enums.OrderType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type AssetType = $Enums.AssetType

export const AssetType: typeof $Enums.AssetType

export type AssetCategory = $Enums.AssetCategory

export const AssetCategory: typeof $Enums.AssetCategory

export type AssetStatus = $Enums.AssetStatus

export const AssetStatus: typeof $Enums.AssetStatus

export type DepreciationMethod = $Enums.DepreciationMethod

export const DepreciationMethod: typeof $Enums.DepreciationMethod

export type EInvoiceType = $Enums.EInvoiceType

export const EInvoiceType: typeof $Enums.EInvoiceType

export type EInvoiceStatus = $Enums.EInvoiceStatus

export const EInvoiceStatus: typeof $Enums.EInvoiceStatus

export type LhdnEnvironment = $Enums.LhdnEnvironment

export const LhdnEnvironment: typeof $Enums.LhdnEnvironment

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformAdmin`: Exposes CRUD operations for the **PlatformAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformAdmins
    * const platformAdmins = await prisma.platformAdmin.findMany()
    * ```
    */
  get platformAdmin(): Prisma.PlatformAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformAdminRefreshToken`: Exposes CRUD operations for the **PlatformAdminRefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformAdminRefreshTokens
    * const platformAdminRefreshTokens = await prisma.platformAdminRefreshToken.findMany()
    * ```
    */
  get platformAdminRefreshToken(): Prisma.PlatformAdminRefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.license`: Exposes CRUD operations for the **License** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenses
    * const licenses = await prisma.license.findMany()
    * ```
    */
  get license(): Prisma.LicenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierProduct`: Exposes CRUD operations for the **SupplierProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierProducts
    * const supplierProducts = await prisma.supplierProduct.findMany()
    * ```
    */
  get supplierProduct(): Prisma.SupplierProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eInvoice`: Exposes CRUD operations for the **EInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EInvoices
    * const eInvoices = await prisma.eInvoice.findMany()
    * ```
    */
  get eInvoice(): Prisma.EInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eInvoiceItem`: Exposes CRUD operations for the **EInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EInvoiceItems
    * const eInvoiceItems = await prisma.eInvoiceItem.findMany()
    * ```
    */
  get eInvoiceItem(): Prisma.EInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eInvoiceLog`: Exposes CRUD operations for the **EInvoiceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EInvoiceLogs
    * const eInvoiceLogs = await prisma.eInvoiceLog.findMany()
    * ```
    */
  get eInvoiceLog(): Prisma.EInvoiceLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lhdnToken`: Exposes CRUD operations for the **LhdnToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LhdnTokens
    * const lhdnTokens = await prisma.lhdnToken.findMany()
    * ```
    */
  get lhdnToken(): Prisma.LhdnTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lhdnCredential`: Exposes CRUD operations for the **LhdnCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LhdnCredentials
    * const lhdnCredentials = await prisma.lhdnCredential.findMany()
    * ```
    */
  get lhdnCredential(): Prisma.LhdnCredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantCapability`: Exposes CRUD operations for the **TenantCapability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantCapabilities
    * const tenantCapabilities = await prisma.tenantCapability.findMany()
    * ```
    */
  get tenantCapability(): Prisma.TenantCapabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.printAudit`: Exposes CRUD operations for the **PrintAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrintAudits
    * const printAudits = await prisma.printAudit.findMany()
    * ```
    */
  get printAudit(): Prisma.PrintAuditDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    RefreshToken: 'RefreshToken',
    PlatformAdmin: 'PlatformAdmin',
    PlatformAdminRefreshToken: 'PlatformAdminRefreshToken',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    License: 'License',
    Category: 'Category',
    Product: 'Product',
    Warehouse: 'Warehouse',
    InventoryItem: 'InventoryItem',
    InventoryMovement: 'InventoryMovement',
    Customer: 'Customer',
    Supplier: 'Supplier',
    SupplierProduct: 'SupplierProduct',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    AuditLog: 'AuditLog',
    Asset: 'Asset',
    EInvoice: 'EInvoice',
    EInvoiceItem: 'EInvoiceItem',
    EInvoiceLog: 'EInvoiceLog',
    LhdnToken: 'LhdnToken',
    LhdnCredential: 'LhdnCredential',
    TenantCapability: 'TenantCapability',
    PrintAudit: 'PrintAudit'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "refreshToken" | "platformAdmin" | "platformAdminRefreshToken" | "role" | "permission" | "rolePermission" | "license" | "category" | "product" | "warehouse" | "inventoryItem" | "inventoryMovement" | "customer" | "supplier" | "supplierProduct" | "order" | "orderItem" | "invoice" | "invoiceItem" | "payment" | "auditLog" | "asset" | "eInvoice" | "eInvoiceItem" | "eInvoiceLog" | "lhdnToken" | "lhdnCredential" | "tenantCapability" | "printAudit"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      PlatformAdmin: {
        payload: Prisma.$PlatformAdminPayload<ExtArgs>
        fields: Prisma.PlatformAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>
          }
          findFirst: {
            args: Prisma.PlatformAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>
          }
          findMany: {
            args: Prisma.PlatformAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>[]
          }
          create: {
            args: Prisma.PlatformAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>
          }
          createMany: {
            args: Prisma.PlatformAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>[]
          }
          delete: {
            args: Prisma.PlatformAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>
          }
          update: {
            args: Prisma.PlatformAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>
          }
          deleteMany: {
            args: Prisma.PlatformAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>[]
          }
          upsert: {
            args: Prisma.PlatformAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminPayload>
          }
          aggregate: {
            args: Prisma.PlatformAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformAdmin>
          }
          groupBy: {
            args: Prisma.PlatformAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformAdminCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformAdminCountAggregateOutputType> | number
          }
        }
      }
      PlatformAdminRefreshToken: {
        payload: Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>
        fields: Prisma.PlatformAdminRefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformAdminRefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformAdminRefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.PlatformAdminRefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformAdminRefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>
          }
          findMany: {
            args: Prisma.PlatformAdminRefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>[]
          }
          create: {
            args: Prisma.PlatformAdminRefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>
          }
          createMany: {
            args: Prisma.PlatformAdminRefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformAdminRefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.PlatformAdminRefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>
          }
          update: {
            args: Prisma.PlatformAdminRefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.PlatformAdminRefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformAdminRefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformAdminRefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.PlatformAdminRefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAdminRefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.PlatformAdminRefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformAdminRefreshToken>
          }
          groupBy: {
            args: Prisma.PlatformAdminRefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformAdminRefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformAdminRefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformAdminRefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      License: {
        payload: Prisma.$LicensePayload<ExtArgs>
        fields: Prisma.LicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findFirst: {
            args: Prisma.LicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findMany: {
            args: Prisma.LicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          create: {
            args: Prisma.LicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          createMany: {
            args: Prisma.LicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          delete: {
            args: Prisma.LicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          update: {
            args: Prisma.LicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          deleteMany: {
            args: Prisma.LicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LicenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          upsert: {
            args: Prisma.LicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          aggregate: {
            args: Prisma.LicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicense>
          }
          groupBy: {
            args: Prisma.LicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      SupplierProduct: {
        payload: Prisma.$SupplierProductPayload<ExtArgs>
        fields: Prisma.SupplierProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          findFirst: {
            args: Prisma.SupplierProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          findMany: {
            args: Prisma.SupplierProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          create: {
            args: Prisma.SupplierProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          createMany: {
            args: Prisma.SupplierProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          delete: {
            args: Prisma.SupplierProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          update: {
            args: Prisma.SupplierProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          deleteMany: {
            args: Prisma.SupplierProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>[]
          }
          upsert: {
            args: Prisma.SupplierProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierProductPayload>
          }
          aggregate: {
            args: Prisma.SupplierProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierProduct>
          }
          groupBy: {
            args: Prisma.SupplierProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierProductCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierProductCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      EInvoice: {
        payload: Prisma.$EInvoicePayload<ExtArgs>
        fields: Prisma.EInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>
          }
          findFirst: {
            args: Prisma.EInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>
          }
          findMany: {
            args: Prisma.EInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>[]
          }
          create: {
            args: Prisma.EInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>
          }
          createMany: {
            args: Prisma.EInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>[]
          }
          delete: {
            args: Prisma.EInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>
          }
          update: {
            args: Prisma.EInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>
          }
          deleteMany: {
            args: Prisma.EInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>[]
          }
          upsert: {
            args: Prisma.EInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoicePayload>
          }
          aggregate: {
            args: Prisma.EInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEInvoice>
          }
          groupBy: {
            args: Prisma.EInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<EInvoiceCountAggregateOutputType> | number
          }
        }
      }
      EInvoiceItem: {
        payload: Prisma.$EInvoiceItemPayload<ExtArgs>
        fields: Prisma.EInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.EInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.EInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.EInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.EInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.EInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>
          }
          update: {
            args: Prisma.EInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.EInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.EInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.EInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEInvoiceItem>
          }
          groupBy: {
            args: Prisma.EInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<EInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.EInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<EInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      EInvoiceLog: {
        payload: Prisma.$EInvoiceLogPayload<ExtArgs>
        fields: Prisma.EInvoiceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EInvoiceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EInvoiceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>
          }
          findFirst: {
            args: Prisma.EInvoiceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EInvoiceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>
          }
          findMany: {
            args: Prisma.EInvoiceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>[]
          }
          create: {
            args: Prisma.EInvoiceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>
          }
          createMany: {
            args: Prisma.EInvoiceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EInvoiceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>[]
          }
          delete: {
            args: Prisma.EInvoiceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>
          }
          update: {
            args: Prisma.EInvoiceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>
          }
          deleteMany: {
            args: Prisma.EInvoiceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EInvoiceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EInvoiceLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>[]
          }
          upsert: {
            args: Prisma.EInvoiceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EInvoiceLogPayload>
          }
          aggregate: {
            args: Prisma.EInvoiceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEInvoiceLog>
          }
          groupBy: {
            args: Prisma.EInvoiceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EInvoiceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EInvoiceLogCountArgs<ExtArgs>
            result: $Utils.Optional<EInvoiceLogCountAggregateOutputType> | number
          }
        }
      }
      LhdnToken: {
        payload: Prisma.$LhdnTokenPayload<ExtArgs>
        fields: Prisma.LhdnTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LhdnTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LhdnTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>
          }
          findFirst: {
            args: Prisma.LhdnTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LhdnTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>
          }
          findMany: {
            args: Prisma.LhdnTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>[]
          }
          create: {
            args: Prisma.LhdnTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>
          }
          createMany: {
            args: Prisma.LhdnTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LhdnTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>[]
          }
          delete: {
            args: Prisma.LhdnTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>
          }
          update: {
            args: Prisma.LhdnTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>
          }
          deleteMany: {
            args: Prisma.LhdnTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LhdnTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LhdnTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>[]
          }
          upsert: {
            args: Prisma.LhdnTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnTokenPayload>
          }
          aggregate: {
            args: Prisma.LhdnTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLhdnToken>
          }
          groupBy: {
            args: Prisma.LhdnTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<LhdnTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.LhdnTokenCountArgs<ExtArgs>
            result: $Utils.Optional<LhdnTokenCountAggregateOutputType> | number
          }
        }
      }
      LhdnCredential: {
        payload: Prisma.$LhdnCredentialPayload<ExtArgs>
        fields: Prisma.LhdnCredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LhdnCredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LhdnCredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>
          }
          findFirst: {
            args: Prisma.LhdnCredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LhdnCredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>
          }
          findMany: {
            args: Prisma.LhdnCredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>[]
          }
          create: {
            args: Prisma.LhdnCredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>
          }
          createMany: {
            args: Prisma.LhdnCredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LhdnCredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>[]
          }
          delete: {
            args: Prisma.LhdnCredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>
          }
          update: {
            args: Prisma.LhdnCredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>
          }
          deleteMany: {
            args: Prisma.LhdnCredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LhdnCredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LhdnCredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>[]
          }
          upsert: {
            args: Prisma.LhdnCredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LhdnCredentialPayload>
          }
          aggregate: {
            args: Prisma.LhdnCredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLhdnCredential>
          }
          groupBy: {
            args: Prisma.LhdnCredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<LhdnCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.LhdnCredentialCountArgs<ExtArgs>
            result: $Utils.Optional<LhdnCredentialCountAggregateOutputType> | number
          }
        }
      }
      TenantCapability: {
        payload: Prisma.$TenantCapabilityPayload<ExtArgs>
        fields: Prisma.TenantCapabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantCapabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantCapabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>
          }
          findFirst: {
            args: Prisma.TenantCapabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantCapabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>
          }
          findMany: {
            args: Prisma.TenantCapabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>[]
          }
          create: {
            args: Prisma.TenantCapabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>
          }
          createMany: {
            args: Prisma.TenantCapabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCapabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>[]
          }
          delete: {
            args: Prisma.TenantCapabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>
          }
          update: {
            args: Prisma.TenantCapabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>
          }
          deleteMany: {
            args: Prisma.TenantCapabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantCapabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantCapabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>[]
          }
          upsert: {
            args: Prisma.TenantCapabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantCapabilityPayload>
          }
          aggregate: {
            args: Prisma.TenantCapabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantCapability>
          }
          groupBy: {
            args: Prisma.TenantCapabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantCapabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCapabilityCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCapabilityCountAggregateOutputType> | number
          }
        }
      }
      PrintAudit: {
        payload: Prisma.$PrintAuditPayload<ExtArgs>
        fields: Prisma.PrintAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrintAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrintAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>
          }
          findFirst: {
            args: Prisma.PrintAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrintAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>
          }
          findMany: {
            args: Prisma.PrintAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>[]
          }
          create: {
            args: Prisma.PrintAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>
          }
          createMany: {
            args: Prisma.PrintAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrintAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>[]
          }
          delete: {
            args: Prisma.PrintAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>
          }
          update: {
            args: Prisma.PrintAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>
          }
          deleteMany: {
            args: Prisma.PrintAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrintAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrintAuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>[]
          }
          upsert: {
            args: Prisma.PrintAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintAuditPayload>
          }
          aggregate: {
            args: Prisma.PrintAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrintAudit>
          }
          groupBy: {
            args: Prisma.PrintAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrintAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrintAuditCountArgs<ExtArgs>
            result: $Utils.Optional<PrintAuditCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    platformAdmin?: PlatformAdminOmit
    platformAdminRefreshToken?: PlatformAdminRefreshTokenOmit
    role?: RoleOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    license?: LicenseOmit
    category?: CategoryOmit
    product?: ProductOmit
    warehouse?: WarehouseOmit
    inventoryItem?: InventoryItemOmit
    inventoryMovement?: InventoryMovementOmit
    customer?: CustomerOmit
    supplier?: SupplierOmit
    supplierProduct?: SupplierProductOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    payment?: PaymentOmit
    auditLog?: AuditLogOmit
    asset?: AssetOmit
    eInvoice?: EInvoiceOmit
    eInvoiceItem?: EInvoiceItemOmit
    eInvoiceLog?: EInvoiceLogOmit
    lhdnToken?: LhdnTokenOmit
    lhdnCredential?: LhdnCredentialOmit
    tenantCapability?: TenantCapabilityOmit
    printAudit?: PrintAuditOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    products: number
    categories: number
    customers: number
    suppliers: number
    warehouses: number
    inventoryItems: number
    inventoryMovements: number
    orders: number
    invoices: number
    payments: number
    licenses: number
    auditLogs: number
    assets: number
    roles: number
    eInvoices: number
    capabilities: number
    printAudits: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    products?: boolean | TenantCountOutputTypeCountProductsArgs
    categories?: boolean | TenantCountOutputTypeCountCategoriesArgs
    customers?: boolean | TenantCountOutputTypeCountCustomersArgs
    suppliers?: boolean | TenantCountOutputTypeCountSuppliersArgs
    warehouses?: boolean | TenantCountOutputTypeCountWarehousesArgs
    inventoryItems?: boolean | TenantCountOutputTypeCountInventoryItemsArgs
    inventoryMovements?: boolean | TenantCountOutputTypeCountInventoryMovementsArgs
    orders?: boolean | TenantCountOutputTypeCountOrdersArgs
    invoices?: boolean | TenantCountOutputTypeCountInvoicesArgs
    payments?: boolean | TenantCountOutputTypeCountPaymentsArgs
    licenses?: boolean | TenantCountOutputTypeCountLicensesArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
    assets?: boolean | TenantCountOutputTypeCountAssetsArgs
    roles?: boolean | TenantCountOutputTypeCountRolesArgs
    eInvoices?: boolean | TenantCountOutputTypeCountEInvoicesArgs
    capabilities?: boolean | TenantCountOutputTypeCountCapabilitiesArgs
    printAudits?: boolean | TenantCountOutputTypeCountPrintAuditsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCapabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantCapabilityWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPrintAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintAuditWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    inventoryMovements: number
    ordersCreated: number
    ordersApproved: number
    invoicesCreated: number
    paymentsReceived: number
    auditLogs: number
    printAudits: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    inventoryMovements?: boolean | UserCountOutputTypeCountInventoryMovementsArgs
    ordersCreated?: boolean | UserCountOutputTypeCountOrdersCreatedArgs
    ordersApproved?: boolean | UserCountOutputTypeCountOrdersApprovedArgs
    invoicesCreated?: boolean | UserCountOutputTypeCountInvoicesCreatedArgs
    paymentsReceived?: boolean | UserCountOutputTypeCountPaymentsReceivedArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    printAudits?: boolean | UserCountOutputTypeCountPrintAuditsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrintAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintAuditWhereInput
  }


  /**
   * Count Type PlatformAdminCountOutputType
   */

  export type PlatformAdminCountOutputType = {
    refreshTokens: number
  }

  export type PlatformAdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | PlatformAdminCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes
  /**
   * PlatformAdminCountOutputType without action
   */
  export type PlatformAdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminCountOutputType
     */
    select?: PlatformAdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlatformAdminCountOutputType without action
   */
  export type PlatformAdminCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAdminRefreshTokenWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
    permissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    inventoryItems: number
    inventoryMovements: number
    orderItems: number
    invoiceItems: number
    supplierProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | ProductCountOutputTypeCountInventoryItemsArgs
    inventoryMovements?: boolean | ProductCountOutputTypeCountInventoryMovementsArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    invoiceItems?: boolean | ProductCountOutputTypeCountInvoiceItemsArgs
    supplierProducts?: boolean | ProductCountOutputTypeCountSupplierProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSupplierProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    inventoryItems: number
    movementsFrom: number
    movementsTo: number
    ordersShipFrom: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | WarehouseCountOutputTypeCountInventoryItemsArgs
    movementsFrom?: boolean | WarehouseCountOutputTypeCountMovementsFromArgs
    movementsTo?: boolean | WarehouseCountOutputTypeCountMovementsToArgs
    ordersShipFrom?: boolean | WarehouseCountOutputTypeCountOrdersShipFromArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountMovementsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountMovementsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountOrdersShipFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
    invoices: number
    payments: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    invoices?: boolean | CustomerCountOutputTypeCountInvoicesArgs
    payments?: boolean | CustomerCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    orders: number
    supplierProducts: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | SupplierCountOutputTypeCountOrdersArgs
    supplierProducts?: boolean | SupplierCountOutputTypeCountSupplierProductsArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountSupplierProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    invoices: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    invoices?: boolean | OrderCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
    payments: number
    eInvoices: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
    eInvoices?: boolean | InvoiceCountOutputTypeCountEInvoicesArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountEInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceWhereInput
  }


  /**
   * Count Type InvoiceItemCountOutputType
   */

  export type InvoiceItemCountOutputType = {
    eInvoiceItems: number
  }

  export type InvoiceItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eInvoiceItems?: boolean | InvoiceItemCountOutputTypeCountEInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceItemCountOutputType without action
   */
  export type InvoiceItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItemCountOutputType
     */
    select?: InvoiceItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceItemCountOutputType without action
   */
  export type InvoiceItemCountOutputTypeCountEInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceItemWhereInput
  }


  /**
   * Count Type EInvoiceCountOutputType
   */

  export type EInvoiceCountOutputType = {
    relatedEInvoices: number
    items: number
    logs: number
  }

  export type EInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedEInvoices?: boolean | EInvoiceCountOutputTypeCountRelatedEInvoicesArgs
    items?: boolean | EInvoiceCountOutputTypeCountItemsArgs
    logs?: boolean | EInvoiceCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * EInvoiceCountOutputType without action
   */
  export type EInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceCountOutputType
     */
    select?: EInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EInvoiceCountOutputType without action
   */
  export type EInvoiceCountOutputTypeCountRelatedEInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceWhereInput
  }

  /**
   * EInvoiceCountOutputType without action
   */
  export type EInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceItemWhereInput
  }

  /**
   * EInvoiceCountOutputType without action
   */
  export type EInvoiceCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    domain: string | null
    status: $Enums.TenantStatus | null
    tier: $Enums.LicenseTier | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    authPolicyPrimary: $Enums.AuthPolicyPrimary | null
    authPolicyMfa: $Enums.AuthPolicyMfa | null
    authPolicyIdentifier: $Enums.AuthPolicyIdentifier | null
    authPolicyAllowFallback: boolean | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    domain: string | null
    status: $Enums.TenantStatus | null
    tier: $Enums.LicenseTier | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    authPolicyPrimary: $Enums.AuthPolicyPrimary | null
    authPolicyMfa: $Enums.AuthPolicyMfa | null
    authPolicyIdentifier: $Enums.AuthPolicyIdentifier | null
    authPolicyAllowFallback: boolean | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    domain: number
    status: number
    tier: number
    settings: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    authPolicyPrimary: number
    authPolicyMfa: number
    authPolicyIdentifier: number
    authPolicyAllowFallback: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    domain?: true
    status?: true
    tier?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    authPolicyPrimary?: true
    authPolicyMfa?: true
    authPolicyIdentifier?: true
    authPolicyAllowFallback?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    domain?: true
    status?: true
    tier?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    authPolicyPrimary?: true
    authPolicyMfa?: true
    authPolicyIdentifier?: true
    authPolicyAllowFallback?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    domain?: true
    status?: true
    tier?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    authPolicyPrimary?: true
    authPolicyMfa?: true
    authPolicyIdentifier?: true
    authPolicyAllowFallback?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    slug: string
    domain: string | null
    status: $Enums.TenantStatus
    tier: $Enums.LicenseTier
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    authPolicyPrimary: $Enums.AuthPolicyPrimary
    authPolicyMfa: $Enums.AuthPolicyMfa
    authPolicyIdentifier: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback: boolean
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    domain?: boolean
    status?: boolean
    tier?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    authPolicyPrimary?: boolean
    authPolicyMfa?: boolean
    authPolicyIdentifier?: boolean
    authPolicyAllowFallback?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    products?: boolean | Tenant$productsArgs<ExtArgs>
    categories?: boolean | Tenant$categoriesArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    suppliers?: boolean | Tenant$suppliersArgs<ExtArgs>
    warehouses?: boolean | Tenant$warehousesArgs<ExtArgs>
    inventoryItems?: boolean | Tenant$inventoryItemsArgs<ExtArgs>
    inventoryMovements?: boolean | Tenant$inventoryMovementsArgs<ExtArgs>
    orders?: boolean | Tenant$ordersArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    licenses?: boolean | Tenant$licensesArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    assets?: boolean | Tenant$assetsArgs<ExtArgs>
    roles?: boolean | Tenant$rolesArgs<ExtArgs>
    eInvoices?: boolean | Tenant$eInvoicesArgs<ExtArgs>
    lhdnToken?: boolean | Tenant$lhdnTokenArgs<ExtArgs>
    lhdnCredential?: boolean | Tenant$lhdnCredentialArgs<ExtArgs>
    capabilities?: boolean | Tenant$capabilitiesArgs<ExtArgs>
    printAudits?: boolean | Tenant$printAuditsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    domain?: boolean
    status?: boolean
    tier?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    authPolicyPrimary?: boolean
    authPolicyMfa?: boolean
    authPolicyIdentifier?: boolean
    authPolicyAllowFallback?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    domain?: boolean
    status?: boolean
    tier?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    authPolicyPrimary?: boolean
    authPolicyMfa?: boolean
    authPolicyIdentifier?: boolean
    authPolicyAllowFallback?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    domain?: boolean
    status?: boolean
    tier?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    authPolicyPrimary?: boolean
    authPolicyMfa?: boolean
    authPolicyIdentifier?: boolean
    authPolicyAllowFallback?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "domain" | "status" | "tier" | "settings" | "createdAt" | "updatedAt" | "deletedAt" | "authPolicyPrimary" | "authPolicyMfa" | "authPolicyIdentifier" | "authPolicyAllowFallback", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    products?: boolean | Tenant$productsArgs<ExtArgs>
    categories?: boolean | Tenant$categoriesArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    suppliers?: boolean | Tenant$suppliersArgs<ExtArgs>
    warehouses?: boolean | Tenant$warehousesArgs<ExtArgs>
    inventoryItems?: boolean | Tenant$inventoryItemsArgs<ExtArgs>
    inventoryMovements?: boolean | Tenant$inventoryMovementsArgs<ExtArgs>
    orders?: boolean | Tenant$ordersArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    licenses?: boolean | Tenant$licensesArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    assets?: boolean | Tenant$assetsArgs<ExtArgs>
    roles?: boolean | Tenant$rolesArgs<ExtArgs>
    eInvoices?: boolean | Tenant$eInvoicesArgs<ExtArgs>
    lhdnToken?: boolean | Tenant$lhdnTokenArgs<ExtArgs>
    lhdnCredential?: boolean | Tenant$lhdnCredentialArgs<ExtArgs>
    capabilities?: boolean | Tenant$capabilitiesArgs<ExtArgs>
    printAudits?: boolean | Tenant$printAuditsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
      warehouses: Prisma.$WarehousePayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      licenses: Prisma.$LicensePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      roles: Prisma.$RolePayload<ExtArgs>[]
      eInvoices: Prisma.$EInvoicePayload<ExtArgs>[]
      lhdnToken: Prisma.$LhdnTokenPayload<ExtArgs> | null
      lhdnCredential: Prisma.$LhdnCredentialPayload<ExtArgs> | null
      capabilities: Prisma.$TenantCapabilityPayload<ExtArgs>[]
      printAudits: Prisma.$PrintAuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      domain: string | null
      status: $Enums.TenantStatus
      tier: $Enums.LicenseTier
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      authPolicyPrimary: $Enums.AuthPolicyPrimary
      authPolicyMfa: $Enums.AuthPolicyMfa
      authPolicyIdentifier: $Enums.AuthPolicyIdentifier
      authPolicyAllowFallback: boolean
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Tenant$productsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Tenant$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Tenant$customersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    suppliers<T extends Tenant$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warehouses<T extends Tenant$warehousesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$warehousesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Tenant$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryMovements<T extends Tenant$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Tenant$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Tenant$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Tenant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    licenses<T extends Tenant$licensesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$licensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assets<T extends Tenant$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends Tenant$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eInvoices<T extends Tenant$eInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$eInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lhdnToken<T extends Tenant$lhdnTokenArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$lhdnTokenArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lhdnCredential<T extends Tenant$lhdnCredentialArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$lhdnCredentialArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    capabilities<T extends Tenant$capabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$capabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    printAudits<T extends Tenant$printAuditsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$printAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly status: FieldRef<"Tenant", 'TenantStatus'>
    readonly tier: FieldRef<"Tenant", 'LicenseTier'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly deletedAt: FieldRef<"Tenant", 'DateTime'>
    readonly authPolicyPrimary: FieldRef<"Tenant", 'AuthPolicyPrimary'>
    readonly authPolicyMfa: FieldRef<"Tenant", 'AuthPolicyMfa'>
    readonly authPolicyIdentifier: FieldRef<"Tenant", 'AuthPolicyIdentifier'>
    readonly authPolicyAllowFallback: FieldRef<"Tenant", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.products
   */
  export type Tenant$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Tenant.categories
   */
  export type Tenant$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Tenant.customers
   */
  export type Tenant$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Tenant.suppliers
   */
  export type Tenant$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Tenant.warehouses
   */
  export type Tenant$warehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    cursor?: WarehouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Tenant.inventoryItems
   */
  export type Tenant$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Tenant.inventoryMovements
   */
  export type Tenant$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Tenant.orders
   */
  export type Tenant$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Tenant.invoices
   */
  export type Tenant$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.payments
   */
  export type Tenant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Tenant.licenses
   */
  export type Tenant$licensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    cursor?: LicenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant.assets
   */
  export type Tenant$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Tenant.roles
   */
  export type Tenant$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Tenant.eInvoices
   */
  export type Tenant$eInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    where?: EInvoiceWhereInput
    orderBy?: EInvoiceOrderByWithRelationInput | EInvoiceOrderByWithRelationInput[]
    cursor?: EInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EInvoiceScalarFieldEnum | EInvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.lhdnToken
   */
  export type Tenant$lhdnTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    where?: LhdnTokenWhereInput
  }

  /**
   * Tenant.lhdnCredential
   */
  export type Tenant$lhdnCredentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    where?: LhdnCredentialWhereInput
  }

  /**
   * Tenant.capabilities
   */
  export type Tenant$capabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    where?: TenantCapabilityWhereInput
    orderBy?: TenantCapabilityOrderByWithRelationInput | TenantCapabilityOrderByWithRelationInput[]
    cursor?: TenantCapabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantCapabilityScalarFieldEnum | TenantCapabilityScalarFieldEnum[]
  }

  /**
   * Tenant.printAudits
   */
  export type Tenant$printAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    where?: PrintAuditWhereInput
    orderBy?: PrintAuditOrderByWithRelationInput | PrintAuditOrderByWithRelationInput[]
    cursor?: PrintAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrintAuditScalarFieldEnum | PrintAuditScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLogins: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLogins: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.UserRole | null
    roleId: string | null
    avatar: string | null
    phone: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    name: string | null
    password: string | null
    role: $Enums.UserRole | null
    roleId: string | null
    avatar: string | null
    phone: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    name: number
    password: number
    role: number
    roleId: number
    avatar: number
    phone: number
    isActive: number
    lastLoginAt: number
    lastLoginIp: number
    failedLogins: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLogins?: true
  }

  export type UserSumAggregateInputType = {
    failedLogins?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    password?: true
    role?: true
    roleId?: true
    avatar?: true
    phone?: true
    isActive?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    password?: true
    role?: true
    roleId?: true
    avatar?: true
    phone?: true
    isActive?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    name?: true
    password?: true
    role?: true
    roleId?: true
    avatar?: true
    phone?: true
    isActive?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    name: string
    password: string
    role: $Enums.UserRole
    roleId: string | null
    avatar: string | null
    phone: string | null
    isActive: boolean
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    roleId?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customRole?: boolean | User$customRoleArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    ordersCreated?: boolean | User$ordersCreatedArgs<ExtArgs>
    ordersApproved?: boolean | User$ordersApprovedArgs<ExtArgs>
    invoicesCreated?: boolean | User$invoicesCreatedArgs<ExtArgs>
    paymentsReceived?: boolean | User$paymentsReceivedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    printAudits?: boolean | User$printAuditsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    roleId?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customRole?: boolean | User$customRoleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    roleId?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customRole?: boolean | User$customRoleArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    roleId?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "email" | "name" | "password" | "role" | "roleId" | "avatar" | "phone" | "isActive" | "lastLoginAt" | "lastLoginIp" | "failedLogins" | "lockedUntil" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customRole?: boolean | User$customRoleArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    ordersCreated?: boolean | User$ordersCreatedArgs<ExtArgs>
    ordersApproved?: boolean | User$ordersApprovedArgs<ExtArgs>
    invoicesCreated?: boolean | User$invoicesCreatedArgs<ExtArgs>
    paymentsReceived?: boolean | User$paymentsReceivedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    printAudits?: boolean | User$printAuditsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customRole?: boolean | User$customRoleArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customRole?: boolean | User$customRoleArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      customRole: Prisma.$RolePayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      ordersCreated: Prisma.$OrderPayload<ExtArgs>[]
      ordersApproved: Prisma.$OrderPayload<ExtArgs>[]
      invoicesCreated: Prisma.$InvoicePayload<ExtArgs>[]
      paymentsReceived: Prisma.$PaymentPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      printAudits: Prisma.$PrintAuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      name: string
      password: string
      role: $Enums.UserRole
      roleId: string | null
      avatar: string | null
      phone: string | null
      isActive: boolean
      lastLoginAt: Date | null
      lastLoginIp: string | null
      failedLogins: number
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customRole<T extends User$customRoleArgs<ExtArgs> = {}>(args?: Subset<T, User$customRoleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryMovements<T extends User$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordersCreated<T extends User$ordersCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordersApproved<T extends User$ordersApprovedArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersApprovedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoicesCreated<T extends User$invoicesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentsReceived<T extends User$paymentsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    printAudits<T extends User$printAuditsArgs<ExtArgs> = {}>(args?: Subset<T, User$printAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginIp: FieldRef<"User", 'String'>
    readonly failedLogins: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.customRole
   */
  export type User$customRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.inventoryMovements
   */
  export type User$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * User.ordersCreated
   */
  export type User$ordersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.ordersApproved
   */
  export type User$ordersApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.invoicesCreated
   */
  export type User$invoicesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.paymentsReceived
   */
  export type User$paymentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.printAudits
   */
  export type User$printAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    where?: PrintAuditWhereInput
    orderBy?: PrintAuditOrderByWithRelationInput | PrintAuditOrderByWithRelationInput[]
    cursor?: PrintAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrintAuditScalarFieldEnum | PrintAuditScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    userAgent: number
    ipAddress: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "userAgent" | "ipAddress" | "expiresAt" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      userAgent: string | null
      ipAddress: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userAgent: FieldRef<"RefreshToken", 'String'>
    readonly ipAddress: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model PlatformAdmin
   */

  export type AggregatePlatformAdmin = {
    _count: PlatformAdminCountAggregateOutputType | null
    _avg: PlatformAdminAvgAggregateOutputType | null
    _sum: PlatformAdminSumAggregateOutputType | null
    _min: PlatformAdminMinAggregateOutputType | null
    _max: PlatformAdminMaxAggregateOutputType | null
  }

  export type PlatformAdminAvgAggregateOutputType = {
    failedLogins: number | null
  }

  export type PlatformAdminSumAggregateOutputType = {
    failedLogins: number | null
  }

  export type PlatformAdminMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    department: string | null
    avatar: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformAdminMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    department: string | null
    avatar: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformAdminCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    department: number
    avatar: number
    isActive: number
    lastLoginAt: number
    lastLoginIp: number
    failedLogins: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformAdminAvgAggregateInputType = {
    failedLogins?: true
  }

  export type PlatformAdminSumAggregateInputType = {
    failedLogins?: true
  }

  export type PlatformAdminMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    department?: true
    avatar?: true
    isActive?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformAdminMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    department?: true
    avatar?: true
    isActive?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformAdminCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    department?: true
    avatar?: true
    isActive?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLogins?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformAdmin to aggregate.
     */
    where?: PlatformAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAdmins to fetch.
     */
    orderBy?: PlatformAdminOrderByWithRelationInput | PlatformAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformAdmins
    **/
    _count?: true | PlatformAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformAdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformAdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformAdminMaxAggregateInputType
  }

  export type GetPlatformAdminAggregateType<T extends PlatformAdminAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformAdmin[P]>
      : GetScalarType<T[P], AggregatePlatformAdmin[P]>
  }




  export type PlatformAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAdminWhereInput
    orderBy?: PlatformAdminOrderByWithAggregationInput | PlatformAdminOrderByWithAggregationInput[]
    by: PlatformAdminScalarFieldEnum[] | PlatformAdminScalarFieldEnum
    having?: PlatformAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformAdminCountAggregateInputType | true
    _avg?: PlatformAdminAvgAggregateInputType
    _sum?: PlatformAdminSumAggregateInputType
    _min?: PlatformAdminMinAggregateInputType
    _max?: PlatformAdminMaxAggregateInputType
  }

  export type PlatformAdminGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    role: string
    department: string | null
    avatar: string | null
    isActive: boolean
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLogins: number
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlatformAdminCountAggregateOutputType | null
    _avg: PlatformAdminAvgAggregateOutputType | null
    _sum: PlatformAdminSumAggregateOutputType | null
    _min: PlatformAdminMinAggregateOutputType | null
    _max: PlatformAdminMaxAggregateOutputType | null
  }

  type GetPlatformAdminGroupByPayload<T extends PlatformAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformAdminGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformAdminGroupByOutputType[P]>
        }
      >
    >


  export type PlatformAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refreshTokens?: boolean | PlatformAdmin$refreshTokensArgs<ExtArgs>
    _count?: boolean | PlatformAdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAdmin"]>

  export type PlatformAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platformAdmin"]>

  export type PlatformAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platformAdmin"]>

  export type PlatformAdminSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    department?: boolean
    avatar?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLogins?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "role" | "department" | "avatar" | "isActive" | "lastLoginAt" | "lastLoginIp" | "failedLogins" | "lockedUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["platformAdmin"]>
  export type PlatformAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | PlatformAdmin$refreshTokensArgs<ExtArgs>
    _count?: boolean | PlatformAdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlatformAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlatformAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlatformAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformAdmin"
    objects: {
      refreshTokens: Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      role: string
      department: string | null
      avatar: string | null
      isActive: boolean
      lastLoginAt: Date | null
      lastLoginIp: string | null
      failedLogins: number
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platformAdmin"]>
    composites: {}
  }

  type PlatformAdminGetPayload<S extends boolean | null | undefined | PlatformAdminDefaultArgs> = $Result.GetResult<Prisma.$PlatformAdminPayload, S>

  type PlatformAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformAdminCountAggregateInputType | true
    }

  export interface PlatformAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformAdmin'], meta: { name: 'PlatformAdmin' } }
    /**
     * Find zero or one PlatformAdmin that matches the filter.
     * @param {PlatformAdminFindUniqueArgs} args - Arguments to find a PlatformAdmin
     * @example
     * // Get one PlatformAdmin
     * const platformAdmin = await prisma.platformAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformAdminFindUniqueArgs>(args: SelectSubset<T, PlatformAdminFindUniqueArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformAdminFindUniqueOrThrowArgs} args - Arguments to find a PlatformAdmin
     * @example
     * // Get one PlatformAdmin
     * const platformAdmin = await prisma.platformAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminFindFirstArgs} args - Arguments to find a PlatformAdmin
     * @example
     * // Get one PlatformAdmin
     * const platformAdmin = await prisma.platformAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformAdminFindFirstArgs>(args?: SelectSubset<T, PlatformAdminFindFirstArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminFindFirstOrThrowArgs} args - Arguments to find a PlatformAdmin
     * @example
     * // Get one PlatformAdmin
     * const platformAdmin = await prisma.platformAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformAdmins
     * const platformAdmins = await prisma.platformAdmin.findMany()
     * 
     * // Get first 10 PlatformAdmins
     * const platformAdmins = await prisma.platformAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformAdminWithIdOnly = await prisma.platformAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformAdminFindManyArgs>(args?: SelectSubset<T, PlatformAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformAdmin.
     * @param {PlatformAdminCreateArgs} args - Arguments to create a PlatformAdmin.
     * @example
     * // Create one PlatformAdmin
     * const PlatformAdmin = await prisma.platformAdmin.create({
     *   data: {
     *     // ... data to create a PlatformAdmin
     *   }
     * })
     * 
     */
    create<T extends PlatformAdminCreateArgs>(args: SelectSubset<T, PlatformAdminCreateArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformAdmins.
     * @param {PlatformAdminCreateManyArgs} args - Arguments to create many PlatformAdmins.
     * @example
     * // Create many PlatformAdmins
     * const platformAdmin = await prisma.platformAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformAdminCreateManyArgs>(args?: SelectSubset<T, PlatformAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformAdmins and returns the data saved in the database.
     * @param {PlatformAdminCreateManyAndReturnArgs} args - Arguments to create many PlatformAdmins.
     * @example
     * // Create many PlatformAdmins
     * const platformAdmin = await prisma.platformAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformAdmins and only return the `id`
     * const platformAdminWithIdOnly = await prisma.platformAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlatformAdmin.
     * @param {PlatformAdminDeleteArgs} args - Arguments to delete one PlatformAdmin.
     * @example
     * // Delete one PlatformAdmin
     * const PlatformAdmin = await prisma.platformAdmin.delete({
     *   where: {
     *     // ... filter to delete one PlatformAdmin
     *   }
     * })
     * 
     */
    delete<T extends PlatformAdminDeleteArgs>(args: SelectSubset<T, PlatformAdminDeleteArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformAdmin.
     * @param {PlatformAdminUpdateArgs} args - Arguments to update one PlatformAdmin.
     * @example
     * // Update one PlatformAdmin
     * const platformAdmin = await prisma.platformAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformAdminUpdateArgs>(args: SelectSubset<T, PlatformAdminUpdateArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformAdmins.
     * @param {PlatformAdminDeleteManyArgs} args - Arguments to filter PlatformAdmins to delete.
     * @example
     * // Delete a few PlatformAdmins
     * const { count } = await prisma.platformAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformAdminDeleteManyArgs>(args?: SelectSubset<T, PlatformAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformAdmins
     * const platformAdmin = await prisma.platformAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformAdminUpdateManyArgs>(args: SelectSubset<T, PlatformAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformAdmins and returns the data updated in the database.
     * @param {PlatformAdminUpdateManyAndReturnArgs} args - Arguments to update many PlatformAdmins.
     * @example
     * // Update many PlatformAdmins
     * const platformAdmin = await prisma.platformAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlatformAdmins and only return the `id`
     * const platformAdminWithIdOnly = await prisma.platformAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlatformAdmin.
     * @param {PlatformAdminUpsertArgs} args - Arguments to update or create a PlatformAdmin.
     * @example
     * // Update or create a PlatformAdmin
     * const platformAdmin = await prisma.platformAdmin.upsert({
     *   create: {
     *     // ... data to create a PlatformAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformAdmin we want to update
     *   }
     * })
     */
    upsert<T extends PlatformAdminUpsertArgs>(args: SelectSubset<T, PlatformAdminUpsertArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminCountArgs} args - Arguments to filter PlatformAdmins to count.
     * @example
     * // Count the number of PlatformAdmins
     * const count = await prisma.platformAdmin.count({
     *   where: {
     *     // ... the filter for the PlatformAdmins we want to count
     *   }
     * })
    **/
    count<T extends PlatformAdminCountArgs>(
      args?: Subset<T, PlatformAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAdminAggregateArgs>(args: Subset<T, PlatformAdminAggregateArgs>): Prisma.PrismaPromise<GetPlatformAdminAggregateType<T>>

    /**
     * Group by PlatformAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformAdminGroupByArgs['orderBy'] }
        : { orderBy?: PlatformAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformAdmin model
   */
  readonly fields: PlatformAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refreshTokens<T extends PlatformAdmin$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, PlatformAdmin$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformAdmin model
   */
  interface PlatformAdminFieldRefs {
    readonly id: FieldRef<"PlatformAdmin", 'String'>
    readonly email: FieldRef<"PlatformAdmin", 'String'>
    readonly name: FieldRef<"PlatformAdmin", 'String'>
    readonly password: FieldRef<"PlatformAdmin", 'String'>
    readonly role: FieldRef<"PlatformAdmin", 'String'>
    readonly department: FieldRef<"PlatformAdmin", 'String'>
    readonly avatar: FieldRef<"PlatformAdmin", 'String'>
    readonly isActive: FieldRef<"PlatformAdmin", 'Boolean'>
    readonly lastLoginAt: FieldRef<"PlatformAdmin", 'DateTime'>
    readonly lastLoginIp: FieldRef<"PlatformAdmin", 'String'>
    readonly failedLogins: FieldRef<"PlatformAdmin", 'Int'>
    readonly lockedUntil: FieldRef<"PlatformAdmin", 'DateTime'>
    readonly createdAt: FieldRef<"PlatformAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"PlatformAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformAdmin findUnique
   */
  export type PlatformAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdmin to fetch.
     */
    where: PlatformAdminWhereUniqueInput
  }

  /**
   * PlatformAdmin findUniqueOrThrow
   */
  export type PlatformAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdmin to fetch.
     */
    where: PlatformAdminWhereUniqueInput
  }

  /**
   * PlatformAdmin findFirst
   */
  export type PlatformAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdmin to fetch.
     */
    where?: PlatformAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAdmins to fetch.
     */
    orderBy?: PlatformAdminOrderByWithRelationInput | PlatformAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformAdmins.
     */
    cursor?: PlatformAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformAdmins.
     */
    distinct?: PlatformAdminScalarFieldEnum | PlatformAdminScalarFieldEnum[]
  }

  /**
   * PlatformAdmin findFirstOrThrow
   */
  export type PlatformAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdmin to fetch.
     */
    where?: PlatformAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAdmins to fetch.
     */
    orderBy?: PlatformAdminOrderByWithRelationInput | PlatformAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformAdmins.
     */
    cursor?: PlatformAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformAdmins.
     */
    distinct?: PlatformAdminScalarFieldEnum | PlatformAdminScalarFieldEnum[]
  }

  /**
   * PlatformAdmin findMany
   */
  export type PlatformAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdmins to fetch.
     */
    where?: PlatformAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAdmins to fetch.
     */
    orderBy?: PlatformAdminOrderByWithRelationInput | PlatformAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformAdmins.
     */
    cursor?: PlatformAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAdmins.
     */
    skip?: number
    distinct?: PlatformAdminScalarFieldEnum | PlatformAdminScalarFieldEnum[]
  }

  /**
   * PlatformAdmin create
   */
  export type PlatformAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformAdmin.
     */
    data: XOR<PlatformAdminCreateInput, PlatformAdminUncheckedCreateInput>
  }

  /**
   * PlatformAdmin createMany
   */
  export type PlatformAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformAdmins.
     */
    data: PlatformAdminCreateManyInput | PlatformAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformAdmin createManyAndReturn
   */
  export type PlatformAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * The data used to create many PlatformAdmins.
     */
    data: PlatformAdminCreateManyInput | PlatformAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformAdmin update
   */
  export type PlatformAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformAdmin.
     */
    data: XOR<PlatformAdminUpdateInput, PlatformAdminUncheckedUpdateInput>
    /**
     * Choose, which PlatformAdmin to update.
     */
    where: PlatformAdminWhereUniqueInput
  }

  /**
   * PlatformAdmin updateMany
   */
  export type PlatformAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformAdmins.
     */
    data: XOR<PlatformAdminUpdateManyMutationInput, PlatformAdminUncheckedUpdateManyInput>
    /**
     * Filter which PlatformAdmins to update
     */
    where?: PlatformAdminWhereInput
    /**
     * Limit how many PlatformAdmins to update.
     */
    limit?: number
  }

  /**
   * PlatformAdmin updateManyAndReturn
   */
  export type PlatformAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * The data used to update PlatformAdmins.
     */
    data: XOR<PlatformAdminUpdateManyMutationInput, PlatformAdminUncheckedUpdateManyInput>
    /**
     * Filter which PlatformAdmins to update
     */
    where?: PlatformAdminWhereInput
    /**
     * Limit how many PlatformAdmins to update.
     */
    limit?: number
  }

  /**
   * PlatformAdmin upsert
   */
  export type PlatformAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformAdmin to update in case it exists.
     */
    where: PlatformAdminWhereUniqueInput
    /**
     * In case the PlatformAdmin found by the `where` argument doesn't exist, create a new PlatformAdmin with this data.
     */
    create: XOR<PlatformAdminCreateInput, PlatformAdminUncheckedCreateInput>
    /**
     * In case the PlatformAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformAdminUpdateInput, PlatformAdminUncheckedUpdateInput>
  }

  /**
   * PlatformAdmin delete
   */
  export type PlatformAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
    /**
     * Filter which PlatformAdmin to delete.
     */
    where: PlatformAdminWhereUniqueInput
  }

  /**
   * PlatformAdmin deleteMany
   */
  export type PlatformAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformAdmins to delete
     */
    where?: PlatformAdminWhereInput
    /**
     * Limit how many PlatformAdmins to delete.
     */
    limit?: number
  }

  /**
   * PlatformAdmin.refreshTokens
   */
  export type PlatformAdmin$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    where?: PlatformAdminRefreshTokenWhereInput
    orderBy?: PlatformAdminRefreshTokenOrderByWithRelationInput | PlatformAdminRefreshTokenOrderByWithRelationInput[]
    cursor?: PlatformAdminRefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformAdminRefreshTokenScalarFieldEnum | PlatformAdminRefreshTokenScalarFieldEnum[]
  }

  /**
   * PlatformAdmin without action
   */
  export type PlatformAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdmin
     */
    select?: PlatformAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdmin
     */
    omit?: PlatformAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminInclude<ExtArgs> | null
  }


  /**
   * Model PlatformAdminRefreshToken
   */

  export type AggregatePlatformAdminRefreshToken = {
    _count: PlatformAdminRefreshTokenCountAggregateOutputType | null
    _min: PlatformAdminRefreshTokenMinAggregateOutputType | null
    _max: PlatformAdminRefreshTokenMaxAggregateOutputType | null
  }

  export type PlatformAdminRefreshTokenMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    token: string | null
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PlatformAdminRefreshTokenMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    token: string | null
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type PlatformAdminRefreshTokenCountAggregateOutputType = {
    id: number
    adminId: number
    token: number
    userAgent: number
    ipAddress: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type PlatformAdminRefreshTokenMinAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PlatformAdminRefreshTokenMaxAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
  }

  export type PlatformAdminRefreshTokenCountAggregateInputType = {
    id?: true
    adminId?: true
    token?: true
    userAgent?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type PlatformAdminRefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformAdminRefreshToken to aggregate.
     */
    where?: PlatformAdminRefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAdminRefreshTokens to fetch.
     */
    orderBy?: PlatformAdminRefreshTokenOrderByWithRelationInput | PlatformAdminRefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformAdminRefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAdminRefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAdminRefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformAdminRefreshTokens
    **/
    _count?: true | PlatformAdminRefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformAdminRefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformAdminRefreshTokenMaxAggregateInputType
  }

  export type GetPlatformAdminRefreshTokenAggregateType<T extends PlatformAdminRefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformAdminRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformAdminRefreshToken[P]>
      : GetScalarType<T[P], AggregatePlatformAdminRefreshToken[P]>
  }




  export type PlatformAdminRefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAdminRefreshTokenWhereInput
    orderBy?: PlatformAdminRefreshTokenOrderByWithAggregationInput | PlatformAdminRefreshTokenOrderByWithAggregationInput[]
    by: PlatformAdminRefreshTokenScalarFieldEnum[] | PlatformAdminRefreshTokenScalarFieldEnum
    having?: PlatformAdminRefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformAdminRefreshTokenCountAggregateInputType | true
    _min?: PlatformAdminRefreshTokenMinAggregateInputType
    _max?: PlatformAdminRefreshTokenMaxAggregateInputType
  }

  export type PlatformAdminRefreshTokenGroupByOutputType = {
    id: string
    adminId: string
    token: string
    userAgent: string | null
    ipAddress: string | null
    expiresAt: Date
    createdAt: Date
    _count: PlatformAdminRefreshTokenCountAggregateOutputType | null
    _min: PlatformAdminRefreshTokenMinAggregateOutputType | null
    _max: PlatformAdminRefreshTokenMaxAggregateOutputType | null
  }

  type GetPlatformAdminRefreshTokenGroupByPayload<T extends PlatformAdminRefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformAdminRefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformAdminRefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformAdminRefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformAdminRefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type PlatformAdminRefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    admin?: boolean | PlatformAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAdminRefreshToken"]>

  export type PlatformAdminRefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    admin?: boolean | PlatformAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAdminRefreshToken"]>

  export type PlatformAdminRefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    token?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    admin?: boolean | PlatformAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAdminRefreshToken"]>

  export type PlatformAdminRefreshTokenSelectScalar = {
    id?: boolean
    adminId?: boolean
    token?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type PlatformAdminRefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "token" | "userAgent" | "ipAddress" | "expiresAt" | "createdAt", ExtArgs["result"]["platformAdminRefreshToken"]>
  export type PlatformAdminRefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | PlatformAdminDefaultArgs<ExtArgs>
  }
  export type PlatformAdminRefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | PlatformAdminDefaultArgs<ExtArgs>
  }
  export type PlatformAdminRefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | PlatformAdminDefaultArgs<ExtArgs>
  }

  export type $PlatformAdminRefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformAdminRefreshToken"
    objects: {
      admin: Prisma.$PlatformAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      token: string
      userAgent: string | null
      ipAddress: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["platformAdminRefreshToken"]>
    composites: {}
  }

  type PlatformAdminRefreshTokenGetPayload<S extends boolean | null | undefined | PlatformAdminRefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload, S>

  type PlatformAdminRefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformAdminRefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformAdminRefreshTokenCountAggregateInputType | true
    }

  export interface PlatformAdminRefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformAdminRefreshToken'], meta: { name: 'PlatformAdminRefreshToken' } }
    /**
     * Find zero or one PlatformAdminRefreshToken that matches the filter.
     * @param {PlatformAdminRefreshTokenFindUniqueArgs} args - Arguments to find a PlatformAdminRefreshToken
     * @example
     * // Get one PlatformAdminRefreshToken
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformAdminRefreshTokenFindUniqueArgs>(args: SelectSubset<T, PlatformAdminRefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__PlatformAdminRefreshTokenClient<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformAdminRefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformAdminRefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a PlatformAdminRefreshToken
     * @example
     * // Get one PlatformAdminRefreshToken
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformAdminRefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformAdminRefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformAdminRefreshTokenClient<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformAdminRefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminRefreshTokenFindFirstArgs} args - Arguments to find a PlatformAdminRefreshToken
     * @example
     * // Get one PlatformAdminRefreshToken
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformAdminRefreshTokenFindFirstArgs>(args?: SelectSubset<T, PlatformAdminRefreshTokenFindFirstArgs<ExtArgs>>): Prisma__PlatformAdminRefreshTokenClient<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformAdminRefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminRefreshTokenFindFirstOrThrowArgs} args - Arguments to find a PlatformAdminRefreshToken
     * @example
     * // Get one PlatformAdminRefreshToken
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformAdminRefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformAdminRefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformAdminRefreshTokenClient<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformAdminRefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminRefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformAdminRefreshTokens
     * const platformAdminRefreshTokens = await prisma.platformAdminRefreshToken.findMany()
     * 
     * // Get first 10 PlatformAdminRefreshTokens
     * const platformAdminRefreshTokens = await prisma.platformAdminRefreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformAdminRefreshTokenWithIdOnly = await prisma.platformAdminRefreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformAdminRefreshTokenFindManyArgs>(args?: SelectSubset<T, PlatformAdminRefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformAdminRefreshToken.
     * @param {PlatformAdminRefreshTokenCreateArgs} args - Arguments to create a PlatformAdminRefreshToken.
     * @example
     * // Create one PlatformAdminRefreshToken
     * const PlatformAdminRefreshToken = await prisma.platformAdminRefreshToken.create({
     *   data: {
     *     // ... data to create a PlatformAdminRefreshToken
     *   }
     * })
     * 
     */
    create<T extends PlatformAdminRefreshTokenCreateArgs>(args: SelectSubset<T, PlatformAdminRefreshTokenCreateArgs<ExtArgs>>): Prisma__PlatformAdminRefreshTokenClient<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformAdminRefreshTokens.
     * @param {PlatformAdminRefreshTokenCreateManyArgs} args - Arguments to create many PlatformAdminRefreshTokens.
     * @example
     * // Create many PlatformAdminRefreshTokens
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformAdminRefreshTokenCreateManyArgs>(args?: SelectSubset<T, PlatformAdminRefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformAdminRefreshTokens and returns the data saved in the database.
     * @param {PlatformAdminRefreshTokenCreateManyAndReturnArgs} args - Arguments to create many PlatformAdminRefreshTokens.
     * @example
     * // Create many PlatformAdminRefreshTokens
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformAdminRefreshTokens and only return the `id`
     * const platformAdminRefreshTokenWithIdOnly = await prisma.platformAdminRefreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformAdminRefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformAdminRefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlatformAdminRefreshToken.
     * @param {PlatformAdminRefreshTokenDeleteArgs} args - Arguments to delete one PlatformAdminRefreshToken.
     * @example
     * // Delete one PlatformAdminRefreshToken
     * const PlatformAdminRefreshToken = await prisma.platformAdminRefreshToken.delete({
     *   where: {
     *     // ... filter to delete one PlatformAdminRefreshToken
     *   }
     * })
     * 
     */
    delete<T extends PlatformAdminRefreshTokenDeleteArgs>(args: SelectSubset<T, PlatformAdminRefreshTokenDeleteArgs<ExtArgs>>): Prisma__PlatformAdminRefreshTokenClient<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformAdminRefreshToken.
     * @param {PlatformAdminRefreshTokenUpdateArgs} args - Arguments to update one PlatformAdminRefreshToken.
     * @example
     * // Update one PlatformAdminRefreshToken
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformAdminRefreshTokenUpdateArgs>(args: SelectSubset<T, PlatformAdminRefreshTokenUpdateArgs<ExtArgs>>): Prisma__PlatformAdminRefreshTokenClient<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformAdminRefreshTokens.
     * @param {PlatformAdminRefreshTokenDeleteManyArgs} args - Arguments to filter PlatformAdminRefreshTokens to delete.
     * @example
     * // Delete a few PlatformAdminRefreshTokens
     * const { count } = await prisma.platformAdminRefreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformAdminRefreshTokenDeleteManyArgs>(args?: SelectSubset<T, PlatformAdminRefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformAdminRefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminRefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformAdminRefreshTokens
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformAdminRefreshTokenUpdateManyArgs>(args: SelectSubset<T, PlatformAdminRefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformAdminRefreshTokens and returns the data updated in the database.
     * @param {PlatformAdminRefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many PlatformAdminRefreshTokens.
     * @example
     * // Update many PlatformAdminRefreshTokens
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlatformAdminRefreshTokens and only return the `id`
     * const platformAdminRefreshTokenWithIdOnly = await prisma.platformAdminRefreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformAdminRefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformAdminRefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlatformAdminRefreshToken.
     * @param {PlatformAdminRefreshTokenUpsertArgs} args - Arguments to update or create a PlatformAdminRefreshToken.
     * @example
     * // Update or create a PlatformAdminRefreshToken
     * const platformAdminRefreshToken = await prisma.platformAdminRefreshToken.upsert({
     *   create: {
     *     // ... data to create a PlatformAdminRefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformAdminRefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends PlatformAdminRefreshTokenUpsertArgs>(args: SelectSubset<T, PlatformAdminRefreshTokenUpsertArgs<ExtArgs>>): Prisma__PlatformAdminRefreshTokenClient<$Result.GetResult<Prisma.$PlatformAdminRefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformAdminRefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminRefreshTokenCountArgs} args - Arguments to filter PlatformAdminRefreshTokens to count.
     * @example
     * // Count the number of PlatformAdminRefreshTokens
     * const count = await prisma.platformAdminRefreshToken.count({
     *   where: {
     *     // ... the filter for the PlatformAdminRefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends PlatformAdminRefreshTokenCountArgs>(
      args?: Subset<T, PlatformAdminRefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformAdminRefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformAdminRefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminRefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAdminRefreshTokenAggregateArgs>(args: Subset<T, PlatformAdminRefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetPlatformAdminRefreshTokenAggregateType<T>>

    /**
     * Group by PlatformAdminRefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAdminRefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformAdminRefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformAdminRefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: PlatformAdminRefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformAdminRefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformAdminRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformAdminRefreshToken model
   */
  readonly fields: PlatformAdminRefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformAdminRefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformAdminRefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends PlatformAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlatformAdminDefaultArgs<ExtArgs>>): Prisma__PlatformAdminClient<$Result.GetResult<Prisma.$PlatformAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformAdminRefreshToken model
   */
  interface PlatformAdminRefreshTokenFieldRefs {
    readonly id: FieldRef<"PlatformAdminRefreshToken", 'String'>
    readonly adminId: FieldRef<"PlatformAdminRefreshToken", 'String'>
    readonly token: FieldRef<"PlatformAdminRefreshToken", 'String'>
    readonly userAgent: FieldRef<"PlatformAdminRefreshToken", 'String'>
    readonly ipAddress: FieldRef<"PlatformAdminRefreshToken", 'String'>
    readonly expiresAt: FieldRef<"PlatformAdminRefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"PlatformAdminRefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformAdminRefreshToken findUnique
   */
  export type PlatformAdminRefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdminRefreshToken to fetch.
     */
    where: PlatformAdminRefreshTokenWhereUniqueInput
  }

  /**
   * PlatformAdminRefreshToken findUniqueOrThrow
   */
  export type PlatformAdminRefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdminRefreshToken to fetch.
     */
    where: PlatformAdminRefreshTokenWhereUniqueInput
  }

  /**
   * PlatformAdminRefreshToken findFirst
   */
  export type PlatformAdminRefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdminRefreshToken to fetch.
     */
    where?: PlatformAdminRefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAdminRefreshTokens to fetch.
     */
    orderBy?: PlatformAdminRefreshTokenOrderByWithRelationInput | PlatformAdminRefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformAdminRefreshTokens.
     */
    cursor?: PlatformAdminRefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAdminRefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAdminRefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformAdminRefreshTokens.
     */
    distinct?: PlatformAdminRefreshTokenScalarFieldEnum | PlatformAdminRefreshTokenScalarFieldEnum[]
  }

  /**
   * PlatformAdminRefreshToken findFirstOrThrow
   */
  export type PlatformAdminRefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdminRefreshToken to fetch.
     */
    where?: PlatformAdminRefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAdminRefreshTokens to fetch.
     */
    orderBy?: PlatformAdminRefreshTokenOrderByWithRelationInput | PlatformAdminRefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformAdminRefreshTokens.
     */
    cursor?: PlatformAdminRefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAdminRefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAdminRefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformAdminRefreshTokens.
     */
    distinct?: PlatformAdminRefreshTokenScalarFieldEnum | PlatformAdminRefreshTokenScalarFieldEnum[]
  }

  /**
   * PlatformAdminRefreshToken findMany
   */
  export type PlatformAdminRefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAdminRefreshTokens to fetch.
     */
    where?: PlatformAdminRefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAdminRefreshTokens to fetch.
     */
    orderBy?: PlatformAdminRefreshTokenOrderByWithRelationInput | PlatformAdminRefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformAdminRefreshTokens.
     */
    cursor?: PlatformAdminRefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAdminRefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAdminRefreshTokens.
     */
    skip?: number
    distinct?: PlatformAdminRefreshTokenScalarFieldEnum | PlatformAdminRefreshTokenScalarFieldEnum[]
  }

  /**
   * PlatformAdminRefreshToken create
   */
  export type PlatformAdminRefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformAdminRefreshToken.
     */
    data: XOR<PlatformAdminRefreshTokenCreateInput, PlatformAdminRefreshTokenUncheckedCreateInput>
  }

  /**
   * PlatformAdminRefreshToken createMany
   */
  export type PlatformAdminRefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformAdminRefreshTokens.
     */
    data: PlatformAdminRefreshTokenCreateManyInput | PlatformAdminRefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformAdminRefreshToken createManyAndReturn
   */
  export type PlatformAdminRefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PlatformAdminRefreshTokens.
     */
    data: PlatformAdminRefreshTokenCreateManyInput | PlatformAdminRefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformAdminRefreshToken update
   */
  export type PlatformAdminRefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformAdminRefreshToken.
     */
    data: XOR<PlatformAdminRefreshTokenUpdateInput, PlatformAdminRefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which PlatformAdminRefreshToken to update.
     */
    where: PlatformAdminRefreshTokenWhereUniqueInput
  }

  /**
   * PlatformAdminRefreshToken updateMany
   */
  export type PlatformAdminRefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformAdminRefreshTokens.
     */
    data: XOR<PlatformAdminRefreshTokenUpdateManyMutationInput, PlatformAdminRefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which PlatformAdminRefreshTokens to update
     */
    where?: PlatformAdminRefreshTokenWhereInput
    /**
     * Limit how many PlatformAdminRefreshTokens to update.
     */
    limit?: number
  }

  /**
   * PlatformAdminRefreshToken updateManyAndReturn
   */
  export type PlatformAdminRefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update PlatformAdminRefreshTokens.
     */
    data: XOR<PlatformAdminRefreshTokenUpdateManyMutationInput, PlatformAdminRefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which PlatformAdminRefreshTokens to update
     */
    where?: PlatformAdminRefreshTokenWhereInput
    /**
     * Limit how many PlatformAdminRefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformAdminRefreshToken upsert
   */
  export type PlatformAdminRefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformAdminRefreshToken to update in case it exists.
     */
    where: PlatformAdminRefreshTokenWhereUniqueInput
    /**
     * In case the PlatformAdminRefreshToken found by the `where` argument doesn't exist, create a new PlatformAdminRefreshToken with this data.
     */
    create: XOR<PlatformAdminRefreshTokenCreateInput, PlatformAdminRefreshTokenUncheckedCreateInput>
    /**
     * In case the PlatformAdminRefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformAdminRefreshTokenUpdateInput, PlatformAdminRefreshTokenUncheckedUpdateInput>
  }

  /**
   * PlatformAdminRefreshToken delete
   */
  export type PlatformAdminRefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which PlatformAdminRefreshToken to delete.
     */
    where: PlatformAdminRefreshTokenWhereUniqueInput
  }

  /**
   * PlatformAdminRefreshToken deleteMany
   */
  export type PlatformAdminRefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformAdminRefreshTokens to delete
     */
    where?: PlatformAdminRefreshTokenWhereInput
    /**
     * Limit how many PlatformAdminRefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * PlatformAdminRefreshToken without action
   */
  export type PlatformAdminRefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAdminRefreshToken
     */
    select?: PlatformAdminRefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAdminRefreshToken
     */
    omit?: PlatformAdminRefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAdminRefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    displayName: string | null
    description: string | null
    color: string | null
    isSystem: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    displayName: string | null
    description: string | null
    color: string | null
    isSystem: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    displayName: number
    description: number
    color: number
    isSystem: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    displayName?: true
    description?: true
    color?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    displayName?: true
    description?: true
    color?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    displayName?: true
    description?: true
    color?: true
    isSystem?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    displayName: string
    description: string | null
    color: string | null
    isSystem: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    color?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    color?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    color?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    color?: boolean
    isSystem?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "displayName" | "description" | "color" | "isSystem" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>[]
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      displayName: string
      description: string | null
      color: string | null
      isSystem: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly tenantId: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly displayName: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly color: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly isActive: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
    readonly deletedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type PermissionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    module: string | null
    action: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    module: string | null
    action: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    module: number
    action: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type PermissionSumAggregateInputType = {
    sortOrder?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    module?: true
    action?: true
    sortOrder?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    module?: true
    action?: true
    sortOrder?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    module?: true
    action?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    module: string
    action: string
    sortOrder: number
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    module?: boolean
    action?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    module?: boolean
    action?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    module?: boolean
    action?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    module?: boolean
    action?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "module" | "action" | "sortOrder" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      module: string
      action: string
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly code: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly module: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly sortOrder: FieldRef<"Permission", 'Int'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId" | "createdAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model License
   */

  export type AggregateLicense = {
    _count: LicenseCountAggregateOutputType | null
    _avg: LicenseAvgAggregateOutputType | null
    _sum: LicenseSumAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  export type LicenseAvgAggregateOutputType = {
    maxUsers: number | null
    maxProducts: number | null
  }

  export type LicenseSumAggregateOutputType = {
    maxUsers: number | null
    maxProducts: number | null
  }

  export type LicenseMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tier: $Enums.LicenseTier | null
    licenseKey: string | null
    maxUsers: number | null
    maxProducts: number | null
    startsAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LicenseMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tier: $Enums.LicenseTier | null
    licenseKey: string | null
    maxUsers: number | null
    maxProducts: number | null
    startsAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LicenseCountAggregateOutputType = {
    id: number
    tenantId: number
    tier: number
    licenseKey: number
    features: number
    maxUsers: number
    maxProducts: number
    startsAt: number
    expiresAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LicenseAvgAggregateInputType = {
    maxUsers?: true
    maxProducts?: true
  }

  export type LicenseSumAggregateInputType = {
    maxUsers?: true
    maxProducts?: true
  }

  export type LicenseMinAggregateInputType = {
    id?: true
    tenantId?: true
    tier?: true
    licenseKey?: true
    maxUsers?: true
    maxProducts?: true
    startsAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LicenseMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tier?: true
    licenseKey?: true
    maxUsers?: true
    maxProducts?: true
    startsAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LicenseCountAggregateInputType = {
    id?: true
    tenantId?: true
    tier?: true
    licenseKey?: true
    features?: true
    maxUsers?: true
    maxProducts?: true
    startsAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which License to aggregate.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenses
    **/
    _count?: true | LicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LicenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LicenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseMaxAggregateInputType
  }

  export type GetLicenseAggregateType<T extends LicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicense[P]>
      : GetScalarType<T[P], AggregateLicense[P]>
  }




  export type LicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithAggregationInput | LicenseOrderByWithAggregationInput[]
    by: LicenseScalarFieldEnum[] | LicenseScalarFieldEnum
    having?: LicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseCountAggregateInputType | true
    _avg?: LicenseAvgAggregateInputType
    _sum?: LicenseSumAggregateInputType
    _min?: LicenseMinAggregateInputType
    _max?: LicenseMaxAggregateInputType
  }

  export type LicenseGroupByOutputType = {
    id: string
    tenantId: string
    tier: $Enums.LicenseTier
    licenseKey: string
    features: JsonValue
    maxUsers: number
    maxProducts: number | null
    startsAt: Date
    expiresAt: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LicenseCountAggregateOutputType | null
    _avg: LicenseAvgAggregateOutputType | null
    _sum: LicenseSumAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  type GetLicenseGroupByPayload<T extends LicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseGroupByOutputType[P]>
        }
      >
    >


  export type LicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tier?: boolean
    licenseKey?: boolean
    features?: boolean
    maxUsers?: boolean
    maxProducts?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tier?: boolean
    licenseKey?: boolean
    features?: boolean
    maxUsers?: boolean
    maxProducts?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tier?: boolean
    licenseKey?: boolean
    features?: boolean
    maxUsers?: boolean
    maxProducts?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tier?: boolean
    licenseKey?: boolean
    features?: boolean
    maxUsers?: boolean
    maxProducts?: boolean
    startsAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LicenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "tier" | "licenseKey" | "features" | "maxUsers" | "maxProducts" | "startsAt" | "expiresAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["license"]>
  export type LicenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LicenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LicenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $LicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "License"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tier: $Enums.LicenseTier
      licenseKey: string
      features: Prisma.JsonValue
      maxUsers: number
      maxProducts: number | null
      startsAt: Date
      expiresAt: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["license"]>
    composites: {}
  }

  type LicenseGetPayload<S extends boolean | null | undefined | LicenseDefaultArgs> = $Result.GetResult<Prisma.$LicensePayload, S>

  type LicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LicenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LicenseCountAggregateInputType | true
    }

  export interface LicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['License'], meta: { name: 'License' } }
    /**
     * Find zero or one License that matches the filter.
     * @param {LicenseFindUniqueArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseFindUniqueArgs>(args: SelectSubset<T, LicenseFindUniqueArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one License that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LicenseFindUniqueOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseFindFirstArgs>(args?: SelectSubset<T, LicenseFindFirstArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenses
     * const licenses = await prisma.license.findMany()
     * 
     * // Get first 10 Licenses
     * const licenses = await prisma.license.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenseWithIdOnly = await prisma.license.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenseFindManyArgs>(args?: SelectSubset<T, LicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a License.
     * @param {LicenseCreateArgs} args - Arguments to create a License.
     * @example
     * // Create one License
     * const License = await prisma.license.create({
     *   data: {
     *     // ... data to create a License
     *   }
     * })
     * 
     */
    create<T extends LicenseCreateArgs>(args: SelectSubset<T, LicenseCreateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Licenses.
     * @param {LicenseCreateManyArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseCreateManyArgs>(args?: SelectSubset<T, LicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Licenses and returns the data saved in the database.
     * @param {LicenseCreateManyAndReturnArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Licenses and only return the `id`
     * const licenseWithIdOnly = await prisma.license.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenseCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a License.
     * @param {LicenseDeleteArgs} args - Arguments to delete one License.
     * @example
     * // Delete one License
     * const License = await prisma.license.delete({
     *   where: {
     *     // ... filter to delete one License
     *   }
     * })
     * 
     */
    delete<T extends LicenseDeleteArgs>(args: SelectSubset<T, LicenseDeleteArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one License.
     * @param {LicenseUpdateArgs} args - Arguments to update one License.
     * @example
     * // Update one License
     * const license = await prisma.license.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseUpdateArgs>(args: SelectSubset<T, LicenseUpdateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Licenses.
     * @param {LicenseDeleteManyArgs} args - Arguments to filter Licenses to delete.
     * @example
     * // Delete a few Licenses
     * const { count } = await prisma.license.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseDeleteManyArgs>(args?: SelectSubset<T, LicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseUpdateManyArgs>(args: SelectSubset<T, LicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses and returns the data updated in the database.
     * @param {LicenseUpdateManyAndReturnArgs} args - Arguments to update many Licenses.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Licenses and only return the `id`
     * const licenseWithIdOnly = await prisma.license.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LicenseUpdateManyAndReturnArgs>(args: SelectSubset<T, LicenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one License.
     * @param {LicenseUpsertArgs} args - Arguments to update or create a License.
     * @example
     * // Update or create a License
     * const license = await prisma.license.upsert({
     *   create: {
     *     // ... data to create a License
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the License we want to update
     *   }
     * })
     */
    upsert<T extends LicenseUpsertArgs>(args: SelectSubset<T, LicenseUpsertArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseCountArgs} args - Arguments to filter Licenses to count.
     * @example
     * // Count the number of Licenses
     * const count = await prisma.license.count({
     *   where: {
     *     // ... the filter for the Licenses we want to count
     *   }
     * })
    **/
    count<T extends LicenseCountArgs>(
      args?: Subset<T, LicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAggregateArgs>(args: Subset<T, LicenseAggregateArgs>): Prisma.PrismaPromise<GetLicenseAggregateType<T>>

    /**
     * Group by License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseGroupByArgs['orderBy'] }
        : { orderBy?: LicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the License model
   */
  readonly fields: LicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for License.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the License model
   */
  interface LicenseFieldRefs {
    readonly id: FieldRef<"License", 'String'>
    readonly tenantId: FieldRef<"License", 'String'>
    readonly tier: FieldRef<"License", 'LicenseTier'>
    readonly licenseKey: FieldRef<"License", 'String'>
    readonly features: FieldRef<"License", 'Json'>
    readonly maxUsers: FieldRef<"License", 'Int'>
    readonly maxProducts: FieldRef<"License", 'Int'>
    readonly startsAt: FieldRef<"License", 'DateTime'>
    readonly expiresAt: FieldRef<"License", 'DateTime'>
    readonly isActive: FieldRef<"License", 'Boolean'>
    readonly createdAt: FieldRef<"License", 'DateTime'>
    readonly updatedAt: FieldRef<"License", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * License findUnique
   */
  export type LicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findUniqueOrThrow
   */
  export type LicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findFirst
   */
  export type LicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findFirstOrThrow
   */
  export type LicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findMany
   */
  export type LicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License create
   */
  export type LicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to create a License.
     */
    data: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
  }

  /**
   * License createMany
   */
  export type LicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * License createManyAndReturn
   */
  export type LicenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * License update
   */
  export type LicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to update a License.
     */
    data: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
    /**
     * Choose, which License to update.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License updateMany
   */
  export type LicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
  }

  /**
   * License updateManyAndReturn
   */
  export type LicenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * License upsert
   */
  export type LicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The filter to search for the License to update in case it exists.
     */
    where: LicenseWhereUniqueInput
    /**
     * In case the License found by the `where` argument doesn't exist, create a new License with this data.
     */
    create: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
    /**
     * In case the License was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
  }

  /**
   * License delete
   */
  export type LicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter which License to delete.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License deleteMany
   */
  export type LicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to delete
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to delete.
     */
    limit?: number
  }

  /**
   * License without action
   */
  export type LicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    parentId: string | null
    name: string | null
    slug: string | null
    description: string | null
    image: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    parentId: string | null
    name: string | null
    slug: string | null
    description: string | null
    image: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    tenantId: number
    parentId: number
    name: number
    slug: number
    description: number
    image: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    tenantId?: true
    parentId?: true
    name?: true
    slug?: true
    description?: true
    image?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    tenantId?: true
    parentId?: true
    name?: true
    slug?: true
    description?: true
    image?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    tenantId?: true
    parentId?: true
    name?: true
    slug?: true
    description?: true
    image?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    tenantId: string
    parentId: string | null
    name: string
    slug: string
    description: string | null
    image: string | null
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    parentId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    image?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    parentId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    image?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    parentId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    image?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    tenantId?: boolean
    parentId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    image?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "parentId" | "name" | "slug" | "description" | "image" | "sortOrder" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      parentId: string | null
      name: string
      slug: string
      description: string | null
      image: string | null
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly tenantId: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly image: FieldRef<"Category", 'String'>
    readonly sortOrder: FieldRef<"Category", 'Int'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly deletedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    cost: Decimal | null
    taxRate: Decimal | null
    minStock: number | null
    maxStock: number | null
    reorderPoint: number | null
    reorderQty: number | null
    weight: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    cost: Decimal | null
    taxRate: Decimal | null
    minStock: number | null
    maxStock: number | null
    reorderPoint: number | null
    reorderQty: number | null
    weight: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    categoryId: string | null
    sku: string | null
    barcode: string | null
    name: string | null
    description: string | null
    unit: string | null
    price: Decimal | null
    cost: Decimal | null
    taxRate: Decimal | null
    minStock: number | null
    maxStock: number | null
    reorderPoint: number | null
    reorderQty: number | null
    weight: Decimal | null
    status: $Enums.ProductStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    categoryId: string | null
    sku: string | null
    barcode: string | null
    name: string | null
    description: string | null
    unit: string | null
    price: Decimal | null
    cost: Decimal | null
    taxRate: Decimal | null
    minStock: number | null
    maxStock: number | null
    reorderPoint: number | null
    reorderQty: number | null
    weight: Decimal | null
    status: $Enums.ProductStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    tenantId: number
    categoryId: number
    sku: number
    barcode: number
    name: number
    description: number
    unit: number
    price: number
    cost: number
    taxRate: number
    minStock: number
    maxStock: number
    reorderPoint: number
    reorderQty: number
    weight: number
    dimensions: number
    images: number
    attributes: number
    status: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    cost?: true
    taxRate?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
    weight?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    cost?: true
    taxRate?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
    weight?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    tenantId?: true
    categoryId?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    unit?: true
    price?: true
    cost?: true
    taxRate?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
    weight?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    tenantId?: true
    categoryId?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    unit?: true
    price?: true
    cost?: true
    taxRate?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
    weight?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    tenantId?: true
    categoryId?: true
    sku?: true
    barcode?: true
    name?: true
    description?: true
    unit?: true
    price?: true
    cost?: true
    taxRate?: true
    minStock?: true
    maxStock?: true
    reorderPoint?: true
    reorderQty?: true
    weight?: true
    dimensions?: true
    images?: true
    attributes?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    tenantId: string
    categoryId: string | null
    sku: string
    barcode: string | null
    name: string
    description: string | null
    unit: string
    price: Decimal
    cost: Decimal
    taxRate: Decimal
    minStock: number
    maxStock: number
    reorderPoint: number
    reorderQty: number
    weight: Decimal | null
    dimensions: JsonValue | null
    images: JsonValue
    attributes: JsonValue
    status: $Enums.ProductStatus
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    categoryId?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    price?: boolean
    cost?: boolean
    taxRate?: boolean
    minStock?: boolean
    maxStock?: boolean
    reorderPoint?: boolean
    reorderQty?: boolean
    weight?: boolean
    dimensions?: boolean
    images?: boolean
    attributes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    inventoryMovements?: boolean | Product$inventoryMovementsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    supplierProducts?: boolean | Product$supplierProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    categoryId?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    price?: boolean
    cost?: boolean
    taxRate?: boolean
    minStock?: boolean
    maxStock?: boolean
    reorderPoint?: boolean
    reorderQty?: boolean
    weight?: boolean
    dimensions?: boolean
    images?: boolean
    attributes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    categoryId?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    price?: boolean
    cost?: boolean
    taxRate?: boolean
    minStock?: boolean
    maxStock?: boolean
    reorderPoint?: boolean
    reorderQty?: boolean
    weight?: boolean
    dimensions?: boolean
    images?: boolean
    attributes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    tenantId?: boolean
    categoryId?: boolean
    sku?: boolean
    barcode?: boolean
    name?: boolean
    description?: boolean
    unit?: boolean
    price?: boolean
    cost?: boolean
    taxRate?: boolean
    minStock?: boolean
    maxStock?: boolean
    reorderPoint?: boolean
    reorderQty?: boolean
    weight?: boolean
    dimensions?: boolean
    images?: boolean
    attributes?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "categoryId" | "sku" | "barcode" | "name" | "description" | "unit" | "price" | "cost" | "taxRate" | "minStock" | "maxStock" | "reorderPoint" | "reorderQty" | "weight" | "dimensions" | "images" | "attributes" | "status" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    inventoryItems?: boolean | Product$inventoryItemsArgs<ExtArgs>
    inventoryMovements?: boolean | Product$inventoryMovementsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    invoiceItems?: boolean | Product$invoiceItemsArgs<ExtArgs>
    supplierProducts?: boolean | Product$supplierProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      supplierProducts: Prisma.$SupplierProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      categoryId: string | null
      sku: string
      barcode: string | null
      name: string
      description: string | null
      unit: string
      price: Prisma.Decimal
      cost: Prisma.Decimal
      taxRate: Prisma.Decimal
      minStock: number
      maxStock: number
      reorderPoint: number
      reorderQty: number
      weight: Prisma.Decimal | null
      dimensions: Prisma.JsonValue | null
      images: Prisma.JsonValue
      attributes: Prisma.JsonValue
      status: $Enums.ProductStatus
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventoryItems<T extends Product$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryMovements<T extends Product$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoiceItems<T extends Product$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supplierProducts<T extends Product$supplierProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$supplierProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly tenantId: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly barcode: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly unit: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly cost: FieldRef<"Product", 'Decimal'>
    readonly taxRate: FieldRef<"Product", 'Decimal'>
    readonly minStock: FieldRef<"Product", 'Int'>
    readonly maxStock: FieldRef<"Product", 'Int'>
    readonly reorderPoint: FieldRef<"Product", 'Int'>
    readonly reorderQty: FieldRef<"Product", 'Int'>
    readonly weight: FieldRef<"Product", 'Decimal'>
    readonly dimensions: FieldRef<"Product", 'Json'>
    readonly images: FieldRef<"Product", 'Json'>
    readonly attributes: FieldRef<"Product", 'Json'>
    readonly status: FieldRef<"Product", 'ProductStatus'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product.inventoryItems
   */
  export type Product$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Product.inventoryMovements
   */
  export type Product$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.invoiceItems
   */
  export type Product$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Product.supplierProducts
   */
  export type Product$supplierProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    cursor?: SupplierProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    manager: string | null
    type: $Enums.WarehouseType | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    manager: string | null
    type: $Enums.WarehouseType | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    tenantId: number
    code: number
    name: number
    address: number
    phone: number
    email: number
    manager: number
    type: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WarehouseMinAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    manager?: true
    type?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    manager?: true
    type?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    manager?: true
    type?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: string
    tenantId: string
    code: string
    name: string
    address: string | null
    phone: string | null
    email: string | null
    manager: string | null
    type: $Enums.WarehouseType
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    manager?: boolean
    type?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    inventoryItems?: boolean | Warehouse$inventoryItemsArgs<ExtArgs>
    movementsFrom?: boolean | Warehouse$movementsFromArgs<ExtArgs>
    movementsTo?: boolean | Warehouse$movementsToArgs<ExtArgs>
    ordersShipFrom?: boolean | Warehouse$ordersShipFromArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    manager?: boolean
    type?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    manager?: boolean
    type?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    manager?: boolean
    type?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "code" | "name" | "address" | "phone" | "email" | "manager" | "type" | "isDefault" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    inventoryItems?: boolean | Warehouse$inventoryItemsArgs<ExtArgs>
    movementsFrom?: boolean | Warehouse$movementsFromArgs<ExtArgs>
    movementsTo?: boolean | Warehouse$movementsToArgs<ExtArgs>
    ordersShipFrom?: boolean | Warehouse$ordersShipFromArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      movementsFrom: Prisma.$InventoryMovementPayload<ExtArgs>[]
      movementsTo: Prisma.$InventoryMovementPayload<ExtArgs>[]
      ordersShipFrom: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      code: string
      name: string
      address: string | null
      phone: string | null
      email: string | null
      manager: string | null
      type: $Enums.WarehouseType
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItems<T extends Warehouse$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movementsFrom<T extends Warehouse$movementsFromArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$movementsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movementsTo<T extends Warehouse$movementsToArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$movementsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordersShipFrom<T extends Warehouse$ordersShipFromArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$ordersShipFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'String'>
    readonly tenantId: FieldRef<"Warehouse", 'String'>
    readonly code: FieldRef<"Warehouse", 'String'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly address: FieldRef<"Warehouse", 'String'>
    readonly phone: FieldRef<"Warehouse", 'String'>
    readonly email: FieldRef<"Warehouse", 'String'>
    readonly manager: FieldRef<"Warehouse", 'String'>
    readonly type: FieldRef<"Warehouse", 'WarehouseType'>
    readonly isDefault: FieldRef<"Warehouse", 'Boolean'>
    readonly isActive: FieldRef<"Warehouse", 'Boolean'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouse", 'DateTime'>
    readonly deletedAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.inventoryItems
   */
  export type Warehouse$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Warehouse.movementsFrom
   */
  export type Warehouse$movementsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Warehouse.movementsTo
   */
  export type Warehouse$movementsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Warehouse.ordersShipFrom
   */
  export type Warehouse$ordersShipFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantity: number | null
    reservedQty: number | null
    availableQty: number | null
    costPrice: Decimal | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantity: number | null
    reservedQty: number | null
    availableQty: number | null
    costPrice: Decimal | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    warehouseId: string | null
    quantity: number | null
    reservedQty: number | null
    availableQty: number | null
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    location: string | null
    costPrice: Decimal | null
    lastCountedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    warehouseId: string | null
    quantity: number | null
    reservedQty: number | null
    availableQty: number | null
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    location: string | null
    costPrice: Decimal | null
    lastCountedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    tenantId: number
    productId: number
    warehouseId: number
    quantity: number
    reservedQty: number
    availableQty: number
    batchNumber: number
    lotNumber: number
    serialNumber: number
    expiryDate: number
    location: number
    costPrice: number
    lastCountedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantity?: true
    reservedQty?: true
    availableQty?: true
    costPrice?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantity?: true
    reservedQty?: true
    availableQty?: true
    costPrice?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    warehouseId?: true
    quantity?: true
    reservedQty?: true
    availableQty?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    location?: true
    costPrice?: true
    lastCountedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    warehouseId?: true
    quantity?: true
    reservedQty?: true
    availableQty?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    location?: true
    costPrice?: true
    lastCountedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    warehouseId?: true
    quantity?: true
    reservedQty?: true
    availableQty?: true
    batchNumber?: true
    lotNumber?: true
    serialNumber?: true
    expiryDate?: true
    location?: true
    costPrice?: true
    lastCountedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    tenantId: string
    productId: string
    warehouseId: string
    quantity: number
    reservedQty: number
    availableQty: number
    batchNumber: string | null
    lotNumber: string | null
    serialNumber: string | null
    expiryDate: Date | null
    location: string | null
    costPrice: Decimal | null
    lastCountedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    reservedQty?: boolean
    availableQty?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    location?: boolean
    costPrice?: boolean
    lastCountedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    reservedQty?: boolean
    availableQty?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    location?: boolean
    costPrice?: boolean
    lastCountedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    reservedQty?: boolean
    availableQty?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    location?: boolean
    costPrice?: boolean
    lastCountedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    warehouseId?: boolean
    quantity?: boolean
    reservedQty?: boolean
    availableQty?: boolean
    batchNumber?: boolean
    lotNumber?: boolean
    serialNumber?: boolean
    expiryDate?: boolean
    location?: boolean
    costPrice?: boolean
    lastCountedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "productId" | "warehouseId" | "quantity" | "reservedQty" | "availableQty" | "batchNumber" | "lotNumber" | "serialNumber" | "expiryDate" | "location" | "costPrice" | "lastCountedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      productId: string
      warehouseId: string
      quantity: number
      reservedQty: number
      availableQty: number
      batchNumber: string | null
      lotNumber: string | null
      serialNumber: string | null
      expiryDate: Date | null
      location: string | null
      costPrice: Prisma.Decimal | null
      lastCountedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly tenantId: FieldRef<"InventoryItem", 'String'>
    readonly productId: FieldRef<"InventoryItem", 'String'>
    readonly warehouseId: FieldRef<"InventoryItem", 'String'>
    readonly quantity: FieldRef<"InventoryItem", 'Int'>
    readonly reservedQty: FieldRef<"InventoryItem", 'Int'>
    readonly availableQty: FieldRef<"InventoryItem", 'Int'>
    readonly batchNumber: FieldRef<"InventoryItem", 'String'>
    readonly lotNumber: FieldRef<"InventoryItem", 'String'>
    readonly serialNumber: FieldRef<"InventoryItem", 'String'>
    readonly expiryDate: FieldRef<"InventoryItem", 'DateTime'>
    readonly location: FieldRef<"InventoryItem", 'String'>
    readonly costPrice: FieldRef<"InventoryItem", 'Decimal'>
    readonly lastCountedAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    quantity: number | null
    unitCost: Decimal | null
    totalCost: Decimal | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    quantity: number | null
    unitCost: Decimal | null
    totalCost: Decimal | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    fromWarehouseId: string | null
    toWarehouseId: string | null
    userId: string | null
    type: $Enums.MovementType | null
    quantity: number | null
    unitCost: Decimal | null
    totalCost: Decimal | null
    reference: string | null
    referenceType: string | null
    batchNumber: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    productId: string | null
    fromWarehouseId: string | null
    toWarehouseId: string | null
    userId: string | null
    type: $Enums.MovementType | null
    quantity: number | null
    unitCost: Decimal | null
    totalCost: Decimal | null
    reference: string | null
    referenceType: string | null
    batchNumber: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    tenantId: number
    productId: number
    fromWarehouseId: number
    toWarehouseId: number
    userId: number
    type: number
    quantity: number
    unitCost: number
    totalCost: number
    reference: number
    referenceType: number
    batchNumber: number
    notes: number
    createdAt: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    quantity?: true
    unitCost?: true
    totalCost?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    quantity?: true
    unitCost?: true
    totalCost?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    userId?: true
    type?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    reference?: true
    referenceType?: true
    batchNumber?: true
    notes?: true
    createdAt?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    userId?: true
    type?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    reference?: true
    referenceType?: true
    batchNumber?: true
    notes?: true
    createdAt?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    tenantId?: true
    productId?: true
    fromWarehouseId?: true
    toWarehouseId?: true
    userId?: true
    type?: true
    quantity?: true
    unitCost?: true
    totalCost?: true
    reference?: true
    referenceType?: true
    batchNumber?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: string
    tenantId: string
    productId: string
    fromWarehouseId: string | null
    toWarehouseId: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost: Decimal | null
    totalCost: Decimal | null
    reference: string | null
    referenceType: string | null
    batchNumber: string | null
    notes: string | null
    createdAt: Date
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    userId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    reference?: boolean
    referenceType?: boolean
    batchNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | InventoryMovement$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | InventoryMovement$toWarehouseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    userId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    reference?: boolean
    referenceType?: boolean
    batchNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | InventoryMovement$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | InventoryMovement$toWarehouseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    userId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    reference?: boolean
    referenceType?: boolean
    batchNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | InventoryMovement$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | InventoryMovement$toWarehouseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>

  export type InventoryMovementSelectScalar = {
    id?: boolean
    tenantId?: boolean
    productId?: boolean
    fromWarehouseId?: boolean
    toWarehouseId?: boolean
    userId?: boolean
    type?: boolean
    quantity?: boolean
    unitCost?: boolean
    totalCost?: boolean
    reference?: boolean
    referenceType?: boolean
    batchNumber?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type InventoryMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "productId" | "fromWarehouseId" | "toWarehouseId" | "userId" | "type" | "quantity" | "unitCost" | "totalCost" | "reference" | "referenceType" | "batchNumber" | "notes" | "createdAt", ExtArgs["result"]["inventoryMovement"]>
  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | InventoryMovement$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | InventoryMovement$toWarehouseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | InventoryMovement$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | InventoryMovement$toWarehouseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventoryMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    fromWarehouse?: boolean | InventoryMovement$fromWarehouseArgs<ExtArgs>
    toWarehouse?: boolean | InventoryMovement$toWarehouseArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      fromWarehouse: Prisma.$WarehousePayload<ExtArgs> | null
      toWarehouse: Prisma.$WarehousePayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      productId: string
      fromWarehouseId: string | null
      toWarehouseId: string | null
      userId: string
      type: $Enums.MovementType
      quantity: number
      unitCost: Prisma.Decimal | null
      totalCost: Prisma.Decimal | null
      reference: string | null
      referenceType: string | null
      batchNumber: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryMovements and returns the data saved in the database.
     * @param {InventoryMovementCreateManyAndReturnArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements and returns the data updated in the database.
     * @param {InventoryMovementUpdateManyAndReturnArgs} args - Arguments to update many InventoryMovements.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryMovements and only return the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromWarehouse<T extends InventoryMovement$fromWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, InventoryMovement$fromWarehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    toWarehouse<T extends InventoryMovement$toWarehouseArgs<ExtArgs> = {}>(args?: Subset<T, InventoryMovement$toWarehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'String'>
    readonly tenantId: FieldRef<"InventoryMovement", 'String'>
    readonly productId: FieldRef<"InventoryMovement", 'String'>
    readonly fromWarehouseId: FieldRef<"InventoryMovement", 'String'>
    readonly toWarehouseId: FieldRef<"InventoryMovement", 'String'>
    readonly userId: FieldRef<"InventoryMovement", 'String'>
    readonly type: FieldRef<"InventoryMovement", 'MovementType'>
    readonly quantity: FieldRef<"InventoryMovement", 'Int'>
    readonly unitCost: FieldRef<"InventoryMovement", 'Decimal'>
    readonly totalCost: FieldRef<"InventoryMovement", 'Decimal'>
    readonly reference: FieldRef<"InventoryMovement", 'String'>
    readonly referenceType: FieldRef<"InventoryMovement", 'String'>
    readonly batchNumber: FieldRef<"InventoryMovement", 'String'>
    readonly notes: FieldRef<"InventoryMovement", 'String'>
    readonly createdAt: FieldRef<"InventoryMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement createManyAndReturn
   */
  export type InventoryMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
  }

  /**
   * InventoryMovement updateManyAndReturn
   */
  export type InventoryMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to delete.
     */
    limit?: number
  }

  /**
   * InventoryMovement.fromWarehouse
   */
  export type InventoryMovement$fromWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * InventoryMovement.toWarehouse
   */
  export type InventoryMovement$toWarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    paymentTerms: number | null
    creditLimit: Decimal | null
    currentBalance: Decimal | null
  }

  export type CustomerSumAggregateOutputType = {
    paymentTerms: number | null
    creditLimit: Decimal | null
    currentBalance: Decimal | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    name: string | null
    type: $Enums.CustomerType | null
    email: string | null
    phone: string | null
    mobile: string | null
    fax: string | null
    website: string | null
    taxId: string | null
    paymentTerms: number | null
    creditLimit: Decimal | null
    currentBalance: Decimal | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    name: string | null
    type: $Enums.CustomerType | null
    email: string | null
    phone: string | null
    mobile: string | null
    fax: string | null
    website: string | null
    taxId: string | null
    paymentTerms: number | null
    creditLimit: Decimal | null
    currentBalance: Decimal | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    tenantId: number
    code: number
    name: number
    type: number
    email: number
    phone: number
    mobile: number
    fax: number
    website: number
    taxId: number
    billingAddress: number
    shippingAddress: number
    paymentTerms: number
    creditLimit: number
    currentBalance: number
    notes: number
    tags: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    paymentTerms?: true
    creditLimit?: true
    currentBalance?: true
  }

  export type CustomerSumAggregateInputType = {
    paymentTerms?: true
    creditLimit?: true
    currentBalance?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    mobile?: true
    fax?: true
    website?: true
    taxId?: true
    paymentTerms?: true
    creditLimit?: true
    currentBalance?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    mobile?: true
    fax?: true
    website?: true
    taxId?: true
    paymentTerms?: true
    creditLimit?: true
    currentBalance?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    type?: true
    email?: true
    phone?: true
    mobile?: true
    fax?: true
    website?: true
    taxId?: true
    billingAddress?: true
    shippingAddress?: true
    paymentTerms?: true
    creditLimit?: true
    currentBalance?: true
    notes?: true
    tags?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    tenantId: string
    code: string
    name: string
    type: $Enums.CustomerType
    email: string | null
    phone: string | null
    mobile: string | null
    fax: string | null
    website: string | null
    taxId: string | null
    billingAddress: JsonValue | null
    shippingAddress: JsonValue | null
    paymentTerms: number
    creditLimit: Decimal
    currentBalance: Decimal
    notes: string | null
    tags: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    fax?: boolean
    website?: boolean
    taxId?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    paymentTerms?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    notes?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    fax?: boolean
    website?: boolean
    taxId?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    paymentTerms?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    notes?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    fax?: boolean
    website?: boolean
    taxId?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    paymentTerms?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    notes?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    fax?: boolean
    website?: boolean
    taxId?: boolean
    billingAddress?: boolean
    shippingAddress?: boolean
    paymentTerms?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    notes?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "code" | "name" | "type" | "email" | "phone" | "mobile" | "fax" | "website" | "taxId" | "billingAddress" | "shippingAddress" | "paymentTerms" | "creditLimit" | "currentBalance" | "notes" | "tags" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    invoices?: boolean | Customer$invoicesArgs<ExtArgs>
    payments?: boolean | Customer$paymentsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      code: string
      name: string
      type: $Enums.CustomerType
      email: string | null
      phone: string | null
      mobile: string | null
      fax: string | null
      website: string | null
      taxId: string | null
      billingAddress: Prisma.JsonValue | null
      shippingAddress: Prisma.JsonValue | null
      paymentTerms: number
      creditLimit: Prisma.Decimal
      currentBalance: Prisma.Decimal
      notes: string | null
      tags: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Customer$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Customer$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly tenantId: FieldRef<"Customer", 'String'>
    readonly code: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly type: FieldRef<"Customer", 'CustomerType'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly mobile: FieldRef<"Customer", 'String'>
    readonly fax: FieldRef<"Customer", 'String'>
    readonly website: FieldRef<"Customer", 'String'>
    readonly taxId: FieldRef<"Customer", 'String'>
    readonly billingAddress: FieldRef<"Customer", 'Json'>
    readonly shippingAddress: FieldRef<"Customer", 'Json'>
    readonly paymentTerms: FieldRef<"Customer", 'Int'>
    readonly creditLimit: FieldRef<"Customer", 'Decimal'>
    readonly currentBalance: FieldRef<"Customer", 'Decimal'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly tags: FieldRef<"Customer", 'Json'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly deletedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.invoices
   */
  export type Customer$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Customer.payments
   */
  export type Customer$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    paymentTerms: number | null
    leadTime: number | null
    minimumOrder: Decimal | null
    rating: number | null
  }

  export type SupplierSumAggregateOutputType = {
    paymentTerms: number | null
    leadTime: number | null
    minimumOrder: Decimal | null
    rating: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    fax: string | null
    website: string | null
    taxId: string | null
    paymentTerms: number | null
    currency: string | null
    leadTime: number | null
    minimumOrder: Decimal | null
    rating: number | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    name: string | null
    contactPerson: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    fax: string | null
    website: string | null
    taxId: string | null
    paymentTerms: number | null
    currency: string | null
    leadTime: number | null
    minimumOrder: Decimal | null
    rating: number | null
    notes: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    tenantId: number
    code: number
    name: number
    contactPerson: number
    email: number
    phone: number
    mobile: number
    fax: number
    website: number
    taxId: number
    address: number
    bankDetails: number
    paymentTerms: number
    currency: number
    leadTime: number
    minimumOrder: number
    rating: number
    notes: number
    tags: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    paymentTerms?: true
    leadTime?: true
    minimumOrder?: true
    rating?: true
  }

  export type SupplierSumAggregateInputType = {
    paymentTerms?: true
    leadTime?: true
    minimumOrder?: true
    rating?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    mobile?: true
    fax?: true
    website?: true
    taxId?: true
    paymentTerms?: true
    currency?: true
    leadTime?: true
    minimumOrder?: true
    rating?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    mobile?: true
    fax?: true
    website?: true
    taxId?: true
    paymentTerms?: true
    currency?: true
    leadTime?: true
    minimumOrder?: true
    rating?: true
    notes?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    name?: true
    contactPerson?: true
    email?: true
    phone?: true
    mobile?: true
    fax?: true
    website?: true
    taxId?: true
    address?: true
    bankDetails?: true
    paymentTerms?: true
    currency?: true
    leadTime?: true
    minimumOrder?: true
    rating?: true
    notes?: true
    tags?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    tenantId: string
    code: string
    name: string
    contactPerson: string | null
    email: string | null
    phone: string | null
    mobile: string | null
    fax: string | null
    website: string | null
    taxId: string | null
    address: JsonValue | null
    bankDetails: JsonValue | null
    paymentTerms: number
    currency: string
    leadTime: number
    minimumOrder: Decimal
    rating: number | null
    notes: string | null
    tags: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    fax?: boolean
    website?: boolean
    taxId?: boolean
    address?: boolean
    bankDetails?: boolean
    paymentTerms?: boolean
    currency?: boolean
    leadTime?: boolean
    minimumOrder?: boolean
    rating?: boolean
    notes?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Supplier$ordersArgs<ExtArgs>
    supplierProducts?: boolean | Supplier$supplierProductsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    fax?: boolean
    website?: boolean
    taxId?: boolean
    address?: boolean
    bankDetails?: boolean
    paymentTerms?: boolean
    currency?: boolean
    leadTime?: boolean
    minimumOrder?: boolean
    rating?: boolean
    notes?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    fax?: boolean
    website?: boolean
    taxId?: boolean
    address?: boolean
    bankDetails?: boolean
    paymentTerms?: boolean
    currency?: boolean
    leadTime?: boolean
    minimumOrder?: boolean
    rating?: boolean
    notes?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    tenantId?: boolean
    code?: boolean
    name?: boolean
    contactPerson?: boolean
    email?: boolean
    phone?: boolean
    mobile?: boolean
    fax?: boolean
    website?: boolean
    taxId?: boolean
    address?: boolean
    bankDetails?: boolean
    paymentTerms?: boolean
    currency?: boolean
    leadTime?: boolean
    minimumOrder?: boolean
    rating?: boolean
    notes?: boolean
    tags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "code" | "name" | "contactPerson" | "email" | "phone" | "mobile" | "fax" | "website" | "taxId" | "address" | "bankDetails" | "paymentTerms" | "currency" | "leadTime" | "minimumOrder" | "rating" | "notes" | "tags" | "isActive" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["supplier"]>
  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    orders?: boolean | Supplier$ordersArgs<ExtArgs>
    supplierProducts?: boolean | Supplier$supplierProductsArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      supplierProducts: Prisma.$SupplierProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      code: string
      name: string
      contactPerson: string | null
      email: string | null
      phone: string | null
      mobile: string | null
      fax: string | null
      website: string | null
      taxId: string | null
      address: Prisma.JsonValue | null
      bankDetails: Prisma.JsonValue | null
      paymentTerms: number
      currency: string
      leadTime: number
      minimumOrder: Prisma.Decimal
      rating: number | null
      notes: string | null
      tags: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers and returns the data updated in the database.
     * @param {SupplierUpdateManyAndReturnArgs} args - Arguments to update many Suppliers.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends Supplier$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supplierProducts<T extends Supplier$supplierProductsArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$supplierProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly tenantId: FieldRef<"Supplier", 'String'>
    readonly code: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contactPerson: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly mobile: FieldRef<"Supplier", 'String'>
    readonly fax: FieldRef<"Supplier", 'String'>
    readonly website: FieldRef<"Supplier", 'String'>
    readonly taxId: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'Json'>
    readonly bankDetails: FieldRef<"Supplier", 'Json'>
    readonly paymentTerms: FieldRef<"Supplier", 'Int'>
    readonly currency: FieldRef<"Supplier", 'String'>
    readonly leadTime: FieldRef<"Supplier", 'Int'>
    readonly minimumOrder: FieldRef<"Supplier", 'Decimal'>
    readonly rating: FieldRef<"Supplier", 'Int'>
    readonly notes: FieldRef<"Supplier", 'String'>
    readonly tags: FieldRef<"Supplier", 'Json'>
    readonly isActive: FieldRef<"Supplier", 'Boolean'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
    readonly deletedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
  }

  /**
   * Supplier updateManyAndReturn
   */
  export type SupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
    /**
     * Limit how many Suppliers to delete.
     */
    limit?: number
  }

  /**
   * Supplier.orders
   */
  export type Supplier$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Supplier.supplierProducts
   */
  export type Supplier$supplierProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    cursor?: SupplierProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model SupplierProduct
   */

  export type AggregateSupplierProduct = {
    _count: SupplierProductCountAggregateOutputType | null
    _avg: SupplierProductAvgAggregateOutputType | null
    _sum: SupplierProductSumAggregateOutputType | null
    _min: SupplierProductMinAggregateOutputType | null
    _max: SupplierProductMaxAggregateOutputType | null
  }

  export type SupplierProductAvgAggregateOutputType = {
    unitPrice: Decimal | null
    minOrderQty: number | null
    leadTime: number | null
  }

  export type SupplierProductSumAggregateOutputType = {
    unitPrice: Decimal | null
    minOrderQty: number | null
    leadTime: number | null
  }

  export type SupplierProductMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    supplierId: string | null
    productId: string | null
    supplierSku: string | null
    unitPrice: Decimal | null
    minOrderQty: number | null
    leadTime: number | null
    isPreferred: boolean | null
    lastOrderAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierProductMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    supplierId: string | null
    productId: string | null
    supplierSku: string | null
    unitPrice: Decimal | null
    minOrderQty: number | null
    leadTime: number | null
    isPreferred: boolean | null
    lastOrderAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierProductCountAggregateOutputType = {
    id: number
    tenantId: number
    supplierId: number
    productId: number
    supplierSku: number
    unitPrice: number
    minOrderQty: number
    leadTime: number
    isPreferred: number
    lastOrderAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierProductAvgAggregateInputType = {
    unitPrice?: true
    minOrderQty?: true
    leadTime?: true
  }

  export type SupplierProductSumAggregateInputType = {
    unitPrice?: true
    minOrderQty?: true
    leadTime?: true
  }

  export type SupplierProductMinAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    productId?: true
    supplierSku?: true
    unitPrice?: true
    minOrderQty?: true
    leadTime?: true
    isPreferred?: true
    lastOrderAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierProductMaxAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    productId?: true
    supplierSku?: true
    unitPrice?: true
    minOrderQty?: true
    leadTime?: true
    isPreferred?: true
    lastOrderAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierProductCountAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    productId?: true
    supplierSku?: true
    unitPrice?: true
    minOrderQty?: true
    leadTime?: true
    isPreferred?: true
    lastOrderAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierProduct to aggregate.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierProducts
    **/
    _count?: true | SupplierProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierProductMaxAggregateInputType
  }

  export type GetSupplierProductAggregateType<T extends SupplierProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierProduct[P]>
      : GetScalarType<T[P], AggregateSupplierProduct[P]>
  }




  export type SupplierProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierProductWhereInput
    orderBy?: SupplierProductOrderByWithAggregationInput | SupplierProductOrderByWithAggregationInput[]
    by: SupplierProductScalarFieldEnum[] | SupplierProductScalarFieldEnum
    having?: SupplierProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierProductCountAggregateInputType | true
    _avg?: SupplierProductAvgAggregateInputType
    _sum?: SupplierProductSumAggregateInputType
    _min?: SupplierProductMinAggregateInputType
    _max?: SupplierProductMaxAggregateInputType
  }

  export type SupplierProductGroupByOutputType = {
    id: string
    tenantId: string
    supplierId: string
    productId: string
    supplierSku: string | null
    unitPrice: Decimal
    minOrderQty: number
    leadTime: number | null
    isPreferred: boolean
    lastOrderAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SupplierProductCountAggregateOutputType | null
    _avg: SupplierProductAvgAggregateOutputType | null
    _sum: SupplierProductSumAggregateOutputType | null
    _min: SupplierProductMinAggregateOutputType | null
    _max: SupplierProductMaxAggregateOutputType | null
  }

  type GetSupplierProductGroupByPayload<T extends SupplierProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierProductGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierProductGroupByOutputType[P]>
        }
      >
    >


  export type SupplierProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    productId?: boolean
    supplierSku?: boolean
    unitPrice?: boolean
    minOrderQty?: boolean
    leadTime?: boolean
    isPreferred?: boolean
    lastOrderAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    productId?: boolean
    supplierSku?: boolean
    unitPrice?: boolean
    minOrderQty?: boolean
    leadTime?: boolean
    isPreferred?: boolean
    lastOrderAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    productId?: boolean
    supplierSku?: boolean
    unitPrice?: boolean
    minOrderQty?: boolean
    leadTime?: boolean
    isPreferred?: boolean
    lastOrderAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierProduct"]>

  export type SupplierProductSelectScalar = {
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    productId?: boolean
    supplierSku?: boolean
    unitPrice?: boolean
    minOrderQty?: boolean
    leadTime?: boolean
    isPreferred?: boolean
    lastOrderAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "supplierId" | "productId" | "supplierSku" | "unitPrice" | "minOrderQty" | "leadTime" | "isPreferred" | "lastOrderAt" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierProduct"]>
  export type SupplierProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SupplierProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SupplierProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SupplierProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierProduct"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      supplierId: string
      productId: string
      supplierSku: string | null
      unitPrice: Prisma.Decimal
      minOrderQty: number
      leadTime: number | null
      isPreferred: boolean
      lastOrderAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierProduct"]>
    composites: {}
  }

  type SupplierProductGetPayload<S extends boolean | null | undefined | SupplierProductDefaultArgs> = $Result.GetResult<Prisma.$SupplierProductPayload, S>

  type SupplierProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierProductCountAggregateInputType | true
    }

  export interface SupplierProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierProduct'], meta: { name: 'SupplierProduct' } }
    /**
     * Find zero or one SupplierProduct that matches the filter.
     * @param {SupplierProductFindUniqueArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierProductFindUniqueArgs>(args: SelectSubset<T, SupplierProductFindUniqueArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierProductFindUniqueOrThrowArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierProductFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindFirstArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierProductFindFirstArgs>(args?: SelectSubset<T, SupplierProductFindFirstArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindFirstOrThrowArgs} args - Arguments to find a SupplierProduct
     * @example
     * // Get one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierProductFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierProducts
     * const supplierProducts = await prisma.supplierProduct.findMany()
     * 
     * // Get first 10 SupplierProducts
     * const supplierProducts = await prisma.supplierProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierProductWithIdOnly = await prisma.supplierProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierProductFindManyArgs>(args?: SelectSubset<T, SupplierProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierProduct.
     * @param {SupplierProductCreateArgs} args - Arguments to create a SupplierProduct.
     * @example
     * // Create one SupplierProduct
     * const SupplierProduct = await prisma.supplierProduct.create({
     *   data: {
     *     // ... data to create a SupplierProduct
     *   }
     * })
     * 
     */
    create<T extends SupplierProductCreateArgs>(args: SelectSubset<T, SupplierProductCreateArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierProducts.
     * @param {SupplierProductCreateManyArgs} args - Arguments to create many SupplierProducts.
     * @example
     * // Create many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierProductCreateManyArgs>(args?: SelectSubset<T, SupplierProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierProducts and returns the data saved in the database.
     * @param {SupplierProductCreateManyAndReturnArgs} args - Arguments to create many SupplierProducts.
     * @example
     * // Create many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierProducts and only return the `id`
     * const supplierProductWithIdOnly = await prisma.supplierProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierProductCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierProduct.
     * @param {SupplierProductDeleteArgs} args - Arguments to delete one SupplierProduct.
     * @example
     * // Delete one SupplierProduct
     * const SupplierProduct = await prisma.supplierProduct.delete({
     *   where: {
     *     // ... filter to delete one SupplierProduct
     *   }
     * })
     * 
     */
    delete<T extends SupplierProductDeleteArgs>(args: SelectSubset<T, SupplierProductDeleteArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierProduct.
     * @param {SupplierProductUpdateArgs} args - Arguments to update one SupplierProduct.
     * @example
     * // Update one SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierProductUpdateArgs>(args: SelectSubset<T, SupplierProductUpdateArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierProducts.
     * @param {SupplierProductDeleteManyArgs} args - Arguments to filter SupplierProducts to delete.
     * @example
     * // Delete a few SupplierProducts
     * const { count } = await prisma.supplierProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierProductDeleteManyArgs>(args?: SelectSubset<T, SupplierProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierProductUpdateManyArgs>(args: SelectSubset<T, SupplierProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierProducts and returns the data updated in the database.
     * @param {SupplierProductUpdateManyAndReturnArgs} args - Arguments to update many SupplierProducts.
     * @example
     * // Update many SupplierProducts
     * const supplierProduct = await prisma.supplierProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierProducts and only return the `id`
     * const supplierProductWithIdOnly = await prisma.supplierProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierProductUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierProduct.
     * @param {SupplierProductUpsertArgs} args - Arguments to update or create a SupplierProduct.
     * @example
     * // Update or create a SupplierProduct
     * const supplierProduct = await prisma.supplierProduct.upsert({
     *   create: {
     *     // ... data to create a SupplierProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierProduct we want to update
     *   }
     * })
     */
    upsert<T extends SupplierProductUpsertArgs>(args: SelectSubset<T, SupplierProductUpsertArgs<ExtArgs>>): Prisma__SupplierProductClient<$Result.GetResult<Prisma.$SupplierProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductCountArgs} args - Arguments to filter SupplierProducts to count.
     * @example
     * // Count the number of SupplierProducts
     * const count = await prisma.supplierProduct.count({
     *   where: {
     *     // ... the filter for the SupplierProducts we want to count
     *   }
     * })
    **/
    count<T extends SupplierProductCountArgs>(
      args?: Subset<T, SupplierProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierProductAggregateArgs>(args: Subset<T, SupplierProductAggregateArgs>): Prisma.PrismaPromise<GetSupplierProductAggregateType<T>>

    /**
     * Group by SupplierProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierProductGroupByArgs['orderBy'] }
        : { orderBy?: SupplierProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierProduct model
   */
  readonly fields: SupplierProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierProduct model
   */
  interface SupplierProductFieldRefs {
    readonly id: FieldRef<"SupplierProduct", 'String'>
    readonly tenantId: FieldRef<"SupplierProduct", 'String'>
    readonly supplierId: FieldRef<"SupplierProduct", 'String'>
    readonly productId: FieldRef<"SupplierProduct", 'String'>
    readonly supplierSku: FieldRef<"SupplierProduct", 'String'>
    readonly unitPrice: FieldRef<"SupplierProduct", 'Decimal'>
    readonly minOrderQty: FieldRef<"SupplierProduct", 'Int'>
    readonly leadTime: FieldRef<"SupplierProduct", 'Int'>
    readonly isPreferred: FieldRef<"SupplierProduct", 'Boolean'>
    readonly lastOrderAt: FieldRef<"SupplierProduct", 'DateTime'>
    readonly createdAt: FieldRef<"SupplierProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierProduct findUnique
   */
  export type SupplierProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct findUniqueOrThrow
   */
  export type SupplierProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct findFirst
   */
  export type SupplierProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierProducts.
     */
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct findFirstOrThrow
   */
  export type SupplierProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProduct to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierProducts.
     */
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct findMany
   */
  export type SupplierProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter, which SupplierProducts to fetch.
     */
    where?: SupplierProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierProducts to fetch.
     */
    orderBy?: SupplierProductOrderByWithRelationInput | SupplierProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierProducts.
     */
    cursor?: SupplierProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierProducts.
     */
    skip?: number
    distinct?: SupplierProductScalarFieldEnum | SupplierProductScalarFieldEnum[]
  }

  /**
   * SupplierProduct create
   */
  export type SupplierProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierProduct.
     */
    data: XOR<SupplierProductCreateInput, SupplierProductUncheckedCreateInput>
  }

  /**
   * SupplierProduct createMany
   */
  export type SupplierProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierProducts.
     */
    data: SupplierProductCreateManyInput | SupplierProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierProduct createManyAndReturn
   */
  export type SupplierProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierProducts.
     */
    data: SupplierProductCreateManyInput | SupplierProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierProduct update
   */
  export type SupplierProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierProduct.
     */
    data: XOR<SupplierProductUpdateInput, SupplierProductUncheckedUpdateInput>
    /**
     * Choose, which SupplierProduct to update.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct updateMany
   */
  export type SupplierProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierProducts.
     */
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyInput>
    /**
     * Filter which SupplierProducts to update
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to update.
     */
    limit?: number
  }

  /**
   * SupplierProduct updateManyAndReturn
   */
  export type SupplierProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * The data used to update SupplierProducts.
     */
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyInput>
    /**
     * Filter which SupplierProducts to update
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierProduct upsert
   */
  export type SupplierProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierProduct to update in case it exists.
     */
    where: SupplierProductWhereUniqueInput
    /**
     * In case the SupplierProduct found by the `where` argument doesn't exist, create a new SupplierProduct with this data.
     */
    create: XOR<SupplierProductCreateInput, SupplierProductUncheckedCreateInput>
    /**
     * In case the SupplierProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierProductUpdateInput, SupplierProductUncheckedUpdateInput>
  }

  /**
   * SupplierProduct delete
   */
  export type SupplierProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
    /**
     * Filter which SupplierProduct to delete.
     */
    where: SupplierProductWhereUniqueInput
  }

  /**
   * SupplierProduct deleteMany
   */
  export type SupplierProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierProducts to delete
     */
    where?: SupplierProductWhereInput
    /**
     * Limit how many SupplierProducts to delete.
     */
    limit?: number
  }

  /**
   * SupplierProduct without action
   */
  export type SupplierProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierProduct
     */
    select?: SupplierProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierProduct
     */
    omit?: SupplierProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierProductInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    shippingCost: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    exchangeRate: Decimal | null
    paymentTerms: number | null
  }

  export type OrderSumAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    shippingCost: Decimal | null
    discount: Decimal | null
    total: Decimal | null
    exchangeRate: Decimal | null
    paymentTerms: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderNumber: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    customerId: string | null
    supplierId: string | null
    warehouseId: string | null
    createdById: string | null
    approvedById: string | null
    orderDate: Date | null
    expectedDate: Date | null
    shippedDate: Date | null
    deliveredDate: Date | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    shippingCost: Decimal | null
    discount: Decimal | null
    discountType: string | null
    total: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    paymentTerms: number | null
    paymentMethod: string | null
    notes: string | null
    internalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderNumber: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    customerId: string | null
    supplierId: string | null
    warehouseId: string | null
    createdById: string | null
    approvedById: string | null
    orderDate: Date | null
    expectedDate: Date | null
    shippedDate: Date | null
    deliveredDate: Date | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    shippingCost: Decimal | null
    discount: Decimal | null
    discountType: string | null
    total: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    paymentTerms: number | null
    paymentMethod: string | null
    notes: string | null
    internalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    tenantId: number
    orderNumber: number
    type: number
    status: number
    customerId: number
    supplierId: number
    warehouseId: number
    createdById: number
    approvedById: number
    orderDate: number
    expectedDate: number
    shippedDate: number
    deliveredDate: number
    shippingAddress: number
    billingAddress: number
    subtotal: number
    taxAmount: number
    shippingCost: number
    discount: number
    discountType: number
    total: number
    currency: number
    exchangeRate: number
    paymentTerms: number
    paymentMethod: number
    notes: number
    internalNotes: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    shippingCost?: true
    discount?: true
    total?: true
    exchangeRate?: true
    paymentTerms?: true
  }

  export type OrderSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    shippingCost?: true
    discount?: true
    total?: true
    exchangeRate?: true
    paymentTerms?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    tenantId?: true
    orderNumber?: true
    type?: true
    status?: true
    customerId?: true
    supplierId?: true
    warehouseId?: true
    createdById?: true
    approvedById?: true
    orderDate?: true
    expectedDate?: true
    shippedDate?: true
    deliveredDate?: true
    subtotal?: true
    taxAmount?: true
    shippingCost?: true
    discount?: true
    discountType?: true
    total?: true
    currency?: true
    exchangeRate?: true
    paymentTerms?: true
    paymentMethod?: true
    notes?: true
    internalNotes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    tenantId?: true
    orderNumber?: true
    type?: true
    status?: true
    customerId?: true
    supplierId?: true
    warehouseId?: true
    createdById?: true
    approvedById?: true
    orderDate?: true
    expectedDate?: true
    shippedDate?: true
    deliveredDate?: true
    subtotal?: true
    taxAmount?: true
    shippingCost?: true
    discount?: true
    discountType?: true
    total?: true
    currency?: true
    exchangeRate?: true
    paymentTerms?: true
    paymentMethod?: true
    notes?: true
    internalNotes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    tenantId?: true
    orderNumber?: true
    type?: true
    status?: true
    customerId?: true
    supplierId?: true
    warehouseId?: true
    createdById?: true
    approvedById?: true
    orderDate?: true
    expectedDate?: true
    shippedDate?: true
    deliveredDate?: true
    shippingAddress?: true
    billingAddress?: true
    subtotal?: true
    taxAmount?: true
    shippingCost?: true
    discount?: true
    discountType?: true
    total?: true
    currency?: true
    exchangeRate?: true
    paymentTerms?: true
    paymentMethod?: true
    notes?: true
    internalNotes?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status: $Enums.OrderStatus
    customerId: string | null
    supplierId: string | null
    warehouseId: string | null
    createdById: string
    approvedById: string | null
    orderDate: Date
    expectedDate: Date | null
    shippedDate: Date | null
    deliveredDate: Date | null
    shippingAddress: JsonValue | null
    billingAddress: JsonValue | null
    subtotal: Decimal
    taxAmount: Decimal
    shippingCost: Decimal
    discount: Decimal
    discountType: string | null
    total: Decimal
    currency: string
    exchangeRate: Decimal
    paymentTerms: number | null
    paymentMethod: string | null
    notes: string | null
    internalNotes: string | null
    tags: JsonValue
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    type?: boolean
    status?: boolean
    customerId?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    createdById?: boolean
    approvedById?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    shippedDate?: boolean
    deliveredDate?: boolean
    shippingAddress?: boolean
    billingAddress?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    shippingCost?: boolean
    discount?: boolean
    discountType?: boolean
    total?: boolean
    currency?: boolean
    exchangeRate?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    notes?: boolean
    internalNotes?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    supplier?: boolean | Order$supplierArgs<ExtArgs>
    warehouse?: boolean | Order$warehouseArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    invoices?: boolean | Order$invoicesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    type?: boolean
    status?: boolean
    customerId?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    createdById?: boolean
    approvedById?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    shippedDate?: boolean
    deliveredDate?: boolean
    shippingAddress?: boolean
    billingAddress?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    shippingCost?: boolean
    discount?: boolean
    discountType?: boolean
    total?: boolean
    currency?: boolean
    exchangeRate?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    notes?: boolean
    internalNotes?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    supplier?: boolean | Order$supplierArgs<ExtArgs>
    warehouse?: boolean | Order$warehouseArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    type?: boolean
    status?: boolean
    customerId?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    createdById?: boolean
    approvedById?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    shippedDate?: boolean
    deliveredDate?: boolean
    shippingAddress?: boolean
    billingAddress?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    shippingCost?: boolean
    discount?: boolean
    discountType?: boolean
    total?: boolean
    currency?: boolean
    exchangeRate?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    notes?: boolean
    internalNotes?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    supplier?: boolean | Order$supplierArgs<ExtArgs>
    warehouse?: boolean | Order$warehouseArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    tenantId?: boolean
    orderNumber?: boolean
    type?: boolean
    status?: boolean
    customerId?: boolean
    supplierId?: boolean
    warehouseId?: boolean
    createdById?: boolean
    approvedById?: boolean
    orderDate?: boolean
    expectedDate?: boolean
    shippedDate?: boolean
    deliveredDate?: boolean
    shippingAddress?: boolean
    billingAddress?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    shippingCost?: boolean
    discount?: boolean
    discountType?: boolean
    total?: boolean
    currency?: boolean
    exchangeRate?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    notes?: boolean
    internalNotes?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "orderNumber" | "type" | "status" | "customerId" | "supplierId" | "warehouseId" | "createdById" | "approvedById" | "orderDate" | "expectedDate" | "shippedDate" | "deliveredDate" | "shippingAddress" | "billingAddress" | "subtotal" | "taxAmount" | "shippingCost" | "discount" | "discountType" | "total" | "currency" | "exchangeRate" | "paymentTerms" | "paymentMethod" | "notes" | "internalNotes" | "tags" | "metadata" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    supplier?: boolean | Order$supplierArgs<ExtArgs>
    warehouse?: boolean | Order$warehouseArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    invoices?: boolean | Order$invoicesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    supplier?: boolean | Order$supplierArgs<ExtArgs>
    warehouse?: boolean | Order$warehouseArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    supplier?: boolean | Order$supplierArgs<ExtArgs>
    warehouse?: boolean | Order$warehouseArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      supplier: Prisma.$SupplierPayload<ExtArgs> | null
      warehouse: Prisma.$WarehousePayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      orderNumber: string
      type: $Enums.OrderType
      status: $Enums.OrderStatus
      customerId: string | null
      supplierId: string | null
      warehouseId: string | null
      createdById: string
      approvedById: string | null
      orderDate: Date
      expectedDate: Date | null
      shippedDate: Date | null
      deliveredDate: Date | null
      shippingAddress: Prisma.JsonValue | null
      billingAddress: Prisma.JsonValue | null
      subtotal: Prisma.Decimal
      taxAmount: Prisma.Decimal
      shippingCost: Prisma.Decimal
      discount: Prisma.Decimal
      discountType: string | null
      total: Prisma.Decimal
      currency: string
      exchangeRate: Prisma.Decimal
      paymentTerms: number | null
      paymentMethod: string | null
      notes: string | null
      internalNotes: string | null
      tags: Prisma.JsonValue
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Order$customerArgs<ExtArgs> = {}>(args?: Subset<T, Order$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supplier<T extends Order$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Order$supplierArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends Order$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, Order$warehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Order$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Order$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Order$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Order$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly tenantId: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly type: FieldRef<"Order", 'OrderType'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly supplierId: FieldRef<"Order", 'String'>
    readonly warehouseId: FieldRef<"Order", 'String'>
    readonly createdById: FieldRef<"Order", 'String'>
    readonly approvedById: FieldRef<"Order", 'String'>
    readonly orderDate: FieldRef<"Order", 'DateTime'>
    readonly expectedDate: FieldRef<"Order", 'DateTime'>
    readonly shippedDate: FieldRef<"Order", 'DateTime'>
    readonly deliveredDate: FieldRef<"Order", 'DateTime'>
    readonly shippingAddress: FieldRef<"Order", 'Json'>
    readonly billingAddress: FieldRef<"Order", 'Json'>
    readonly subtotal: FieldRef<"Order", 'Decimal'>
    readonly taxAmount: FieldRef<"Order", 'Decimal'>
    readonly shippingCost: FieldRef<"Order", 'Decimal'>
    readonly discount: FieldRef<"Order", 'Decimal'>
    readonly discountType: FieldRef<"Order", 'String'>
    readonly total: FieldRef<"Order", 'Decimal'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly exchangeRate: FieldRef<"Order", 'Decimal'>
    readonly paymentTerms: FieldRef<"Order", 'Int'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly internalNotes: FieldRef<"Order", 'String'>
    readonly tags: FieldRef<"Order", 'Json'>
    readonly metadata: FieldRef<"Order", 'Json'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly deletedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.customer
   */
  export type Order$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Order.supplier
   */
  export type Order$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Supplier
     */
    omit?: SupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
  }

  /**
   * Order.warehouse
   */
  export type Order$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * Order.approvedBy
   */
  export type Order$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.invoices
   */
  export type Order$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    shippedQty: number | null
    receivedQty: number | null
    unitPrice: Decimal | null
    unitCost: Decimal | null
    discount: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    sortOrder: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    shippedQty: number | null
    receivedQty: number | null
    unitPrice: Decimal | null
    unitCost: Decimal | null
    discount: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    sortOrder: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    sku: string | null
    name: string | null
    description: string | null
    quantity: number | null
    shippedQty: number | null
    receivedQty: number | null
    unitPrice: Decimal | null
    unitCost: Decimal | null
    discount: Decimal | null
    discountType: string | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    notes: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    sku: string | null
    name: string | null
    description: string | null
    quantity: number | null
    shippedQty: number | null
    receivedQty: number | null
    unitPrice: Decimal | null
    unitCost: Decimal | null
    discount: Decimal | null
    discountType: string | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    notes: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    sku: number
    name: number
    description: number
    quantity: number
    shippedQty: number
    receivedQty: number
    unitPrice: number
    unitCost: number
    discount: number
    discountType: number
    taxRate: number
    taxAmount: number
    total: number
    notes: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    shippedQty?: true
    receivedQty?: true
    unitPrice?: true
    unitCost?: true
    discount?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    sortOrder?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    shippedQty?: true
    receivedQty?: true
    unitPrice?: true
    unitCost?: true
    discount?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    sortOrder?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    shippedQty?: true
    receivedQty?: true
    unitPrice?: true
    unitCost?: true
    discount?: true
    discountType?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    notes?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    shippedQty?: true
    receivedQty?: true
    unitPrice?: true
    unitCost?: true
    discount?: true
    discountType?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    notes?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    shippedQty?: true
    receivedQty?: true
    unitPrice?: true
    unitCost?: true
    discount?: true
    discountType?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    notes?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    sku: string
    name: string
    description: string | null
    quantity: number
    shippedQty: number
    receivedQty: number
    unitPrice: Decimal
    unitCost: Decimal | null
    discount: Decimal
    discountType: string | null
    taxRate: Decimal
    taxAmount: Decimal
    total: Decimal
    notes: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    shippedQty?: boolean
    receivedQty?: boolean
    unitPrice?: boolean
    unitCost?: boolean
    discount?: boolean
    discountType?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    notes?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    shippedQty?: boolean
    receivedQty?: boolean
    unitPrice?: boolean
    unitCost?: boolean
    discount?: boolean
    discountType?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    notes?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    shippedQty?: boolean
    receivedQty?: boolean
    unitPrice?: boolean
    unitCost?: boolean
    discount?: boolean
    discountType?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    notes?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    shippedQty?: boolean
    receivedQty?: boolean
    unitPrice?: boolean
    unitCost?: boolean
    discount?: boolean
    discountType?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    notes?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "sku" | "name" | "description" | "quantity" | "shippedQty" | "receivedQty" | "unitPrice" | "unitCost" | "discount" | "discountType" | "taxRate" | "taxAmount" | "total" | "notes" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      sku: string
      name: string
      description: string | null
      quantity: number
      shippedQty: number
      receivedQty: number
      unitPrice: Prisma.Decimal
      unitCost: Prisma.Decimal | null
      discount: Prisma.Decimal
      discountType: string | null
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
      notes: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly sku: FieldRef<"OrderItem", 'String'>
    readonly name: FieldRef<"OrderItem", 'String'>
    readonly description: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly shippedQty: FieldRef<"OrderItem", 'Int'>
    readonly receivedQty: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Decimal'>
    readonly unitCost: FieldRef<"OrderItem", 'Decimal'>
    readonly discount: FieldRef<"OrderItem", 'Decimal'>
    readonly discountType: FieldRef<"OrderItem", 'String'>
    readonly taxRate: FieldRef<"OrderItem", 'Decimal'>
    readonly taxAmount: FieldRef<"OrderItem", 'Decimal'>
    readonly total: FieldRef<"OrderItem", 'Decimal'>
    readonly notes: FieldRef<"OrderItem", 'String'>
    readonly sortOrder: FieldRef<"OrderItem", 'Int'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discount: Decimal | null
    shippingCost: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    balanceDue: Decimal | null
    exchangeRate: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discount: Decimal | null
    shippingCost: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    balanceDue: Decimal | null
    exchangeRate: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderId: string | null
    customerId: string | null
    createdById: string | null
    invoiceNumber: string | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discount: Decimal | null
    shippingCost: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    balanceDue: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    notes: string | null
    terms: string | null
    footer: string | null
    sentAt: Date | null
    viewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    orderId: string | null
    customerId: string | null
    createdById: string | null
    invoiceNumber: string | null
    type: $Enums.InvoiceType | null
    status: $Enums.InvoiceStatus | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    subtotal: Decimal | null
    taxAmount: Decimal | null
    discount: Decimal | null
    shippingCost: Decimal | null
    total: Decimal | null
    paidAmount: Decimal | null
    balanceDue: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    notes: string | null
    terms: string | null
    footer: string | null
    sentAt: Date | null
    viewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    orderId: number
    customerId: number
    createdById: number
    invoiceNumber: number
    type: number
    status: number
    issueDate: number
    dueDate: number
    paidDate: number
    subtotal: number
    taxAmount: number
    discount: number
    shippingCost: number
    total: number
    paidAmount: number
    balanceDue: number
    currency: number
    exchangeRate: number
    notes: number
    terms: number
    footer: number
    metadata: number
    sentAt: number
    viewedAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discount?: true
    shippingCost?: true
    total?: true
    paidAmount?: true
    balanceDue?: true
    exchangeRate?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discount?: true
    shippingCost?: true
    total?: true
    paidAmount?: true
    balanceDue?: true
    exchangeRate?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    customerId?: true
    createdById?: true
    invoiceNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    taxAmount?: true
    discount?: true
    shippingCost?: true
    total?: true
    paidAmount?: true
    balanceDue?: true
    currency?: true
    exchangeRate?: true
    notes?: true
    terms?: true
    footer?: true
    sentAt?: true
    viewedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    customerId?: true
    createdById?: true
    invoiceNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    taxAmount?: true
    discount?: true
    shippingCost?: true
    total?: true
    paidAmount?: true
    balanceDue?: true
    currency?: true
    exchangeRate?: true
    notes?: true
    terms?: true
    footer?: true
    sentAt?: true
    viewedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    orderId?: true
    customerId?: true
    createdById?: true
    invoiceNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    taxAmount?: true
    discount?: true
    shippingCost?: true
    total?: true
    paidAmount?: true
    balanceDue?: true
    currency?: true
    exchangeRate?: true
    notes?: true
    terms?: true
    footer?: true
    metadata?: true
    sentAt?: true
    viewedAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    tenantId: string
    orderId: string | null
    customerId: string
    createdById: string
    invoiceNumber: string
    type: $Enums.InvoiceType
    status: $Enums.InvoiceStatus
    issueDate: Date
    dueDate: Date
    paidDate: Date | null
    subtotal: Decimal
    taxAmount: Decimal
    discount: Decimal
    shippingCost: Decimal
    total: Decimal
    paidAmount: Decimal
    balanceDue: Decimal
    currency: string
    exchangeRate: Decimal
    notes: string | null
    terms: string | null
    footer: string | null
    metadata: JsonValue
    sentAt: Date | null
    viewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    customerId?: boolean
    createdById?: boolean
    invoiceNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discount?: boolean
    shippingCost?: boolean
    total?: boolean
    paidAmount?: boolean
    balanceDue?: boolean
    currency?: boolean
    exchangeRate?: boolean
    notes?: boolean
    terms?: boolean
    footer?: boolean
    metadata?: boolean
    sentAt?: boolean
    viewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    eInvoices?: boolean | Invoice$eInvoicesArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    customerId?: boolean
    createdById?: boolean
    invoiceNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discount?: boolean
    shippingCost?: boolean
    total?: boolean
    paidAmount?: boolean
    balanceDue?: boolean
    currency?: boolean
    exchangeRate?: boolean
    notes?: boolean
    terms?: boolean
    footer?: boolean
    metadata?: boolean
    sentAt?: boolean
    viewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    customerId?: boolean
    createdById?: boolean
    invoiceNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discount?: boolean
    shippingCost?: boolean
    total?: boolean
    paidAmount?: boolean
    balanceDue?: boolean
    currency?: boolean
    exchangeRate?: boolean
    notes?: boolean
    terms?: boolean
    footer?: boolean
    metadata?: boolean
    sentAt?: boolean
    viewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    orderId?: boolean
    customerId?: boolean
    createdById?: boolean
    invoiceNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discount?: boolean
    shippingCost?: boolean
    total?: boolean
    paidAmount?: boolean
    balanceDue?: boolean
    currency?: boolean
    exchangeRate?: boolean
    notes?: boolean
    terms?: boolean
    footer?: boolean
    metadata?: boolean
    sentAt?: boolean
    viewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "orderId" | "customerId" | "createdById" | "invoiceNumber" | "type" | "status" | "issueDate" | "dueDate" | "paidDate" | "subtotal" | "taxAmount" | "discount" | "shippingCost" | "total" | "paidAmount" | "balanceDue" | "currency" | "exchangeRate" | "notes" | "terms" | "footer" | "metadata" | "sentAt" | "viewedAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    eInvoices?: boolean | Invoice$eInvoicesArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    order?: boolean | Invoice$orderArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      eInvoices: Prisma.$EInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      orderId: string | null
      customerId: string
      createdById: string
      invoiceNumber: string
      type: $Enums.InvoiceType
      status: $Enums.InvoiceStatus
      issueDate: Date
      dueDate: Date
      paidDate: Date | null
      subtotal: Prisma.Decimal
      taxAmount: Prisma.Decimal
      discount: Prisma.Decimal
      shippingCost: Prisma.Decimal
      total: Prisma.Decimal
      paidAmount: Prisma.Decimal
      balanceDue: Prisma.Decimal
      currency: string
      exchangeRate: Prisma.Decimal
      notes: string | null
      terms: string | null
      footer: string | null
      metadata: Prisma.JsonValue
      sentAt: Date | null
      viewedAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends Invoice$orderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eInvoices<T extends Invoice$eInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$eInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly orderId: FieldRef<"Invoice", 'String'>
    readonly customerId: FieldRef<"Invoice", 'String'>
    readonly createdById: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly type: FieldRef<"Invoice", 'InvoiceType'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidDate: FieldRef<"Invoice", 'DateTime'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly taxAmount: FieldRef<"Invoice", 'Decimal'>
    readonly discount: FieldRef<"Invoice", 'Decimal'>
    readonly shippingCost: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly paidAmount: FieldRef<"Invoice", 'Decimal'>
    readonly balanceDue: FieldRef<"Invoice", 'Decimal'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly exchangeRate: FieldRef<"Invoice", 'Decimal'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly terms: FieldRef<"Invoice", 'String'>
    readonly footer: FieldRef<"Invoice", 'String'>
    readonly metadata: FieldRef<"Invoice", 'Json'>
    readonly sentAt: FieldRef<"Invoice", 'DateTime'>
    readonly viewedAt: FieldRef<"Invoice", 'DateTime'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly deletedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.order
   */
  export type Invoice$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice.eInvoices
   */
  export type Invoice$eInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    where?: EInvoiceWhereInput
    orderBy?: EInvoiceOrderByWithRelationInput | EInvoiceOrderByWithRelationInput[]
    cursor?: EInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EInvoiceScalarFieldEnum | EInvoiceScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    sortOrder: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    sortOrder: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    productId: string | null
    sku: string | null
    name: string | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    productId: string | null
    sku: string | null
    name: string | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    discount: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    productId: number
    sku: number
    name: number
    description: number
    quantity: number
    unitPrice: number
    discount: number
    taxRate: number
    taxAmount: number
    total: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    sortOrder?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    sortOrder?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    productId?: true
    sku?: true
    name?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    productId: string | null
    sku: string | null
    name: string
    description: string | null
    quantity: number
    unitPrice: Decimal
    discount: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    total: Decimal
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    eInvoiceItems?: boolean | InvoiceItem$eInvoiceItemsArgs<ExtArgs>
    _count?: boolean | InvoiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "productId" | "sku" | "name" | "description" | "quantity" | "unitPrice" | "discount" | "taxRate" | "taxAmount" | "total" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
    eInvoiceItems?: boolean | InvoiceItem$eInvoiceItemsArgs<ExtArgs>
    _count?: boolean | InvoiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    product?: boolean | InvoiceItem$productArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      eInvoiceItems: Prisma.$EInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      productId: string | null
      sku: string | null
      name: string
      description: string | null
      quantity: number
      unitPrice: Prisma.Decimal
      discount: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends InvoiceItem$productArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    eInvoiceItems<T extends InvoiceItem$eInvoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$eInvoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly productId: FieldRef<"InvoiceItem", 'String'>
    readonly sku: FieldRef<"InvoiceItem", 'String'>
    readonly name: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Decimal'>
    readonly discount: FieldRef<"InvoiceItem", 'Decimal'>
    readonly taxRate: FieldRef<"InvoiceItem", 'Decimal'>
    readonly taxAmount: FieldRef<"InvoiceItem", 'Decimal'>
    readonly total: FieldRef<"InvoiceItem", 'Decimal'>
    readonly sortOrder: FieldRef<"InvoiceItem", 'Int'>
    readonly createdAt: FieldRef<"InvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem.product
   */
  export type InvoiceItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * InvoiceItem.eInvoiceItems
   */
  export type InvoiceItem$eInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    where?: EInvoiceItemWhereInput
    orderBy?: EInvoiceItemOrderByWithRelationInput | EInvoiceItemOrderByWithRelationInput[]
    cursor?: EInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EInvoiceItemScalarFieldEnum | EInvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
    exchangeRate: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
    exchangeRate: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    customerId: string | null
    receivedById: string | null
    paymentNumber: string | null
    type: $Enums.PaymentType | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    amount: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    paymentDate: Date | null
    reference: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    customerId: string | null
    receivedById: string | null
    paymentNumber: string | null
    type: $Enums.PaymentType | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PaymentStatus | null
    amount: Decimal | null
    currency: string | null
    exchangeRate: Decimal | null
    paymentDate: Date | null
    reference: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceId: number
    customerId: number
    receivedById: number
    paymentNumber: number
    type: number
    method: number
    status: number
    amount: number
    currency: number
    exchangeRate: number
    paymentDate: number
    reference: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    exchangeRate?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    exchangeRate?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    customerId?: true
    receivedById?: true
    paymentNumber?: true
    type?: true
    method?: true
    status?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    paymentDate?: true
    reference?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    customerId?: true
    receivedById?: true
    paymentNumber?: true
    type?: true
    method?: true
    status?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    paymentDate?: true
    reference?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    customerId?: true
    receivedById?: true
    paymentNumber?: true
    type?: true
    method?: true
    status?: true
    amount?: true
    currency?: true
    exchangeRate?: true
    paymentDate?: true
    reference?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    tenantId: string
    invoiceId: string | null
    customerId: string
    receivedById: string
    paymentNumber: string
    type: $Enums.PaymentType
    method: $Enums.PaymentMethod
    status: $Enums.PaymentStatus
    amount: Decimal
    currency: string
    exchangeRate: Decimal
    paymentDate: Date
    reference: string | null
    notes: string | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    customerId?: boolean
    receivedById?: boolean
    paymentNumber?: boolean
    type?: boolean
    method?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    paymentDate?: boolean
    reference?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    customerId?: boolean
    receivedById?: boolean
    paymentNumber?: boolean
    type?: boolean
    method?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    paymentDate?: boolean
    reference?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    customerId?: boolean
    receivedById?: boolean
    paymentNumber?: boolean
    type?: boolean
    method?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    paymentDate?: boolean
    reference?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    customerId?: boolean
    receivedById?: boolean
    paymentNumber?: boolean
    type?: boolean
    method?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    exchangeRate?: boolean
    paymentDate?: boolean
    reference?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "invoiceId" | "customerId" | "receivedById" | "paymentNumber" | "type" | "method" | "status" | "amount" | "currency" | "exchangeRate" | "paymentDate" | "reference" | "notes" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs>
      receivedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceId: string | null
      customerId: string
      receivedById: string
      paymentNumber: string
      type: $Enums.PaymentType
      method: $Enums.PaymentMethod
      status: $Enums.PaymentStatus
      amount: Prisma.Decimal
      currency: string
      exchangeRate: Prisma.Decimal
      paymentDate: Date
      reference: string | null
      notes: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receivedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly tenantId: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly customerId: FieldRef<"Payment", 'String'>
    readonly receivedById: FieldRef<"Payment", 'String'>
    readonly paymentNumber: FieldRef<"Payment", 'String'>
    readonly type: FieldRef<"Payment", 'PaymentType'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly exchangeRate: FieldRef<"Payment", 'Decimal'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    duration: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    duration: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    entityName: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    entityName: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    duration: number | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    action: number
    entityType: number
    entityId: number
    entityName: number
    oldValues: number
    newValues: number
    changedFields: number
    ipAddress: number
    userAgent: number
    requestId: number
    duration: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    duration?: true
  }

  export type AuditLogSumAggregateInputType = {
    duration?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    duration?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    duration?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    entityName?: true
    oldValues?: true
    newValues?: true
    changedFields?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    duration?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    action: string
    entityType: string
    entityId: string | null
    entityName: string | null
    oldValues: JsonValue | null
    newValues: JsonValue | null
    changedFields: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    duration: number | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    duration?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    duration?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    duration?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    entityName?: boolean
    oldValues?: boolean
    newValues?: boolean
    changedFields?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    duration?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "action" | "entityType" | "entityId" | "entityName" | "oldValues" | "newValues" | "changedFields" | "ipAddress" | "userAgent" | "requestId" | "duration" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      action: string
      entityType: string
      entityId: string | null
      entityName: string | null
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      changedFields: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      requestId: string | null
      duration: number | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly entityName: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly changedFields: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly requestId: FieldRef<"AuditLog", 'String'>
    readonly duration: FieldRef<"AuditLog", 'Int'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    purchaseCost: Decimal | null
    currentValue: Decimal | null
    usefulLifeYears: number | null
    salvageValue: Decimal | null
  }

  export type AssetSumAggregateOutputType = {
    purchaseCost: Decimal | null
    currentValue: Decimal | null
    usefulLifeYears: number | null
    salvageValue: Decimal | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    assetTag: string | null
    name: string | null
    description: string | null
    assetType: $Enums.AssetType | null
    category: $Enums.AssetCategory | null
    status: $Enums.AssetStatus | null
    location: string | null
    assignedTo: string | null
    purchaseDate: Date | null
    purchaseCost: Decimal | null
    currentValue: Decimal | null
    depreciationMethod: $Enums.DepreciationMethod | null
    usefulLifeYears: number | null
    salvageValue: Decimal | null
    warrantyExpiry: Date | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    assetTag: string | null
    name: string | null
    description: string | null
    assetType: $Enums.AssetType | null
    category: $Enums.AssetCategory | null
    status: $Enums.AssetStatus | null
    location: string | null
    assignedTo: string | null
    purchaseDate: Date | null
    purchaseCost: Decimal | null
    currentValue: Decimal | null
    depreciationMethod: $Enums.DepreciationMethod | null
    usefulLifeYears: number | null
    salvageValue: Decimal | null
    warrantyExpiry: Date | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    tenantId: number
    assetTag: number
    name: number
    description: number
    assetType: number
    category: number
    status: number
    location: number
    assignedTo: number
    purchaseDate: number
    purchaseCost: number
    currentValue: number
    depreciationMethod: number
    usefulLifeYears: number
    salvageValue: number
    warrantyExpiry: number
    serialNumber: number
    manufacturer: number
    model: number
    notes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    purchaseCost?: true
    currentValue?: true
    usefulLifeYears?: true
    salvageValue?: true
  }

  export type AssetSumAggregateInputType = {
    purchaseCost?: true
    currentValue?: true
    usefulLifeYears?: true
    salvageValue?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    tenantId?: true
    assetTag?: true
    name?: true
    description?: true
    assetType?: true
    category?: true
    status?: true
    location?: true
    assignedTo?: true
    purchaseDate?: true
    purchaseCost?: true
    currentValue?: true
    depreciationMethod?: true
    usefulLifeYears?: true
    salvageValue?: true
    warrantyExpiry?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    tenantId?: true
    assetTag?: true
    name?: true
    description?: true
    assetType?: true
    category?: true
    status?: true
    location?: true
    assignedTo?: true
    purchaseDate?: true
    purchaseCost?: true
    currentValue?: true
    depreciationMethod?: true
    usefulLifeYears?: true
    salvageValue?: true
    warrantyExpiry?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    tenantId?: true
    assetTag?: true
    name?: true
    description?: true
    assetType?: true
    category?: true
    status?: true
    location?: true
    assignedTo?: true
    purchaseDate?: true
    purchaseCost?: true
    currentValue?: true
    depreciationMethod?: true
    usefulLifeYears?: true
    salvageValue?: true
    warrantyExpiry?: true
    serialNumber?: true
    manufacturer?: true
    model?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    tenantId: string
    assetTag: string
    name: string
    description: string | null
    assetType: $Enums.AssetType
    category: $Enums.AssetCategory
    status: $Enums.AssetStatus
    location: string
    assignedTo: string | null
    purchaseDate: Date
    purchaseCost: Decimal
    currentValue: Decimal
    depreciationMethod: $Enums.DepreciationMethod
    usefulLifeYears: number | null
    salvageValue: Decimal | null
    warrantyExpiry: Date | null
    serialNumber: string | null
    manufacturer: string | null
    model: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    assetTag?: boolean
    name?: boolean
    description?: boolean
    assetType?: boolean
    category?: boolean
    status?: boolean
    location?: boolean
    assignedTo?: boolean
    purchaseDate?: boolean
    purchaseCost?: boolean
    currentValue?: boolean
    depreciationMethod?: boolean
    usefulLifeYears?: boolean
    salvageValue?: boolean
    warrantyExpiry?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    assetTag?: boolean
    name?: boolean
    description?: boolean
    assetType?: boolean
    category?: boolean
    status?: boolean
    location?: boolean
    assignedTo?: boolean
    purchaseDate?: boolean
    purchaseCost?: boolean
    currentValue?: boolean
    depreciationMethod?: boolean
    usefulLifeYears?: boolean
    salvageValue?: boolean
    warrantyExpiry?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    assetTag?: boolean
    name?: boolean
    description?: boolean
    assetType?: boolean
    category?: boolean
    status?: boolean
    location?: boolean
    assignedTo?: boolean
    purchaseDate?: boolean
    purchaseCost?: boolean
    currentValue?: boolean
    depreciationMethod?: boolean
    usefulLifeYears?: boolean
    salvageValue?: boolean
    warrantyExpiry?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    tenantId?: boolean
    assetTag?: boolean
    name?: boolean
    description?: boolean
    assetType?: boolean
    category?: boolean
    status?: boolean
    location?: boolean
    assignedTo?: boolean
    purchaseDate?: boolean
    purchaseCost?: boolean
    currentValue?: boolean
    depreciationMethod?: boolean
    usefulLifeYears?: boolean
    salvageValue?: boolean
    warrantyExpiry?: boolean
    serialNumber?: boolean
    manufacturer?: boolean
    model?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AssetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "assetTag" | "name" | "description" | "assetType" | "category" | "status" | "location" | "assignedTo" | "purchaseDate" | "purchaseCost" | "currentValue" | "depreciationMethod" | "usefulLifeYears" | "salvageValue" | "warrantyExpiry" | "serialNumber" | "manufacturer" | "model" | "notes" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["asset"]>
  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AssetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      assetTag: string
      name: string
      description: string | null
      assetType: $Enums.AssetType
      category: $Enums.AssetCategory
      status: $Enums.AssetStatus
      location: string
      assignedTo: string | null
      purchaseDate: Date
      purchaseCost: Prisma.Decimal
      currentValue: Prisma.Decimal
      depreciationMethod: $Enums.DepreciationMethod
      usefulLifeYears: number | null
      salvageValue: Prisma.Decimal | null
      warrantyExpiry: Date | null
      serialNumber: string | null
      manufacturer: string | null
      model: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets and returns the data updated in the database.
     * @param {AssetUpdateManyAndReturnArgs} args - Arguments to update many Assets.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly tenantId: FieldRef<"Asset", 'String'>
    readonly assetTag: FieldRef<"Asset", 'String'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly description: FieldRef<"Asset", 'String'>
    readonly assetType: FieldRef<"Asset", 'AssetType'>
    readonly category: FieldRef<"Asset", 'AssetCategory'>
    readonly status: FieldRef<"Asset", 'AssetStatus'>
    readonly location: FieldRef<"Asset", 'String'>
    readonly assignedTo: FieldRef<"Asset", 'String'>
    readonly purchaseDate: FieldRef<"Asset", 'DateTime'>
    readonly purchaseCost: FieldRef<"Asset", 'Decimal'>
    readonly currentValue: FieldRef<"Asset", 'Decimal'>
    readonly depreciationMethod: FieldRef<"Asset", 'DepreciationMethod'>
    readonly usefulLifeYears: FieldRef<"Asset", 'Int'>
    readonly salvageValue: FieldRef<"Asset", 'Decimal'>
    readonly warrantyExpiry: FieldRef<"Asset", 'DateTime'>
    readonly serialNumber: FieldRef<"Asset", 'String'>
    readonly manufacturer: FieldRef<"Asset", 'String'>
    readonly model: FieldRef<"Asset", 'String'>
    readonly notes: FieldRef<"Asset", 'String'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
    readonly deletedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
  }

  /**
   * Asset updateManyAndReturn
   */
  export type AssetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
    /**
     * Limit how many Assets to delete.
     */
    limit?: number
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Asset
     */
    omit?: AssetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model EInvoice
   */

  export type AggregateEInvoice = {
    _count: EInvoiceCountAggregateOutputType | null
    _avg: EInvoiceAvgAggregateOutputType | null
    _sum: EInvoiceSumAggregateOutputType | null
    _min: EInvoiceMinAggregateOutputType | null
    _max: EInvoiceMaxAggregateOutputType | null
  }

  export type EInvoiceAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type EInvoiceSumAggregateOutputType = {
    retryCount: number | null
  }

  export type EInvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    invoiceType: $Enums.EInvoiceType | null
    status: $Enums.EInvoiceStatus | null
    lhdnUuid: string | null
    lhdnLongId: string | null
    lhdnSubmissionUid: string | null
    submittedAt: Date | null
    validatedAt: Date | null
    cancelledAt: Date | null
    rejectedAt: Date | null
    documentHash: string | null
    rejectReason: string | null
    retryCount: number | null
    lastRetryAt: Date | null
    originalEInvoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EInvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceId: string | null
    invoiceType: $Enums.EInvoiceType | null
    status: $Enums.EInvoiceStatus | null
    lhdnUuid: string | null
    lhdnLongId: string | null
    lhdnSubmissionUid: string | null
    submittedAt: Date | null
    validatedAt: Date | null
    cancelledAt: Date | null
    rejectedAt: Date | null
    documentHash: string | null
    rejectReason: string | null
    retryCount: number | null
    lastRetryAt: Date | null
    originalEInvoiceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EInvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceId: number
    invoiceType: number
    status: number
    lhdnUuid: number
    lhdnLongId: number
    lhdnSubmissionUid: number
    submittedAt: number
    validatedAt: number
    cancelledAt: number
    rejectedAt: number
    requestJson: number
    responseJson: number
    documentHash: number
    rejectReason: number
    validationErrors: number
    retryCount: number
    lastRetryAt: number
    originalEInvoiceId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EInvoiceAvgAggregateInputType = {
    retryCount?: true
  }

  export type EInvoiceSumAggregateInputType = {
    retryCount?: true
  }

  export type EInvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    invoiceType?: true
    status?: true
    lhdnUuid?: true
    lhdnLongId?: true
    lhdnSubmissionUid?: true
    submittedAt?: true
    validatedAt?: true
    cancelledAt?: true
    rejectedAt?: true
    documentHash?: true
    rejectReason?: true
    retryCount?: true
    lastRetryAt?: true
    originalEInvoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EInvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    invoiceType?: true
    status?: true
    lhdnUuid?: true
    lhdnLongId?: true
    lhdnSubmissionUid?: true
    submittedAt?: true
    validatedAt?: true
    cancelledAt?: true
    rejectedAt?: true
    documentHash?: true
    rejectReason?: true
    retryCount?: true
    lastRetryAt?: true
    originalEInvoiceId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EInvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceId?: true
    invoiceType?: true
    status?: true
    lhdnUuid?: true
    lhdnLongId?: true
    lhdnSubmissionUid?: true
    submittedAt?: true
    validatedAt?: true
    cancelledAt?: true
    rejectedAt?: true
    requestJson?: true
    responseJson?: true
    documentHash?: true
    rejectReason?: true
    validationErrors?: true
    retryCount?: true
    lastRetryAt?: true
    originalEInvoiceId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EInvoice to aggregate.
     */
    where?: EInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoices to fetch.
     */
    orderBy?: EInvoiceOrderByWithRelationInput | EInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EInvoices
    **/
    _count?: true | EInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EInvoiceMaxAggregateInputType
  }

  export type GetEInvoiceAggregateType<T extends EInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateEInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEInvoice[P]>
      : GetScalarType<T[P], AggregateEInvoice[P]>
  }




  export type EInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceWhereInput
    orderBy?: EInvoiceOrderByWithAggregationInput | EInvoiceOrderByWithAggregationInput[]
    by: EInvoiceScalarFieldEnum[] | EInvoiceScalarFieldEnum
    having?: EInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EInvoiceCountAggregateInputType | true
    _avg?: EInvoiceAvgAggregateInputType
    _sum?: EInvoiceSumAggregateInputType
    _min?: EInvoiceMinAggregateInputType
    _max?: EInvoiceMaxAggregateInputType
  }

  export type EInvoiceGroupByOutputType = {
    id: string
    tenantId: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status: $Enums.EInvoiceStatus
    lhdnUuid: string | null
    lhdnLongId: string | null
    lhdnSubmissionUid: string | null
    submittedAt: Date | null
    validatedAt: Date | null
    cancelledAt: Date | null
    rejectedAt: Date | null
    requestJson: JsonValue | null
    responseJson: JsonValue | null
    documentHash: string | null
    rejectReason: string | null
    validationErrors: JsonValue | null
    retryCount: number
    lastRetryAt: Date | null
    originalEInvoiceId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EInvoiceCountAggregateOutputType | null
    _avg: EInvoiceAvgAggregateOutputType | null
    _sum: EInvoiceSumAggregateOutputType | null
    _min: EInvoiceMinAggregateOutputType | null
    _max: EInvoiceMaxAggregateOutputType | null
  }

  type GetEInvoiceGroupByPayload<T extends EInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], EInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type EInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    invoiceType?: boolean
    status?: boolean
    lhdnUuid?: boolean
    lhdnLongId?: boolean
    lhdnSubmissionUid?: boolean
    submittedAt?: boolean
    validatedAt?: boolean
    cancelledAt?: boolean
    rejectedAt?: boolean
    requestJson?: boolean
    responseJson?: boolean
    documentHash?: boolean
    rejectReason?: boolean
    validationErrors?: boolean
    retryCount?: boolean
    lastRetryAt?: boolean
    originalEInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    originalEInvoice?: boolean | EInvoice$originalEInvoiceArgs<ExtArgs>
    relatedEInvoices?: boolean | EInvoice$relatedEInvoicesArgs<ExtArgs>
    items?: boolean | EInvoice$itemsArgs<ExtArgs>
    logs?: boolean | EInvoice$logsArgs<ExtArgs>
    _count?: boolean | EInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoice"]>

  export type EInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    invoiceType?: boolean
    status?: boolean
    lhdnUuid?: boolean
    lhdnLongId?: boolean
    lhdnSubmissionUid?: boolean
    submittedAt?: boolean
    validatedAt?: boolean
    cancelledAt?: boolean
    rejectedAt?: boolean
    requestJson?: boolean
    responseJson?: boolean
    documentHash?: boolean
    rejectReason?: boolean
    validationErrors?: boolean
    retryCount?: boolean
    lastRetryAt?: boolean
    originalEInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    originalEInvoice?: boolean | EInvoice$originalEInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoice"]>

  export type EInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    invoiceType?: boolean
    status?: boolean
    lhdnUuid?: boolean
    lhdnLongId?: boolean
    lhdnSubmissionUid?: boolean
    submittedAt?: boolean
    validatedAt?: boolean
    cancelledAt?: boolean
    rejectedAt?: boolean
    requestJson?: boolean
    responseJson?: boolean
    documentHash?: boolean
    rejectReason?: boolean
    validationErrors?: boolean
    retryCount?: boolean
    lastRetryAt?: boolean
    originalEInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    originalEInvoice?: boolean | EInvoice$originalEInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoice"]>

  export type EInvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceId?: boolean
    invoiceType?: boolean
    status?: boolean
    lhdnUuid?: boolean
    lhdnLongId?: boolean
    lhdnSubmissionUid?: boolean
    submittedAt?: boolean
    validatedAt?: boolean
    cancelledAt?: boolean
    rejectedAt?: boolean
    requestJson?: boolean
    responseJson?: boolean
    documentHash?: boolean
    rejectReason?: boolean
    validationErrors?: boolean
    retryCount?: boolean
    lastRetryAt?: boolean
    originalEInvoiceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "invoiceId" | "invoiceType" | "status" | "lhdnUuid" | "lhdnLongId" | "lhdnSubmissionUid" | "submittedAt" | "validatedAt" | "cancelledAt" | "rejectedAt" | "requestJson" | "responseJson" | "documentHash" | "rejectReason" | "validationErrors" | "retryCount" | "lastRetryAt" | "originalEInvoiceId" | "createdAt" | "updatedAt", ExtArgs["result"]["eInvoice"]>
  export type EInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    originalEInvoice?: boolean | EInvoice$originalEInvoiceArgs<ExtArgs>
    relatedEInvoices?: boolean | EInvoice$relatedEInvoicesArgs<ExtArgs>
    items?: boolean | EInvoice$itemsArgs<ExtArgs>
    logs?: boolean | EInvoice$logsArgs<ExtArgs>
    _count?: boolean | EInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    originalEInvoice?: boolean | EInvoice$originalEInvoiceArgs<ExtArgs>
  }
  export type EInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    originalEInvoice?: boolean | EInvoice$originalEInvoiceArgs<ExtArgs>
  }

  export type $EInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EInvoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
      originalEInvoice: Prisma.$EInvoicePayload<ExtArgs> | null
      relatedEInvoices: Prisma.$EInvoicePayload<ExtArgs>[]
      items: Prisma.$EInvoiceItemPayload<ExtArgs>[]
      logs: Prisma.$EInvoiceLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceId: string
      invoiceType: $Enums.EInvoiceType
      status: $Enums.EInvoiceStatus
      lhdnUuid: string | null
      lhdnLongId: string | null
      lhdnSubmissionUid: string | null
      submittedAt: Date | null
      validatedAt: Date | null
      cancelledAt: Date | null
      rejectedAt: Date | null
      requestJson: Prisma.JsonValue | null
      responseJson: Prisma.JsonValue | null
      documentHash: string | null
      rejectReason: string | null
      validationErrors: Prisma.JsonValue | null
      retryCount: number
      lastRetryAt: Date | null
      originalEInvoiceId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eInvoice"]>
    composites: {}
  }

  type EInvoiceGetPayload<S extends boolean | null | undefined | EInvoiceDefaultArgs> = $Result.GetResult<Prisma.$EInvoicePayload, S>

  type EInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EInvoiceCountAggregateInputType | true
    }

  export interface EInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EInvoice'], meta: { name: 'EInvoice' } }
    /**
     * Find zero or one EInvoice that matches the filter.
     * @param {EInvoiceFindUniqueArgs} args - Arguments to find a EInvoice
     * @example
     * // Get one EInvoice
     * const eInvoice = await prisma.eInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EInvoiceFindUniqueArgs>(args: SelectSubset<T, EInvoiceFindUniqueArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EInvoiceFindUniqueOrThrowArgs} args - Arguments to find a EInvoice
     * @example
     * // Get one EInvoice
     * const eInvoice = await prisma.eInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, EInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceFindFirstArgs} args - Arguments to find a EInvoice
     * @example
     * // Get one EInvoice
     * const eInvoice = await prisma.eInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EInvoiceFindFirstArgs>(args?: SelectSubset<T, EInvoiceFindFirstArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceFindFirstOrThrowArgs} args - Arguments to find a EInvoice
     * @example
     * // Get one EInvoice
     * const eInvoice = await prisma.eInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, EInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EInvoices
     * const eInvoices = await prisma.eInvoice.findMany()
     * 
     * // Get first 10 EInvoices
     * const eInvoices = await prisma.eInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eInvoiceWithIdOnly = await prisma.eInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EInvoiceFindManyArgs>(args?: SelectSubset<T, EInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EInvoice.
     * @param {EInvoiceCreateArgs} args - Arguments to create a EInvoice.
     * @example
     * // Create one EInvoice
     * const EInvoice = await prisma.eInvoice.create({
     *   data: {
     *     // ... data to create a EInvoice
     *   }
     * })
     * 
     */
    create<T extends EInvoiceCreateArgs>(args: SelectSubset<T, EInvoiceCreateArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EInvoices.
     * @param {EInvoiceCreateManyArgs} args - Arguments to create many EInvoices.
     * @example
     * // Create many EInvoices
     * const eInvoice = await prisma.eInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EInvoiceCreateManyArgs>(args?: SelectSubset<T, EInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EInvoices and returns the data saved in the database.
     * @param {EInvoiceCreateManyAndReturnArgs} args - Arguments to create many EInvoices.
     * @example
     * // Create many EInvoices
     * const eInvoice = await prisma.eInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EInvoices and only return the `id`
     * const eInvoiceWithIdOnly = await prisma.eInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, EInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EInvoice.
     * @param {EInvoiceDeleteArgs} args - Arguments to delete one EInvoice.
     * @example
     * // Delete one EInvoice
     * const EInvoice = await prisma.eInvoice.delete({
     *   where: {
     *     // ... filter to delete one EInvoice
     *   }
     * })
     * 
     */
    delete<T extends EInvoiceDeleteArgs>(args: SelectSubset<T, EInvoiceDeleteArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EInvoice.
     * @param {EInvoiceUpdateArgs} args - Arguments to update one EInvoice.
     * @example
     * // Update one EInvoice
     * const eInvoice = await prisma.eInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EInvoiceUpdateArgs>(args: SelectSubset<T, EInvoiceUpdateArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EInvoices.
     * @param {EInvoiceDeleteManyArgs} args - Arguments to filter EInvoices to delete.
     * @example
     * // Delete a few EInvoices
     * const { count } = await prisma.eInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EInvoiceDeleteManyArgs>(args?: SelectSubset<T, EInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EInvoices
     * const eInvoice = await prisma.eInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EInvoiceUpdateManyArgs>(args: SelectSubset<T, EInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EInvoices and returns the data updated in the database.
     * @param {EInvoiceUpdateManyAndReturnArgs} args - Arguments to update many EInvoices.
     * @example
     * // Update many EInvoices
     * const eInvoice = await prisma.eInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EInvoices and only return the `id`
     * const eInvoiceWithIdOnly = await prisma.eInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, EInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EInvoice.
     * @param {EInvoiceUpsertArgs} args - Arguments to update or create a EInvoice.
     * @example
     * // Update or create a EInvoice
     * const eInvoice = await prisma.eInvoice.upsert({
     *   create: {
     *     // ... data to create a EInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EInvoice we want to update
     *   }
     * })
     */
    upsert<T extends EInvoiceUpsertArgs>(args: SelectSubset<T, EInvoiceUpsertArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceCountArgs} args - Arguments to filter EInvoices to count.
     * @example
     * // Count the number of EInvoices
     * const count = await prisma.eInvoice.count({
     *   where: {
     *     // ... the filter for the EInvoices we want to count
     *   }
     * })
    **/
    count<T extends EInvoiceCountArgs>(
      args?: Subset<T, EInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EInvoiceAggregateArgs>(args: Subset<T, EInvoiceAggregateArgs>): Prisma.PrismaPromise<GetEInvoiceAggregateType<T>>

    /**
     * Group by EInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: EInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EInvoice model
   */
  readonly fields: EInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    originalEInvoice<T extends EInvoice$originalEInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, EInvoice$originalEInvoiceArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    relatedEInvoices<T extends EInvoice$relatedEInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, EInvoice$relatedEInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends EInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, EInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends EInvoice$logsArgs<ExtArgs> = {}>(args?: Subset<T, EInvoice$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EInvoice model
   */
  interface EInvoiceFieldRefs {
    readonly id: FieldRef<"EInvoice", 'String'>
    readonly tenantId: FieldRef<"EInvoice", 'String'>
    readonly invoiceId: FieldRef<"EInvoice", 'String'>
    readonly invoiceType: FieldRef<"EInvoice", 'EInvoiceType'>
    readonly status: FieldRef<"EInvoice", 'EInvoiceStatus'>
    readonly lhdnUuid: FieldRef<"EInvoice", 'String'>
    readonly lhdnLongId: FieldRef<"EInvoice", 'String'>
    readonly lhdnSubmissionUid: FieldRef<"EInvoice", 'String'>
    readonly submittedAt: FieldRef<"EInvoice", 'DateTime'>
    readonly validatedAt: FieldRef<"EInvoice", 'DateTime'>
    readonly cancelledAt: FieldRef<"EInvoice", 'DateTime'>
    readonly rejectedAt: FieldRef<"EInvoice", 'DateTime'>
    readonly requestJson: FieldRef<"EInvoice", 'Json'>
    readonly responseJson: FieldRef<"EInvoice", 'Json'>
    readonly documentHash: FieldRef<"EInvoice", 'String'>
    readonly rejectReason: FieldRef<"EInvoice", 'String'>
    readonly validationErrors: FieldRef<"EInvoice", 'Json'>
    readonly retryCount: FieldRef<"EInvoice", 'Int'>
    readonly lastRetryAt: FieldRef<"EInvoice", 'DateTime'>
    readonly originalEInvoiceId: FieldRef<"EInvoice", 'String'>
    readonly createdAt: FieldRef<"EInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"EInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EInvoice findUnique
   */
  export type EInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which EInvoice to fetch.
     */
    where: EInvoiceWhereUniqueInput
  }

  /**
   * EInvoice findUniqueOrThrow
   */
  export type EInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which EInvoice to fetch.
     */
    where: EInvoiceWhereUniqueInput
  }

  /**
   * EInvoice findFirst
   */
  export type EInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which EInvoice to fetch.
     */
    where?: EInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoices to fetch.
     */
    orderBy?: EInvoiceOrderByWithRelationInput | EInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EInvoices.
     */
    cursor?: EInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EInvoices.
     */
    distinct?: EInvoiceScalarFieldEnum | EInvoiceScalarFieldEnum[]
  }

  /**
   * EInvoice findFirstOrThrow
   */
  export type EInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which EInvoice to fetch.
     */
    where?: EInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoices to fetch.
     */
    orderBy?: EInvoiceOrderByWithRelationInput | EInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EInvoices.
     */
    cursor?: EInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EInvoices.
     */
    distinct?: EInvoiceScalarFieldEnum | EInvoiceScalarFieldEnum[]
  }

  /**
   * EInvoice findMany
   */
  export type EInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which EInvoices to fetch.
     */
    where?: EInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoices to fetch.
     */
    orderBy?: EInvoiceOrderByWithRelationInput | EInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EInvoices.
     */
    cursor?: EInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoices.
     */
    skip?: number
    distinct?: EInvoiceScalarFieldEnum | EInvoiceScalarFieldEnum[]
  }

  /**
   * EInvoice create
   */
  export type EInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a EInvoice.
     */
    data: XOR<EInvoiceCreateInput, EInvoiceUncheckedCreateInput>
  }

  /**
   * EInvoice createMany
   */
  export type EInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EInvoices.
     */
    data: EInvoiceCreateManyInput | EInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EInvoice createManyAndReturn
   */
  export type EInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many EInvoices.
     */
    data: EInvoiceCreateManyInput | EInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EInvoice update
   */
  export type EInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a EInvoice.
     */
    data: XOR<EInvoiceUpdateInput, EInvoiceUncheckedUpdateInput>
    /**
     * Choose, which EInvoice to update.
     */
    where: EInvoiceWhereUniqueInput
  }

  /**
   * EInvoice updateMany
   */
  export type EInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EInvoices.
     */
    data: XOR<EInvoiceUpdateManyMutationInput, EInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which EInvoices to update
     */
    where?: EInvoiceWhereInput
    /**
     * Limit how many EInvoices to update.
     */
    limit?: number
  }

  /**
   * EInvoice updateManyAndReturn
   */
  export type EInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update EInvoices.
     */
    data: XOR<EInvoiceUpdateManyMutationInput, EInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which EInvoices to update
     */
    where?: EInvoiceWhereInput
    /**
     * Limit how many EInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EInvoice upsert
   */
  export type EInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the EInvoice to update in case it exists.
     */
    where: EInvoiceWhereUniqueInput
    /**
     * In case the EInvoice found by the `where` argument doesn't exist, create a new EInvoice with this data.
     */
    create: XOR<EInvoiceCreateInput, EInvoiceUncheckedCreateInput>
    /**
     * In case the EInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EInvoiceUpdateInput, EInvoiceUncheckedUpdateInput>
  }

  /**
   * EInvoice delete
   */
  export type EInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    /**
     * Filter which EInvoice to delete.
     */
    where: EInvoiceWhereUniqueInput
  }

  /**
   * EInvoice deleteMany
   */
  export type EInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EInvoices to delete
     */
    where?: EInvoiceWhereInput
    /**
     * Limit how many EInvoices to delete.
     */
    limit?: number
  }

  /**
   * EInvoice.originalEInvoice
   */
  export type EInvoice$originalEInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    where?: EInvoiceWhereInput
  }

  /**
   * EInvoice.relatedEInvoices
   */
  export type EInvoice$relatedEInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
    where?: EInvoiceWhereInput
    orderBy?: EInvoiceOrderByWithRelationInput | EInvoiceOrderByWithRelationInput[]
    cursor?: EInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EInvoiceScalarFieldEnum | EInvoiceScalarFieldEnum[]
  }

  /**
   * EInvoice.items
   */
  export type EInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    where?: EInvoiceItemWhereInput
    orderBy?: EInvoiceItemOrderByWithRelationInput | EInvoiceItemOrderByWithRelationInput[]
    cursor?: EInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EInvoiceItemScalarFieldEnum | EInvoiceItemScalarFieldEnum[]
  }

  /**
   * EInvoice.logs
   */
  export type EInvoice$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    where?: EInvoiceLogWhereInput
    orderBy?: EInvoiceLogOrderByWithRelationInput | EInvoiceLogOrderByWithRelationInput[]
    cursor?: EInvoiceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EInvoiceLogScalarFieldEnum | EInvoiceLogScalarFieldEnum[]
  }

  /**
   * EInvoice without action
   */
  export type EInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoice
     */
    select?: EInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoice
     */
    omit?: EInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model EInvoiceItem
   */

  export type AggregateEInvoiceItem = {
    _count: EInvoiceItemCountAggregateOutputType | null
    _avg: EInvoiceItemAvgAggregateOutputType | null
    _sum: EInvoiceItemSumAggregateOutputType | null
    _min: EInvoiceItemMinAggregateOutputType | null
    _max: EInvoiceItemMaxAggregateOutputType | null
  }

  export type EInvoiceItemAvgAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    discountRate: Decimal | null
    totalAmount: Decimal | null
    sortOrder: number | null
  }

  export type EInvoiceItemSumAggregateOutputType = {
    quantity: Decimal | null
    unitPrice: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    discountRate: Decimal | null
    totalAmount: Decimal | null
    sortOrder: number | null
  }

  export type EInvoiceItemMinAggregateOutputType = {
    id: string | null
    eInvoiceId: string | null
    invoiceItemId: string | null
    classificationCode: string | null
    description: string | null
    quantity: Decimal | null
    unitCode: string | null
    unitPrice: Decimal | null
    taxType: string | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    taxExemptReason: string | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    discountRate: Decimal | null
    totalAmount: Decimal | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EInvoiceItemMaxAggregateOutputType = {
    id: string | null
    eInvoiceId: string | null
    invoiceItemId: string | null
    classificationCode: string | null
    description: string | null
    quantity: Decimal | null
    unitCode: string | null
    unitPrice: Decimal | null
    taxType: string | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    taxExemptReason: string | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    discountRate: Decimal | null
    totalAmount: Decimal | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EInvoiceItemCountAggregateOutputType = {
    id: number
    eInvoiceId: number
    invoiceItemId: number
    classificationCode: number
    description: number
    quantity: number
    unitCode: number
    unitPrice: number
    taxType: number
    taxRate: number
    taxAmount: number
    taxExemptReason: number
    subtotal: number
    discountAmount: number
    discountRate: number
    totalAmount: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EInvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    taxRate?: true
    taxAmount?: true
    subtotal?: true
    discountAmount?: true
    discountRate?: true
    totalAmount?: true
    sortOrder?: true
  }

  export type EInvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    taxRate?: true
    taxAmount?: true
    subtotal?: true
    discountAmount?: true
    discountRate?: true
    totalAmount?: true
    sortOrder?: true
  }

  export type EInvoiceItemMinAggregateInputType = {
    id?: true
    eInvoiceId?: true
    invoiceItemId?: true
    classificationCode?: true
    description?: true
    quantity?: true
    unitCode?: true
    unitPrice?: true
    taxType?: true
    taxRate?: true
    taxAmount?: true
    taxExemptReason?: true
    subtotal?: true
    discountAmount?: true
    discountRate?: true
    totalAmount?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EInvoiceItemMaxAggregateInputType = {
    id?: true
    eInvoiceId?: true
    invoiceItemId?: true
    classificationCode?: true
    description?: true
    quantity?: true
    unitCode?: true
    unitPrice?: true
    taxType?: true
    taxRate?: true
    taxAmount?: true
    taxExemptReason?: true
    subtotal?: true
    discountAmount?: true
    discountRate?: true
    totalAmount?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EInvoiceItemCountAggregateInputType = {
    id?: true
    eInvoiceId?: true
    invoiceItemId?: true
    classificationCode?: true
    description?: true
    quantity?: true
    unitCode?: true
    unitPrice?: true
    taxType?: true
    taxRate?: true
    taxAmount?: true
    taxExemptReason?: true
    subtotal?: true
    discountAmount?: true
    discountRate?: true
    totalAmount?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EInvoiceItem to aggregate.
     */
    where?: EInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoiceItems to fetch.
     */
    orderBy?: EInvoiceItemOrderByWithRelationInput | EInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EInvoiceItems
    **/
    _count?: true | EInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EInvoiceItemMaxAggregateInputType
  }

  export type GetEInvoiceItemAggregateType<T extends EInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateEInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEInvoiceItem[P]>
      : GetScalarType<T[P], AggregateEInvoiceItem[P]>
  }




  export type EInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceItemWhereInput
    orderBy?: EInvoiceItemOrderByWithAggregationInput | EInvoiceItemOrderByWithAggregationInput[]
    by: EInvoiceItemScalarFieldEnum[] | EInvoiceItemScalarFieldEnum
    having?: EInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EInvoiceItemCountAggregateInputType | true
    _avg?: EInvoiceItemAvgAggregateInputType
    _sum?: EInvoiceItemSumAggregateInputType
    _min?: EInvoiceItemMinAggregateInputType
    _max?: EInvoiceItemMaxAggregateInputType
  }

  export type EInvoiceItemGroupByOutputType = {
    id: string
    eInvoiceId: string
    invoiceItemId: string | null
    classificationCode: string
    description: string
    quantity: Decimal
    unitCode: string
    unitPrice: Decimal
    taxType: string
    taxRate: Decimal
    taxAmount: Decimal
    taxExemptReason: string | null
    subtotal: Decimal
    discountAmount: Decimal
    discountRate: Decimal
    totalAmount: Decimal
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: EInvoiceItemCountAggregateOutputType | null
    _avg: EInvoiceItemAvgAggregateOutputType | null
    _sum: EInvoiceItemSumAggregateOutputType | null
    _min: EInvoiceItemMinAggregateOutputType | null
    _max: EInvoiceItemMaxAggregateOutputType | null
  }

  type GetEInvoiceItemGroupByPayload<T extends EInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], EInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type EInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eInvoiceId?: boolean
    invoiceItemId?: boolean
    classificationCode?: boolean
    description?: boolean
    quantity?: boolean
    unitCode?: boolean
    unitPrice?: boolean
    taxType?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    taxExemptReason?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    discountRate?: boolean
    totalAmount?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
    invoiceItem?: boolean | EInvoiceItem$invoiceItemArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoiceItem"]>

  export type EInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eInvoiceId?: boolean
    invoiceItemId?: boolean
    classificationCode?: boolean
    description?: boolean
    quantity?: boolean
    unitCode?: boolean
    unitPrice?: boolean
    taxType?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    taxExemptReason?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    discountRate?: boolean
    totalAmount?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
    invoiceItem?: boolean | EInvoiceItem$invoiceItemArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoiceItem"]>

  export type EInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eInvoiceId?: boolean
    invoiceItemId?: boolean
    classificationCode?: boolean
    description?: boolean
    quantity?: boolean
    unitCode?: boolean
    unitPrice?: boolean
    taxType?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    taxExemptReason?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    discountRate?: boolean
    totalAmount?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
    invoiceItem?: boolean | EInvoiceItem$invoiceItemArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoiceItem"]>

  export type EInvoiceItemSelectScalar = {
    id?: boolean
    eInvoiceId?: boolean
    invoiceItemId?: boolean
    classificationCode?: boolean
    description?: boolean
    quantity?: boolean
    unitCode?: boolean
    unitPrice?: boolean
    taxType?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    taxExemptReason?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    discountRate?: boolean
    totalAmount?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eInvoiceId" | "invoiceItemId" | "classificationCode" | "description" | "quantity" | "unitCode" | "unitPrice" | "taxType" | "taxRate" | "taxAmount" | "taxExemptReason" | "subtotal" | "discountAmount" | "discountRate" | "totalAmount" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["eInvoiceItem"]>
  export type EInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
    invoiceItem?: boolean | EInvoiceItem$invoiceItemArgs<ExtArgs>
  }
  export type EInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
    invoiceItem?: boolean | EInvoiceItem$invoiceItemArgs<ExtArgs>
  }
  export type EInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
    invoiceItem?: boolean | EInvoiceItem$invoiceItemArgs<ExtArgs>
  }

  export type $EInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EInvoiceItem"
    objects: {
      eInvoice: Prisma.$EInvoicePayload<ExtArgs>
      invoiceItem: Prisma.$InvoiceItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eInvoiceId: string
      invoiceItemId: string | null
      classificationCode: string
      description: string
      quantity: Prisma.Decimal
      unitCode: string
      unitPrice: Prisma.Decimal
      taxType: string
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      taxExemptReason: string | null
      subtotal: Prisma.Decimal
      discountAmount: Prisma.Decimal
      discountRate: Prisma.Decimal
      totalAmount: Prisma.Decimal
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["eInvoiceItem"]>
    composites: {}
  }

  type EInvoiceItemGetPayload<S extends boolean | null | undefined | EInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$EInvoiceItemPayload, S>

  type EInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EInvoiceItemCountAggregateInputType | true
    }

  export interface EInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EInvoiceItem'], meta: { name: 'EInvoiceItem' } }
    /**
     * Find zero or one EInvoiceItem that matches the filter.
     * @param {EInvoiceItemFindUniqueArgs} args - Arguments to find a EInvoiceItem
     * @example
     * // Get one EInvoiceItem
     * const eInvoiceItem = await prisma.eInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EInvoiceItemFindUniqueArgs>(args: SelectSubset<T, EInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__EInvoiceItemClient<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a EInvoiceItem
     * @example
     * // Get one EInvoiceItem
     * const eInvoiceItem = await prisma.eInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, EInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EInvoiceItemClient<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceItemFindFirstArgs} args - Arguments to find a EInvoiceItem
     * @example
     * // Get one EInvoiceItem
     * const eInvoiceItem = await prisma.eInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EInvoiceItemFindFirstArgs>(args?: SelectSubset<T, EInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__EInvoiceItemClient<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a EInvoiceItem
     * @example
     * // Get one EInvoiceItem
     * const eInvoiceItem = await prisma.eInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, EInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__EInvoiceItemClient<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EInvoiceItems
     * const eInvoiceItems = await prisma.eInvoiceItem.findMany()
     * 
     * // Get first 10 EInvoiceItems
     * const eInvoiceItems = await prisma.eInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eInvoiceItemWithIdOnly = await prisma.eInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EInvoiceItemFindManyArgs>(args?: SelectSubset<T, EInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EInvoiceItem.
     * @param {EInvoiceItemCreateArgs} args - Arguments to create a EInvoiceItem.
     * @example
     * // Create one EInvoiceItem
     * const EInvoiceItem = await prisma.eInvoiceItem.create({
     *   data: {
     *     // ... data to create a EInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends EInvoiceItemCreateArgs>(args: SelectSubset<T, EInvoiceItemCreateArgs<ExtArgs>>): Prisma__EInvoiceItemClient<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EInvoiceItems.
     * @param {EInvoiceItemCreateManyArgs} args - Arguments to create many EInvoiceItems.
     * @example
     * // Create many EInvoiceItems
     * const eInvoiceItem = await prisma.eInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EInvoiceItemCreateManyArgs>(args?: SelectSubset<T, EInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EInvoiceItems and returns the data saved in the database.
     * @param {EInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many EInvoiceItems.
     * @example
     * // Create many EInvoiceItems
     * const eInvoiceItem = await prisma.eInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EInvoiceItems and only return the `id`
     * const eInvoiceItemWithIdOnly = await prisma.eInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, EInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EInvoiceItem.
     * @param {EInvoiceItemDeleteArgs} args - Arguments to delete one EInvoiceItem.
     * @example
     * // Delete one EInvoiceItem
     * const EInvoiceItem = await prisma.eInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one EInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends EInvoiceItemDeleteArgs>(args: SelectSubset<T, EInvoiceItemDeleteArgs<ExtArgs>>): Prisma__EInvoiceItemClient<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EInvoiceItem.
     * @param {EInvoiceItemUpdateArgs} args - Arguments to update one EInvoiceItem.
     * @example
     * // Update one EInvoiceItem
     * const eInvoiceItem = await prisma.eInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EInvoiceItemUpdateArgs>(args: SelectSubset<T, EInvoiceItemUpdateArgs<ExtArgs>>): Prisma__EInvoiceItemClient<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EInvoiceItems.
     * @param {EInvoiceItemDeleteManyArgs} args - Arguments to filter EInvoiceItems to delete.
     * @example
     * // Delete a few EInvoiceItems
     * const { count } = await prisma.eInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, EInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EInvoiceItems
     * const eInvoiceItem = await prisma.eInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EInvoiceItemUpdateManyArgs>(args: SelectSubset<T, EInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EInvoiceItems and returns the data updated in the database.
     * @param {EInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many EInvoiceItems.
     * @example
     * // Update many EInvoiceItems
     * const eInvoiceItem = await prisma.eInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EInvoiceItems and only return the `id`
     * const eInvoiceItemWithIdOnly = await prisma.eInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, EInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EInvoiceItem.
     * @param {EInvoiceItemUpsertArgs} args - Arguments to update or create a EInvoiceItem.
     * @example
     * // Update or create a EInvoiceItem
     * const eInvoiceItem = await prisma.eInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a EInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends EInvoiceItemUpsertArgs>(args: SelectSubset<T, EInvoiceItemUpsertArgs<ExtArgs>>): Prisma__EInvoiceItemClient<$Result.GetResult<Prisma.$EInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceItemCountArgs} args - Arguments to filter EInvoiceItems to count.
     * @example
     * // Count the number of EInvoiceItems
     * const count = await prisma.eInvoiceItem.count({
     *   where: {
     *     // ... the filter for the EInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends EInvoiceItemCountArgs>(
      args?: Subset<T, EInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EInvoiceItemAggregateArgs>(args: Subset<T, EInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetEInvoiceItemAggregateType<T>>

    /**
     * Group by EInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: EInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EInvoiceItem model
   */
  readonly fields: EInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eInvoice<T extends EInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EInvoiceDefaultArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoiceItem<T extends EInvoiceItem$invoiceItemArgs<ExtArgs> = {}>(args?: Subset<T, EInvoiceItem$invoiceItemArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EInvoiceItem model
   */
  interface EInvoiceItemFieldRefs {
    readonly id: FieldRef<"EInvoiceItem", 'String'>
    readonly eInvoiceId: FieldRef<"EInvoiceItem", 'String'>
    readonly invoiceItemId: FieldRef<"EInvoiceItem", 'String'>
    readonly classificationCode: FieldRef<"EInvoiceItem", 'String'>
    readonly description: FieldRef<"EInvoiceItem", 'String'>
    readonly quantity: FieldRef<"EInvoiceItem", 'Decimal'>
    readonly unitCode: FieldRef<"EInvoiceItem", 'String'>
    readonly unitPrice: FieldRef<"EInvoiceItem", 'Decimal'>
    readonly taxType: FieldRef<"EInvoiceItem", 'String'>
    readonly taxRate: FieldRef<"EInvoiceItem", 'Decimal'>
    readonly taxAmount: FieldRef<"EInvoiceItem", 'Decimal'>
    readonly taxExemptReason: FieldRef<"EInvoiceItem", 'String'>
    readonly subtotal: FieldRef<"EInvoiceItem", 'Decimal'>
    readonly discountAmount: FieldRef<"EInvoiceItem", 'Decimal'>
    readonly discountRate: FieldRef<"EInvoiceItem", 'Decimal'>
    readonly totalAmount: FieldRef<"EInvoiceItem", 'Decimal'>
    readonly sortOrder: FieldRef<"EInvoiceItem", 'Int'>
    readonly createdAt: FieldRef<"EInvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"EInvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EInvoiceItem findUnique
   */
  export type EInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceItem to fetch.
     */
    where: EInvoiceItemWhereUniqueInput
  }

  /**
   * EInvoiceItem findUniqueOrThrow
   */
  export type EInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceItem to fetch.
     */
    where: EInvoiceItemWhereUniqueInput
  }

  /**
   * EInvoiceItem findFirst
   */
  export type EInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceItem to fetch.
     */
    where?: EInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoiceItems to fetch.
     */
    orderBy?: EInvoiceItemOrderByWithRelationInput | EInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EInvoiceItems.
     */
    cursor?: EInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EInvoiceItems.
     */
    distinct?: EInvoiceItemScalarFieldEnum | EInvoiceItemScalarFieldEnum[]
  }

  /**
   * EInvoiceItem findFirstOrThrow
   */
  export type EInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceItem to fetch.
     */
    where?: EInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoiceItems to fetch.
     */
    orderBy?: EInvoiceItemOrderByWithRelationInput | EInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EInvoiceItems.
     */
    cursor?: EInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EInvoiceItems.
     */
    distinct?: EInvoiceItemScalarFieldEnum | EInvoiceItemScalarFieldEnum[]
  }

  /**
   * EInvoiceItem findMany
   */
  export type EInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceItems to fetch.
     */
    where?: EInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoiceItems to fetch.
     */
    orderBy?: EInvoiceItemOrderByWithRelationInput | EInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EInvoiceItems.
     */
    cursor?: EInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoiceItems.
     */
    skip?: number
    distinct?: EInvoiceItemScalarFieldEnum | EInvoiceItemScalarFieldEnum[]
  }

  /**
   * EInvoiceItem create
   */
  export type EInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a EInvoiceItem.
     */
    data: XOR<EInvoiceItemCreateInput, EInvoiceItemUncheckedCreateInput>
  }

  /**
   * EInvoiceItem createMany
   */
  export type EInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EInvoiceItems.
     */
    data: EInvoiceItemCreateManyInput | EInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EInvoiceItem createManyAndReturn
   */
  export type EInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many EInvoiceItems.
     */
    data: EInvoiceItemCreateManyInput | EInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EInvoiceItem update
   */
  export type EInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a EInvoiceItem.
     */
    data: XOR<EInvoiceItemUpdateInput, EInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which EInvoiceItem to update.
     */
    where: EInvoiceItemWhereUniqueInput
  }

  /**
   * EInvoiceItem updateMany
   */
  export type EInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EInvoiceItems.
     */
    data: XOR<EInvoiceItemUpdateManyMutationInput, EInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which EInvoiceItems to update
     */
    where?: EInvoiceItemWhereInput
    /**
     * Limit how many EInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * EInvoiceItem updateManyAndReturn
   */
  export type EInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update EInvoiceItems.
     */
    data: XOR<EInvoiceItemUpdateManyMutationInput, EInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which EInvoiceItems to update
     */
    where?: EInvoiceItemWhereInput
    /**
     * Limit how many EInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EInvoiceItem upsert
   */
  export type EInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the EInvoiceItem to update in case it exists.
     */
    where: EInvoiceItemWhereUniqueInput
    /**
     * In case the EInvoiceItem found by the `where` argument doesn't exist, create a new EInvoiceItem with this data.
     */
    create: XOR<EInvoiceItemCreateInput, EInvoiceItemUncheckedCreateInput>
    /**
     * In case the EInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EInvoiceItemUpdateInput, EInvoiceItemUncheckedUpdateInput>
  }

  /**
   * EInvoiceItem delete
   */
  export type EInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which EInvoiceItem to delete.
     */
    where: EInvoiceItemWhereUniqueInput
  }

  /**
   * EInvoiceItem deleteMany
   */
  export type EInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EInvoiceItems to delete
     */
    where?: EInvoiceItemWhereInput
    /**
     * Limit how many EInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * EInvoiceItem.invoiceItem
   */
  export type EInvoiceItem$invoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
  }

  /**
   * EInvoiceItem without action
   */
  export type EInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceItem
     */
    select?: EInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceItem
     */
    omit?: EInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model EInvoiceLog
   */

  export type AggregateEInvoiceLog = {
    _count: EInvoiceLogCountAggregateOutputType | null
    _min: EInvoiceLogMinAggregateOutputType | null
    _max: EInvoiceLogMaxAggregateOutputType | null
  }

  export type EInvoiceLogMinAggregateOutputType = {
    id: string | null
    eInvoiceId: string | null
    action: string | null
    status: $Enums.EInvoiceStatus | null
    message: string | null
    errorCode: string | null
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type EInvoiceLogMaxAggregateOutputType = {
    id: string | null
    eInvoiceId: string | null
    action: string | null
    status: $Enums.EInvoiceStatus | null
    message: string | null
    errorCode: string | null
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type EInvoiceLogCountAggregateOutputType = {
    id: number
    eInvoiceId: number
    action: number
    status: number
    message: number
    requestData: number
    responseData: number
    errorCode: number
    errorMessage: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type EInvoiceLogMinAggregateInputType = {
    id?: true
    eInvoiceId?: true
    action?: true
    status?: true
    message?: true
    errorCode?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type EInvoiceLogMaxAggregateInputType = {
    id?: true
    eInvoiceId?: true
    action?: true
    status?: true
    message?: true
    errorCode?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type EInvoiceLogCountAggregateInputType = {
    id?: true
    eInvoiceId?: true
    action?: true
    status?: true
    message?: true
    requestData?: true
    responseData?: true
    errorCode?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type EInvoiceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EInvoiceLog to aggregate.
     */
    where?: EInvoiceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoiceLogs to fetch.
     */
    orderBy?: EInvoiceLogOrderByWithRelationInput | EInvoiceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EInvoiceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoiceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoiceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EInvoiceLogs
    **/
    _count?: true | EInvoiceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EInvoiceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EInvoiceLogMaxAggregateInputType
  }

  export type GetEInvoiceLogAggregateType<T extends EInvoiceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEInvoiceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEInvoiceLog[P]>
      : GetScalarType<T[P], AggregateEInvoiceLog[P]>
  }




  export type EInvoiceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EInvoiceLogWhereInput
    orderBy?: EInvoiceLogOrderByWithAggregationInput | EInvoiceLogOrderByWithAggregationInput[]
    by: EInvoiceLogScalarFieldEnum[] | EInvoiceLogScalarFieldEnum
    having?: EInvoiceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EInvoiceLogCountAggregateInputType | true
    _min?: EInvoiceLogMinAggregateInputType
    _max?: EInvoiceLogMaxAggregateInputType
  }

  export type EInvoiceLogGroupByOutputType = {
    id: string
    eInvoiceId: string
    action: string
    status: $Enums.EInvoiceStatus
    message: string | null
    requestData: JsonValue | null
    responseData: JsonValue | null
    errorCode: string | null
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: EInvoiceLogCountAggregateOutputType | null
    _min: EInvoiceLogMinAggregateOutputType | null
    _max: EInvoiceLogMaxAggregateOutputType | null
  }

  type GetEInvoiceLogGroupByPayload<T extends EInvoiceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EInvoiceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EInvoiceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EInvoiceLogGroupByOutputType[P]>
            : GetScalarType<T[P], EInvoiceLogGroupByOutputType[P]>
        }
      >
    >


  export type EInvoiceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eInvoiceId?: boolean
    action?: boolean
    status?: boolean
    message?: boolean
    requestData?: boolean
    responseData?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoiceLog"]>

  export type EInvoiceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eInvoiceId?: boolean
    action?: boolean
    status?: boolean
    message?: boolean
    requestData?: boolean
    responseData?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoiceLog"]>

  export type EInvoiceLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eInvoiceId?: boolean
    action?: boolean
    status?: boolean
    message?: boolean
    requestData?: boolean
    responseData?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eInvoiceLog"]>

  export type EInvoiceLogSelectScalar = {
    id?: boolean
    eInvoiceId?: boolean
    action?: boolean
    status?: boolean
    message?: boolean
    requestData?: boolean
    responseData?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type EInvoiceLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eInvoiceId" | "action" | "status" | "message" | "requestData" | "responseData" | "errorCode" | "errorMessage" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["eInvoiceLog"]>
  export type EInvoiceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
  }
  export type EInvoiceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
  }
  export type EInvoiceLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eInvoice?: boolean | EInvoiceDefaultArgs<ExtArgs>
  }

  export type $EInvoiceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EInvoiceLog"
    objects: {
      eInvoice: Prisma.$EInvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eInvoiceId: string
      action: string
      status: $Enums.EInvoiceStatus
      message: string | null
      requestData: Prisma.JsonValue | null
      responseData: Prisma.JsonValue | null
      errorCode: string | null
      errorMessage: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["eInvoiceLog"]>
    composites: {}
  }

  type EInvoiceLogGetPayload<S extends boolean | null | undefined | EInvoiceLogDefaultArgs> = $Result.GetResult<Prisma.$EInvoiceLogPayload, S>

  type EInvoiceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EInvoiceLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EInvoiceLogCountAggregateInputType | true
    }

  export interface EInvoiceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EInvoiceLog'], meta: { name: 'EInvoiceLog' } }
    /**
     * Find zero or one EInvoiceLog that matches the filter.
     * @param {EInvoiceLogFindUniqueArgs} args - Arguments to find a EInvoiceLog
     * @example
     * // Get one EInvoiceLog
     * const eInvoiceLog = await prisma.eInvoiceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EInvoiceLogFindUniqueArgs>(args: SelectSubset<T, EInvoiceLogFindUniqueArgs<ExtArgs>>): Prisma__EInvoiceLogClient<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EInvoiceLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EInvoiceLogFindUniqueOrThrowArgs} args - Arguments to find a EInvoiceLog
     * @example
     * // Get one EInvoiceLog
     * const eInvoiceLog = await prisma.eInvoiceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EInvoiceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EInvoiceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EInvoiceLogClient<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EInvoiceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceLogFindFirstArgs} args - Arguments to find a EInvoiceLog
     * @example
     * // Get one EInvoiceLog
     * const eInvoiceLog = await prisma.eInvoiceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EInvoiceLogFindFirstArgs>(args?: SelectSubset<T, EInvoiceLogFindFirstArgs<ExtArgs>>): Prisma__EInvoiceLogClient<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EInvoiceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceLogFindFirstOrThrowArgs} args - Arguments to find a EInvoiceLog
     * @example
     * // Get one EInvoiceLog
     * const eInvoiceLog = await prisma.eInvoiceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EInvoiceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EInvoiceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EInvoiceLogClient<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EInvoiceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EInvoiceLogs
     * const eInvoiceLogs = await prisma.eInvoiceLog.findMany()
     * 
     * // Get first 10 EInvoiceLogs
     * const eInvoiceLogs = await prisma.eInvoiceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eInvoiceLogWithIdOnly = await prisma.eInvoiceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EInvoiceLogFindManyArgs>(args?: SelectSubset<T, EInvoiceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EInvoiceLog.
     * @param {EInvoiceLogCreateArgs} args - Arguments to create a EInvoiceLog.
     * @example
     * // Create one EInvoiceLog
     * const EInvoiceLog = await prisma.eInvoiceLog.create({
     *   data: {
     *     // ... data to create a EInvoiceLog
     *   }
     * })
     * 
     */
    create<T extends EInvoiceLogCreateArgs>(args: SelectSubset<T, EInvoiceLogCreateArgs<ExtArgs>>): Prisma__EInvoiceLogClient<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EInvoiceLogs.
     * @param {EInvoiceLogCreateManyArgs} args - Arguments to create many EInvoiceLogs.
     * @example
     * // Create many EInvoiceLogs
     * const eInvoiceLog = await prisma.eInvoiceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EInvoiceLogCreateManyArgs>(args?: SelectSubset<T, EInvoiceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EInvoiceLogs and returns the data saved in the database.
     * @param {EInvoiceLogCreateManyAndReturnArgs} args - Arguments to create many EInvoiceLogs.
     * @example
     * // Create many EInvoiceLogs
     * const eInvoiceLog = await prisma.eInvoiceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EInvoiceLogs and only return the `id`
     * const eInvoiceLogWithIdOnly = await prisma.eInvoiceLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EInvoiceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EInvoiceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EInvoiceLog.
     * @param {EInvoiceLogDeleteArgs} args - Arguments to delete one EInvoiceLog.
     * @example
     * // Delete one EInvoiceLog
     * const EInvoiceLog = await prisma.eInvoiceLog.delete({
     *   where: {
     *     // ... filter to delete one EInvoiceLog
     *   }
     * })
     * 
     */
    delete<T extends EInvoiceLogDeleteArgs>(args: SelectSubset<T, EInvoiceLogDeleteArgs<ExtArgs>>): Prisma__EInvoiceLogClient<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EInvoiceLog.
     * @param {EInvoiceLogUpdateArgs} args - Arguments to update one EInvoiceLog.
     * @example
     * // Update one EInvoiceLog
     * const eInvoiceLog = await prisma.eInvoiceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EInvoiceLogUpdateArgs>(args: SelectSubset<T, EInvoiceLogUpdateArgs<ExtArgs>>): Prisma__EInvoiceLogClient<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EInvoiceLogs.
     * @param {EInvoiceLogDeleteManyArgs} args - Arguments to filter EInvoiceLogs to delete.
     * @example
     * // Delete a few EInvoiceLogs
     * const { count } = await prisma.eInvoiceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EInvoiceLogDeleteManyArgs>(args?: SelectSubset<T, EInvoiceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EInvoiceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EInvoiceLogs
     * const eInvoiceLog = await prisma.eInvoiceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EInvoiceLogUpdateManyArgs>(args: SelectSubset<T, EInvoiceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EInvoiceLogs and returns the data updated in the database.
     * @param {EInvoiceLogUpdateManyAndReturnArgs} args - Arguments to update many EInvoiceLogs.
     * @example
     * // Update many EInvoiceLogs
     * const eInvoiceLog = await prisma.eInvoiceLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EInvoiceLogs and only return the `id`
     * const eInvoiceLogWithIdOnly = await prisma.eInvoiceLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EInvoiceLogUpdateManyAndReturnArgs>(args: SelectSubset<T, EInvoiceLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EInvoiceLog.
     * @param {EInvoiceLogUpsertArgs} args - Arguments to update or create a EInvoiceLog.
     * @example
     * // Update or create a EInvoiceLog
     * const eInvoiceLog = await prisma.eInvoiceLog.upsert({
     *   create: {
     *     // ... data to create a EInvoiceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EInvoiceLog we want to update
     *   }
     * })
     */
    upsert<T extends EInvoiceLogUpsertArgs>(args: SelectSubset<T, EInvoiceLogUpsertArgs<ExtArgs>>): Prisma__EInvoiceLogClient<$Result.GetResult<Prisma.$EInvoiceLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EInvoiceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceLogCountArgs} args - Arguments to filter EInvoiceLogs to count.
     * @example
     * // Count the number of EInvoiceLogs
     * const count = await prisma.eInvoiceLog.count({
     *   where: {
     *     // ... the filter for the EInvoiceLogs we want to count
     *   }
     * })
    **/
    count<T extends EInvoiceLogCountArgs>(
      args?: Subset<T, EInvoiceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EInvoiceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EInvoiceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EInvoiceLogAggregateArgs>(args: Subset<T, EInvoiceLogAggregateArgs>): Prisma.PrismaPromise<GetEInvoiceLogAggregateType<T>>

    /**
     * Group by EInvoiceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EInvoiceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EInvoiceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EInvoiceLogGroupByArgs['orderBy'] }
        : { orderBy?: EInvoiceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EInvoiceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEInvoiceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EInvoiceLog model
   */
  readonly fields: EInvoiceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EInvoiceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EInvoiceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eInvoice<T extends EInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EInvoiceDefaultArgs<ExtArgs>>): Prisma__EInvoiceClient<$Result.GetResult<Prisma.$EInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EInvoiceLog model
   */
  interface EInvoiceLogFieldRefs {
    readonly id: FieldRef<"EInvoiceLog", 'String'>
    readonly eInvoiceId: FieldRef<"EInvoiceLog", 'String'>
    readonly action: FieldRef<"EInvoiceLog", 'String'>
    readonly status: FieldRef<"EInvoiceLog", 'EInvoiceStatus'>
    readonly message: FieldRef<"EInvoiceLog", 'String'>
    readonly requestData: FieldRef<"EInvoiceLog", 'Json'>
    readonly responseData: FieldRef<"EInvoiceLog", 'Json'>
    readonly errorCode: FieldRef<"EInvoiceLog", 'String'>
    readonly errorMessage: FieldRef<"EInvoiceLog", 'String'>
    readonly ipAddress: FieldRef<"EInvoiceLog", 'String'>
    readonly userAgent: FieldRef<"EInvoiceLog", 'String'>
    readonly createdAt: FieldRef<"EInvoiceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EInvoiceLog findUnique
   */
  export type EInvoiceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceLog to fetch.
     */
    where: EInvoiceLogWhereUniqueInput
  }

  /**
   * EInvoiceLog findUniqueOrThrow
   */
  export type EInvoiceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceLog to fetch.
     */
    where: EInvoiceLogWhereUniqueInput
  }

  /**
   * EInvoiceLog findFirst
   */
  export type EInvoiceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceLog to fetch.
     */
    where?: EInvoiceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoiceLogs to fetch.
     */
    orderBy?: EInvoiceLogOrderByWithRelationInput | EInvoiceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EInvoiceLogs.
     */
    cursor?: EInvoiceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoiceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoiceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EInvoiceLogs.
     */
    distinct?: EInvoiceLogScalarFieldEnum | EInvoiceLogScalarFieldEnum[]
  }

  /**
   * EInvoiceLog findFirstOrThrow
   */
  export type EInvoiceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceLog to fetch.
     */
    where?: EInvoiceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoiceLogs to fetch.
     */
    orderBy?: EInvoiceLogOrderByWithRelationInput | EInvoiceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EInvoiceLogs.
     */
    cursor?: EInvoiceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoiceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoiceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EInvoiceLogs.
     */
    distinct?: EInvoiceLogScalarFieldEnum | EInvoiceLogScalarFieldEnum[]
  }

  /**
   * EInvoiceLog findMany
   */
  export type EInvoiceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * Filter, which EInvoiceLogs to fetch.
     */
    where?: EInvoiceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EInvoiceLogs to fetch.
     */
    orderBy?: EInvoiceLogOrderByWithRelationInput | EInvoiceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EInvoiceLogs.
     */
    cursor?: EInvoiceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EInvoiceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EInvoiceLogs.
     */
    skip?: number
    distinct?: EInvoiceLogScalarFieldEnum | EInvoiceLogScalarFieldEnum[]
  }

  /**
   * EInvoiceLog create
   */
  export type EInvoiceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EInvoiceLog.
     */
    data: XOR<EInvoiceLogCreateInput, EInvoiceLogUncheckedCreateInput>
  }

  /**
   * EInvoiceLog createMany
   */
  export type EInvoiceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EInvoiceLogs.
     */
    data: EInvoiceLogCreateManyInput | EInvoiceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EInvoiceLog createManyAndReturn
   */
  export type EInvoiceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * The data used to create many EInvoiceLogs.
     */
    data: EInvoiceLogCreateManyInput | EInvoiceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EInvoiceLog update
   */
  export type EInvoiceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EInvoiceLog.
     */
    data: XOR<EInvoiceLogUpdateInput, EInvoiceLogUncheckedUpdateInput>
    /**
     * Choose, which EInvoiceLog to update.
     */
    where: EInvoiceLogWhereUniqueInput
  }

  /**
   * EInvoiceLog updateMany
   */
  export type EInvoiceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EInvoiceLogs.
     */
    data: XOR<EInvoiceLogUpdateManyMutationInput, EInvoiceLogUncheckedUpdateManyInput>
    /**
     * Filter which EInvoiceLogs to update
     */
    where?: EInvoiceLogWhereInput
    /**
     * Limit how many EInvoiceLogs to update.
     */
    limit?: number
  }

  /**
   * EInvoiceLog updateManyAndReturn
   */
  export type EInvoiceLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * The data used to update EInvoiceLogs.
     */
    data: XOR<EInvoiceLogUpdateManyMutationInput, EInvoiceLogUncheckedUpdateManyInput>
    /**
     * Filter which EInvoiceLogs to update
     */
    where?: EInvoiceLogWhereInput
    /**
     * Limit how many EInvoiceLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EInvoiceLog upsert
   */
  export type EInvoiceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EInvoiceLog to update in case it exists.
     */
    where: EInvoiceLogWhereUniqueInput
    /**
     * In case the EInvoiceLog found by the `where` argument doesn't exist, create a new EInvoiceLog with this data.
     */
    create: XOR<EInvoiceLogCreateInput, EInvoiceLogUncheckedCreateInput>
    /**
     * In case the EInvoiceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EInvoiceLogUpdateInput, EInvoiceLogUncheckedUpdateInput>
  }

  /**
   * EInvoiceLog delete
   */
  export type EInvoiceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
    /**
     * Filter which EInvoiceLog to delete.
     */
    where: EInvoiceLogWhereUniqueInput
  }

  /**
   * EInvoiceLog deleteMany
   */
  export type EInvoiceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EInvoiceLogs to delete
     */
    where?: EInvoiceLogWhereInput
    /**
     * Limit how many EInvoiceLogs to delete.
     */
    limit?: number
  }

  /**
   * EInvoiceLog without action
   */
  export type EInvoiceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EInvoiceLog
     */
    select?: EInvoiceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EInvoiceLog
     */
    omit?: EInvoiceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EInvoiceLogInclude<ExtArgs> | null
  }


  /**
   * Model LhdnToken
   */

  export type AggregateLhdnToken = {
    _count: LhdnTokenCountAggregateOutputType | null
    _min: LhdnTokenMinAggregateOutputType | null
    _max: LhdnTokenMaxAggregateOutputType | null
  }

  export type LhdnTokenMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accessToken: string | null
    tokenType: string | null
    expiresAt: Date | null
    scope: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LhdnTokenMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    accessToken: string | null
    tokenType: string | null
    expiresAt: Date | null
    scope: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LhdnTokenCountAggregateOutputType = {
    id: number
    tenantId: number
    accessToken: number
    tokenType: number
    expiresAt: number
    scope: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LhdnTokenMinAggregateInputType = {
    id?: true
    tenantId?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LhdnTokenMaxAggregateInputType = {
    id?: true
    tenantId?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LhdnTokenCountAggregateInputType = {
    id?: true
    tenantId?: true
    accessToken?: true
    tokenType?: true
    expiresAt?: true
    scope?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LhdnTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LhdnToken to aggregate.
     */
    where?: LhdnTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LhdnTokens to fetch.
     */
    orderBy?: LhdnTokenOrderByWithRelationInput | LhdnTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LhdnTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LhdnTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LhdnTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LhdnTokens
    **/
    _count?: true | LhdnTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LhdnTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LhdnTokenMaxAggregateInputType
  }

  export type GetLhdnTokenAggregateType<T extends LhdnTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateLhdnToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLhdnToken[P]>
      : GetScalarType<T[P], AggregateLhdnToken[P]>
  }




  export type LhdnTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LhdnTokenWhereInput
    orderBy?: LhdnTokenOrderByWithAggregationInput | LhdnTokenOrderByWithAggregationInput[]
    by: LhdnTokenScalarFieldEnum[] | LhdnTokenScalarFieldEnum
    having?: LhdnTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LhdnTokenCountAggregateInputType | true
    _min?: LhdnTokenMinAggregateInputType
    _max?: LhdnTokenMaxAggregateInputType
  }

  export type LhdnTokenGroupByOutputType = {
    id: string
    tenantId: string
    accessToken: string
    tokenType: string
    expiresAt: Date
    scope: string | null
    createdAt: Date
    updatedAt: Date
    _count: LhdnTokenCountAggregateOutputType | null
    _min: LhdnTokenMinAggregateOutputType | null
    _max: LhdnTokenMaxAggregateOutputType | null
  }

  type GetLhdnTokenGroupByPayload<T extends LhdnTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LhdnTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LhdnTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LhdnTokenGroupByOutputType[P]>
            : GetScalarType<T[P], LhdnTokenGroupByOutputType[P]>
        }
      >
    >


  export type LhdnTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accessToken?: boolean
    tokenType?: boolean
    expiresAt?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lhdnToken"]>

  export type LhdnTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accessToken?: boolean
    tokenType?: boolean
    expiresAt?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lhdnToken"]>

  export type LhdnTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    accessToken?: boolean
    tokenType?: boolean
    expiresAt?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lhdnToken"]>

  export type LhdnTokenSelectScalar = {
    id?: boolean
    tenantId?: boolean
    accessToken?: boolean
    tokenType?: boolean
    expiresAt?: boolean
    scope?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LhdnTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "accessToken" | "tokenType" | "expiresAt" | "scope" | "createdAt" | "updatedAt", ExtArgs["result"]["lhdnToken"]>
  export type LhdnTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LhdnTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LhdnTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $LhdnTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LhdnToken"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      accessToken: string
      tokenType: string
      expiresAt: Date
      scope: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lhdnToken"]>
    composites: {}
  }

  type LhdnTokenGetPayload<S extends boolean | null | undefined | LhdnTokenDefaultArgs> = $Result.GetResult<Prisma.$LhdnTokenPayload, S>

  type LhdnTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LhdnTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LhdnTokenCountAggregateInputType | true
    }

  export interface LhdnTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LhdnToken'], meta: { name: 'LhdnToken' } }
    /**
     * Find zero or one LhdnToken that matches the filter.
     * @param {LhdnTokenFindUniqueArgs} args - Arguments to find a LhdnToken
     * @example
     * // Get one LhdnToken
     * const lhdnToken = await prisma.lhdnToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LhdnTokenFindUniqueArgs>(args: SelectSubset<T, LhdnTokenFindUniqueArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LhdnToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LhdnTokenFindUniqueOrThrowArgs} args - Arguments to find a LhdnToken
     * @example
     * // Get one LhdnToken
     * const lhdnToken = await prisma.lhdnToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LhdnTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, LhdnTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LhdnToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnTokenFindFirstArgs} args - Arguments to find a LhdnToken
     * @example
     * // Get one LhdnToken
     * const lhdnToken = await prisma.lhdnToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LhdnTokenFindFirstArgs>(args?: SelectSubset<T, LhdnTokenFindFirstArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LhdnToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnTokenFindFirstOrThrowArgs} args - Arguments to find a LhdnToken
     * @example
     * // Get one LhdnToken
     * const lhdnToken = await prisma.lhdnToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LhdnTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, LhdnTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LhdnTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LhdnTokens
     * const lhdnTokens = await prisma.lhdnToken.findMany()
     * 
     * // Get first 10 LhdnTokens
     * const lhdnTokens = await prisma.lhdnToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lhdnTokenWithIdOnly = await prisma.lhdnToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LhdnTokenFindManyArgs>(args?: SelectSubset<T, LhdnTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LhdnToken.
     * @param {LhdnTokenCreateArgs} args - Arguments to create a LhdnToken.
     * @example
     * // Create one LhdnToken
     * const LhdnToken = await prisma.lhdnToken.create({
     *   data: {
     *     // ... data to create a LhdnToken
     *   }
     * })
     * 
     */
    create<T extends LhdnTokenCreateArgs>(args: SelectSubset<T, LhdnTokenCreateArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LhdnTokens.
     * @param {LhdnTokenCreateManyArgs} args - Arguments to create many LhdnTokens.
     * @example
     * // Create many LhdnTokens
     * const lhdnToken = await prisma.lhdnToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LhdnTokenCreateManyArgs>(args?: SelectSubset<T, LhdnTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LhdnTokens and returns the data saved in the database.
     * @param {LhdnTokenCreateManyAndReturnArgs} args - Arguments to create many LhdnTokens.
     * @example
     * // Create many LhdnTokens
     * const lhdnToken = await prisma.lhdnToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LhdnTokens and only return the `id`
     * const lhdnTokenWithIdOnly = await prisma.lhdnToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LhdnTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, LhdnTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LhdnToken.
     * @param {LhdnTokenDeleteArgs} args - Arguments to delete one LhdnToken.
     * @example
     * // Delete one LhdnToken
     * const LhdnToken = await prisma.lhdnToken.delete({
     *   where: {
     *     // ... filter to delete one LhdnToken
     *   }
     * })
     * 
     */
    delete<T extends LhdnTokenDeleteArgs>(args: SelectSubset<T, LhdnTokenDeleteArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LhdnToken.
     * @param {LhdnTokenUpdateArgs} args - Arguments to update one LhdnToken.
     * @example
     * // Update one LhdnToken
     * const lhdnToken = await prisma.lhdnToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LhdnTokenUpdateArgs>(args: SelectSubset<T, LhdnTokenUpdateArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LhdnTokens.
     * @param {LhdnTokenDeleteManyArgs} args - Arguments to filter LhdnTokens to delete.
     * @example
     * // Delete a few LhdnTokens
     * const { count } = await prisma.lhdnToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LhdnTokenDeleteManyArgs>(args?: SelectSubset<T, LhdnTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LhdnTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LhdnTokens
     * const lhdnToken = await prisma.lhdnToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LhdnTokenUpdateManyArgs>(args: SelectSubset<T, LhdnTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LhdnTokens and returns the data updated in the database.
     * @param {LhdnTokenUpdateManyAndReturnArgs} args - Arguments to update many LhdnTokens.
     * @example
     * // Update many LhdnTokens
     * const lhdnToken = await prisma.lhdnToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LhdnTokens and only return the `id`
     * const lhdnTokenWithIdOnly = await prisma.lhdnToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LhdnTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, LhdnTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LhdnToken.
     * @param {LhdnTokenUpsertArgs} args - Arguments to update or create a LhdnToken.
     * @example
     * // Update or create a LhdnToken
     * const lhdnToken = await prisma.lhdnToken.upsert({
     *   create: {
     *     // ... data to create a LhdnToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LhdnToken we want to update
     *   }
     * })
     */
    upsert<T extends LhdnTokenUpsertArgs>(args: SelectSubset<T, LhdnTokenUpsertArgs<ExtArgs>>): Prisma__LhdnTokenClient<$Result.GetResult<Prisma.$LhdnTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LhdnTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnTokenCountArgs} args - Arguments to filter LhdnTokens to count.
     * @example
     * // Count the number of LhdnTokens
     * const count = await prisma.lhdnToken.count({
     *   where: {
     *     // ... the filter for the LhdnTokens we want to count
     *   }
     * })
    **/
    count<T extends LhdnTokenCountArgs>(
      args?: Subset<T, LhdnTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LhdnTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LhdnToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LhdnTokenAggregateArgs>(args: Subset<T, LhdnTokenAggregateArgs>): Prisma.PrismaPromise<GetLhdnTokenAggregateType<T>>

    /**
     * Group by LhdnToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LhdnTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LhdnTokenGroupByArgs['orderBy'] }
        : { orderBy?: LhdnTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LhdnTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLhdnTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LhdnToken model
   */
  readonly fields: LhdnTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LhdnToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LhdnTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LhdnToken model
   */
  interface LhdnTokenFieldRefs {
    readonly id: FieldRef<"LhdnToken", 'String'>
    readonly tenantId: FieldRef<"LhdnToken", 'String'>
    readonly accessToken: FieldRef<"LhdnToken", 'String'>
    readonly tokenType: FieldRef<"LhdnToken", 'String'>
    readonly expiresAt: FieldRef<"LhdnToken", 'DateTime'>
    readonly scope: FieldRef<"LhdnToken", 'String'>
    readonly createdAt: FieldRef<"LhdnToken", 'DateTime'>
    readonly updatedAt: FieldRef<"LhdnToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LhdnToken findUnique
   */
  export type LhdnTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * Filter, which LhdnToken to fetch.
     */
    where: LhdnTokenWhereUniqueInput
  }

  /**
   * LhdnToken findUniqueOrThrow
   */
  export type LhdnTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * Filter, which LhdnToken to fetch.
     */
    where: LhdnTokenWhereUniqueInput
  }

  /**
   * LhdnToken findFirst
   */
  export type LhdnTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * Filter, which LhdnToken to fetch.
     */
    where?: LhdnTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LhdnTokens to fetch.
     */
    orderBy?: LhdnTokenOrderByWithRelationInput | LhdnTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LhdnTokens.
     */
    cursor?: LhdnTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LhdnTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LhdnTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LhdnTokens.
     */
    distinct?: LhdnTokenScalarFieldEnum | LhdnTokenScalarFieldEnum[]
  }

  /**
   * LhdnToken findFirstOrThrow
   */
  export type LhdnTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * Filter, which LhdnToken to fetch.
     */
    where?: LhdnTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LhdnTokens to fetch.
     */
    orderBy?: LhdnTokenOrderByWithRelationInput | LhdnTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LhdnTokens.
     */
    cursor?: LhdnTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LhdnTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LhdnTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LhdnTokens.
     */
    distinct?: LhdnTokenScalarFieldEnum | LhdnTokenScalarFieldEnum[]
  }

  /**
   * LhdnToken findMany
   */
  export type LhdnTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * Filter, which LhdnTokens to fetch.
     */
    where?: LhdnTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LhdnTokens to fetch.
     */
    orderBy?: LhdnTokenOrderByWithRelationInput | LhdnTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LhdnTokens.
     */
    cursor?: LhdnTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LhdnTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LhdnTokens.
     */
    skip?: number
    distinct?: LhdnTokenScalarFieldEnum | LhdnTokenScalarFieldEnum[]
  }

  /**
   * LhdnToken create
   */
  export type LhdnTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a LhdnToken.
     */
    data: XOR<LhdnTokenCreateInput, LhdnTokenUncheckedCreateInput>
  }

  /**
   * LhdnToken createMany
   */
  export type LhdnTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LhdnTokens.
     */
    data: LhdnTokenCreateManyInput | LhdnTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LhdnToken createManyAndReturn
   */
  export type LhdnTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * The data used to create many LhdnTokens.
     */
    data: LhdnTokenCreateManyInput | LhdnTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LhdnToken update
   */
  export type LhdnTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a LhdnToken.
     */
    data: XOR<LhdnTokenUpdateInput, LhdnTokenUncheckedUpdateInput>
    /**
     * Choose, which LhdnToken to update.
     */
    where: LhdnTokenWhereUniqueInput
  }

  /**
   * LhdnToken updateMany
   */
  export type LhdnTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LhdnTokens.
     */
    data: XOR<LhdnTokenUpdateManyMutationInput, LhdnTokenUncheckedUpdateManyInput>
    /**
     * Filter which LhdnTokens to update
     */
    where?: LhdnTokenWhereInput
    /**
     * Limit how many LhdnTokens to update.
     */
    limit?: number
  }

  /**
   * LhdnToken updateManyAndReturn
   */
  export type LhdnTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * The data used to update LhdnTokens.
     */
    data: XOR<LhdnTokenUpdateManyMutationInput, LhdnTokenUncheckedUpdateManyInput>
    /**
     * Filter which LhdnTokens to update
     */
    where?: LhdnTokenWhereInput
    /**
     * Limit how many LhdnTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LhdnToken upsert
   */
  export type LhdnTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the LhdnToken to update in case it exists.
     */
    where: LhdnTokenWhereUniqueInput
    /**
     * In case the LhdnToken found by the `where` argument doesn't exist, create a new LhdnToken with this data.
     */
    create: XOR<LhdnTokenCreateInput, LhdnTokenUncheckedCreateInput>
    /**
     * In case the LhdnToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LhdnTokenUpdateInput, LhdnTokenUncheckedUpdateInput>
  }

  /**
   * LhdnToken delete
   */
  export type LhdnTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
    /**
     * Filter which LhdnToken to delete.
     */
    where: LhdnTokenWhereUniqueInput
  }

  /**
   * LhdnToken deleteMany
   */
  export type LhdnTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LhdnTokens to delete
     */
    where?: LhdnTokenWhereInput
    /**
     * Limit how many LhdnTokens to delete.
     */
    limit?: number
  }

  /**
   * LhdnToken without action
   */
  export type LhdnTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnToken
     */
    select?: LhdnTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnToken
     */
    omit?: LhdnTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnTokenInclude<ExtArgs> | null
  }


  /**
   * Model LhdnCredential
   */

  export type AggregateLhdnCredential = {
    _count: LhdnCredentialCountAggregateOutputType | null
    _min: LhdnCredentialMinAggregateOutputType | null
    _max: LhdnCredentialMaxAggregateOutputType | null
  }

  export type LhdnCredentialMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    clientId: string | null
    clientSecretEncrypted: string | null
    tin: string | null
    brn: string | null
    idType: string | null
    idValue: string | null
    environment: $Enums.LhdnEnvironment | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LhdnCredentialMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    clientId: string | null
    clientSecretEncrypted: string | null
    tin: string | null
    brn: string | null
    idType: string | null
    idValue: string | null
    environment: $Enums.LhdnEnvironment | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LhdnCredentialCountAggregateOutputType = {
    id: number
    tenantId: number
    clientId: number
    clientSecretEncrypted: number
    tin: number
    brn: number
    idType: number
    idValue: number
    environment: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LhdnCredentialMinAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    clientSecretEncrypted?: true
    tin?: true
    brn?: true
    idType?: true
    idValue?: true
    environment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LhdnCredentialMaxAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    clientSecretEncrypted?: true
    tin?: true
    brn?: true
    idType?: true
    idValue?: true
    environment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LhdnCredentialCountAggregateInputType = {
    id?: true
    tenantId?: true
    clientId?: true
    clientSecretEncrypted?: true
    tin?: true
    brn?: true
    idType?: true
    idValue?: true
    environment?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LhdnCredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LhdnCredential to aggregate.
     */
    where?: LhdnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LhdnCredentials to fetch.
     */
    orderBy?: LhdnCredentialOrderByWithRelationInput | LhdnCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LhdnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LhdnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LhdnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LhdnCredentials
    **/
    _count?: true | LhdnCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LhdnCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LhdnCredentialMaxAggregateInputType
  }

  export type GetLhdnCredentialAggregateType<T extends LhdnCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateLhdnCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLhdnCredential[P]>
      : GetScalarType<T[P], AggregateLhdnCredential[P]>
  }




  export type LhdnCredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LhdnCredentialWhereInput
    orderBy?: LhdnCredentialOrderByWithAggregationInput | LhdnCredentialOrderByWithAggregationInput[]
    by: LhdnCredentialScalarFieldEnum[] | LhdnCredentialScalarFieldEnum
    having?: LhdnCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LhdnCredentialCountAggregateInputType | true
    _min?: LhdnCredentialMinAggregateInputType
    _max?: LhdnCredentialMaxAggregateInputType
  }

  export type LhdnCredentialGroupByOutputType = {
    id: string
    tenantId: string
    clientId: string
    clientSecretEncrypted: string
    tin: string
    brn: string | null
    idType: string
    idValue: string
    environment: $Enums.LhdnEnvironment
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LhdnCredentialCountAggregateOutputType | null
    _min: LhdnCredentialMinAggregateOutputType | null
    _max: LhdnCredentialMaxAggregateOutputType | null
  }

  type GetLhdnCredentialGroupByPayload<T extends LhdnCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LhdnCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LhdnCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LhdnCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], LhdnCredentialGroupByOutputType[P]>
        }
      >
    >


  export type LhdnCredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    clientSecretEncrypted?: boolean
    tin?: boolean
    brn?: boolean
    idType?: boolean
    idValue?: boolean
    environment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lhdnCredential"]>

  export type LhdnCredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    clientSecretEncrypted?: boolean
    tin?: boolean
    brn?: boolean
    idType?: boolean
    idValue?: boolean
    environment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lhdnCredential"]>

  export type LhdnCredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    clientSecretEncrypted?: boolean
    tin?: boolean
    brn?: boolean
    idType?: boolean
    idValue?: boolean
    environment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lhdnCredential"]>

  export type LhdnCredentialSelectScalar = {
    id?: boolean
    tenantId?: boolean
    clientId?: boolean
    clientSecretEncrypted?: boolean
    tin?: boolean
    brn?: boolean
    idType?: boolean
    idValue?: boolean
    environment?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LhdnCredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "clientId" | "clientSecretEncrypted" | "tin" | "brn" | "idType" | "idValue" | "environment" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["lhdnCredential"]>
  export type LhdnCredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LhdnCredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LhdnCredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $LhdnCredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LhdnCredential"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      clientId: string
      clientSecretEncrypted: string
      tin: string
      brn: string | null
      idType: string
      idValue: string
      environment: $Enums.LhdnEnvironment
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lhdnCredential"]>
    composites: {}
  }

  type LhdnCredentialGetPayload<S extends boolean | null | undefined | LhdnCredentialDefaultArgs> = $Result.GetResult<Prisma.$LhdnCredentialPayload, S>

  type LhdnCredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LhdnCredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LhdnCredentialCountAggregateInputType | true
    }

  export interface LhdnCredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LhdnCredential'], meta: { name: 'LhdnCredential' } }
    /**
     * Find zero or one LhdnCredential that matches the filter.
     * @param {LhdnCredentialFindUniqueArgs} args - Arguments to find a LhdnCredential
     * @example
     * // Get one LhdnCredential
     * const lhdnCredential = await prisma.lhdnCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LhdnCredentialFindUniqueArgs>(args: SelectSubset<T, LhdnCredentialFindUniqueArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LhdnCredential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LhdnCredentialFindUniqueOrThrowArgs} args - Arguments to find a LhdnCredential
     * @example
     * // Get one LhdnCredential
     * const lhdnCredential = await prisma.lhdnCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LhdnCredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, LhdnCredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LhdnCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnCredentialFindFirstArgs} args - Arguments to find a LhdnCredential
     * @example
     * // Get one LhdnCredential
     * const lhdnCredential = await prisma.lhdnCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LhdnCredentialFindFirstArgs>(args?: SelectSubset<T, LhdnCredentialFindFirstArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LhdnCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnCredentialFindFirstOrThrowArgs} args - Arguments to find a LhdnCredential
     * @example
     * // Get one LhdnCredential
     * const lhdnCredential = await prisma.lhdnCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LhdnCredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, LhdnCredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LhdnCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LhdnCredentials
     * const lhdnCredentials = await prisma.lhdnCredential.findMany()
     * 
     * // Get first 10 LhdnCredentials
     * const lhdnCredentials = await prisma.lhdnCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lhdnCredentialWithIdOnly = await prisma.lhdnCredential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LhdnCredentialFindManyArgs>(args?: SelectSubset<T, LhdnCredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LhdnCredential.
     * @param {LhdnCredentialCreateArgs} args - Arguments to create a LhdnCredential.
     * @example
     * // Create one LhdnCredential
     * const LhdnCredential = await prisma.lhdnCredential.create({
     *   data: {
     *     // ... data to create a LhdnCredential
     *   }
     * })
     * 
     */
    create<T extends LhdnCredentialCreateArgs>(args: SelectSubset<T, LhdnCredentialCreateArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LhdnCredentials.
     * @param {LhdnCredentialCreateManyArgs} args - Arguments to create many LhdnCredentials.
     * @example
     * // Create many LhdnCredentials
     * const lhdnCredential = await prisma.lhdnCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LhdnCredentialCreateManyArgs>(args?: SelectSubset<T, LhdnCredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LhdnCredentials and returns the data saved in the database.
     * @param {LhdnCredentialCreateManyAndReturnArgs} args - Arguments to create many LhdnCredentials.
     * @example
     * // Create many LhdnCredentials
     * const lhdnCredential = await prisma.lhdnCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LhdnCredentials and only return the `id`
     * const lhdnCredentialWithIdOnly = await prisma.lhdnCredential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LhdnCredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, LhdnCredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LhdnCredential.
     * @param {LhdnCredentialDeleteArgs} args - Arguments to delete one LhdnCredential.
     * @example
     * // Delete one LhdnCredential
     * const LhdnCredential = await prisma.lhdnCredential.delete({
     *   where: {
     *     // ... filter to delete one LhdnCredential
     *   }
     * })
     * 
     */
    delete<T extends LhdnCredentialDeleteArgs>(args: SelectSubset<T, LhdnCredentialDeleteArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LhdnCredential.
     * @param {LhdnCredentialUpdateArgs} args - Arguments to update one LhdnCredential.
     * @example
     * // Update one LhdnCredential
     * const lhdnCredential = await prisma.lhdnCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LhdnCredentialUpdateArgs>(args: SelectSubset<T, LhdnCredentialUpdateArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LhdnCredentials.
     * @param {LhdnCredentialDeleteManyArgs} args - Arguments to filter LhdnCredentials to delete.
     * @example
     * // Delete a few LhdnCredentials
     * const { count } = await prisma.lhdnCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LhdnCredentialDeleteManyArgs>(args?: SelectSubset<T, LhdnCredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LhdnCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LhdnCredentials
     * const lhdnCredential = await prisma.lhdnCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LhdnCredentialUpdateManyArgs>(args: SelectSubset<T, LhdnCredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LhdnCredentials and returns the data updated in the database.
     * @param {LhdnCredentialUpdateManyAndReturnArgs} args - Arguments to update many LhdnCredentials.
     * @example
     * // Update many LhdnCredentials
     * const lhdnCredential = await prisma.lhdnCredential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LhdnCredentials and only return the `id`
     * const lhdnCredentialWithIdOnly = await prisma.lhdnCredential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LhdnCredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, LhdnCredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LhdnCredential.
     * @param {LhdnCredentialUpsertArgs} args - Arguments to update or create a LhdnCredential.
     * @example
     * // Update or create a LhdnCredential
     * const lhdnCredential = await prisma.lhdnCredential.upsert({
     *   create: {
     *     // ... data to create a LhdnCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LhdnCredential we want to update
     *   }
     * })
     */
    upsert<T extends LhdnCredentialUpsertArgs>(args: SelectSubset<T, LhdnCredentialUpsertArgs<ExtArgs>>): Prisma__LhdnCredentialClient<$Result.GetResult<Prisma.$LhdnCredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LhdnCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnCredentialCountArgs} args - Arguments to filter LhdnCredentials to count.
     * @example
     * // Count the number of LhdnCredentials
     * const count = await prisma.lhdnCredential.count({
     *   where: {
     *     // ... the filter for the LhdnCredentials we want to count
     *   }
     * })
    **/
    count<T extends LhdnCredentialCountArgs>(
      args?: Subset<T, LhdnCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LhdnCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LhdnCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LhdnCredentialAggregateArgs>(args: Subset<T, LhdnCredentialAggregateArgs>): Prisma.PrismaPromise<GetLhdnCredentialAggregateType<T>>

    /**
     * Group by LhdnCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LhdnCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LhdnCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LhdnCredentialGroupByArgs['orderBy'] }
        : { orderBy?: LhdnCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LhdnCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLhdnCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LhdnCredential model
   */
  readonly fields: LhdnCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LhdnCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LhdnCredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LhdnCredential model
   */
  interface LhdnCredentialFieldRefs {
    readonly id: FieldRef<"LhdnCredential", 'String'>
    readonly tenantId: FieldRef<"LhdnCredential", 'String'>
    readonly clientId: FieldRef<"LhdnCredential", 'String'>
    readonly clientSecretEncrypted: FieldRef<"LhdnCredential", 'String'>
    readonly tin: FieldRef<"LhdnCredential", 'String'>
    readonly brn: FieldRef<"LhdnCredential", 'String'>
    readonly idType: FieldRef<"LhdnCredential", 'String'>
    readonly idValue: FieldRef<"LhdnCredential", 'String'>
    readonly environment: FieldRef<"LhdnCredential", 'LhdnEnvironment'>
    readonly isActive: FieldRef<"LhdnCredential", 'Boolean'>
    readonly createdAt: FieldRef<"LhdnCredential", 'DateTime'>
    readonly updatedAt: FieldRef<"LhdnCredential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LhdnCredential findUnique
   */
  export type LhdnCredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LhdnCredential to fetch.
     */
    where: LhdnCredentialWhereUniqueInput
  }

  /**
   * LhdnCredential findUniqueOrThrow
   */
  export type LhdnCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LhdnCredential to fetch.
     */
    where: LhdnCredentialWhereUniqueInput
  }

  /**
   * LhdnCredential findFirst
   */
  export type LhdnCredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LhdnCredential to fetch.
     */
    where?: LhdnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LhdnCredentials to fetch.
     */
    orderBy?: LhdnCredentialOrderByWithRelationInput | LhdnCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LhdnCredentials.
     */
    cursor?: LhdnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LhdnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LhdnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LhdnCredentials.
     */
    distinct?: LhdnCredentialScalarFieldEnum | LhdnCredentialScalarFieldEnum[]
  }

  /**
   * LhdnCredential findFirstOrThrow
   */
  export type LhdnCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LhdnCredential to fetch.
     */
    where?: LhdnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LhdnCredentials to fetch.
     */
    orderBy?: LhdnCredentialOrderByWithRelationInput | LhdnCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LhdnCredentials.
     */
    cursor?: LhdnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LhdnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LhdnCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LhdnCredentials.
     */
    distinct?: LhdnCredentialScalarFieldEnum | LhdnCredentialScalarFieldEnum[]
  }

  /**
   * LhdnCredential findMany
   */
  export type LhdnCredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LhdnCredentials to fetch.
     */
    where?: LhdnCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LhdnCredentials to fetch.
     */
    orderBy?: LhdnCredentialOrderByWithRelationInput | LhdnCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LhdnCredentials.
     */
    cursor?: LhdnCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LhdnCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LhdnCredentials.
     */
    skip?: number
    distinct?: LhdnCredentialScalarFieldEnum | LhdnCredentialScalarFieldEnum[]
  }

  /**
   * LhdnCredential create
   */
  export type LhdnCredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a LhdnCredential.
     */
    data: XOR<LhdnCredentialCreateInput, LhdnCredentialUncheckedCreateInput>
  }

  /**
   * LhdnCredential createMany
   */
  export type LhdnCredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LhdnCredentials.
     */
    data: LhdnCredentialCreateManyInput | LhdnCredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LhdnCredential createManyAndReturn
   */
  export type LhdnCredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * The data used to create many LhdnCredentials.
     */
    data: LhdnCredentialCreateManyInput | LhdnCredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LhdnCredential update
   */
  export type LhdnCredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a LhdnCredential.
     */
    data: XOR<LhdnCredentialUpdateInput, LhdnCredentialUncheckedUpdateInput>
    /**
     * Choose, which LhdnCredential to update.
     */
    where: LhdnCredentialWhereUniqueInput
  }

  /**
   * LhdnCredential updateMany
   */
  export type LhdnCredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LhdnCredentials.
     */
    data: XOR<LhdnCredentialUpdateManyMutationInput, LhdnCredentialUncheckedUpdateManyInput>
    /**
     * Filter which LhdnCredentials to update
     */
    where?: LhdnCredentialWhereInput
    /**
     * Limit how many LhdnCredentials to update.
     */
    limit?: number
  }

  /**
   * LhdnCredential updateManyAndReturn
   */
  export type LhdnCredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * The data used to update LhdnCredentials.
     */
    data: XOR<LhdnCredentialUpdateManyMutationInput, LhdnCredentialUncheckedUpdateManyInput>
    /**
     * Filter which LhdnCredentials to update
     */
    where?: LhdnCredentialWhereInput
    /**
     * Limit how many LhdnCredentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LhdnCredential upsert
   */
  export type LhdnCredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the LhdnCredential to update in case it exists.
     */
    where: LhdnCredentialWhereUniqueInput
    /**
     * In case the LhdnCredential found by the `where` argument doesn't exist, create a new LhdnCredential with this data.
     */
    create: XOR<LhdnCredentialCreateInput, LhdnCredentialUncheckedCreateInput>
    /**
     * In case the LhdnCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LhdnCredentialUpdateInput, LhdnCredentialUncheckedUpdateInput>
  }

  /**
   * LhdnCredential delete
   */
  export type LhdnCredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
    /**
     * Filter which LhdnCredential to delete.
     */
    where: LhdnCredentialWhereUniqueInput
  }

  /**
   * LhdnCredential deleteMany
   */
  export type LhdnCredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LhdnCredentials to delete
     */
    where?: LhdnCredentialWhereInput
    /**
     * Limit how many LhdnCredentials to delete.
     */
    limit?: number
  }

  /**
   * LhdnCredential without action
   */
  export type LhdnCredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LhdnCredential
     */
    select?: LhdnCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LhdnCredential
     */
    omit?: LhdnCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LhdnCredentialInclude<ExtArgs> | null
  }


  /**
   * Model TenantCapability
   */

  export type AggregateTenantCapability = {
    _count: TenantCapabilityCountAggregateOutputType | null
    _min: TenantCapabilityMinAggregateOutputType | null
    _max: TenantCapabilityMaxAggregateOutputType | null
  }

  export type TenantCapabilityMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCapabilityMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    code: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCapabilityCountAggregateOutputType = {
    id: number
    tenantId: number
    code: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantCapabilityMinAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCapabilityMaxAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCapabilityCountAggregateInputType = {
    id?: true
    tenantId?: true
    code?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantCapabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantCapability to aggregate.
     */
    where?: TenantCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantCapabilities to fetch.
     */
    orderBy?: TenantCapabilityOrderByWithRelationInput | TenantCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantCapabilities
    **/
    _count?: true | TenantCapabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantCapabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantCapabilityMaxAggregateInputType
  }

  export type GetTenantCapabilityAggregateType<T extends TenantCapabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantCapability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantCapability[P]>
      : GetScalarType<T[P], AggregateTenantCapability[P]>
  }




  export type TenantCapabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantCapabilityWhereInput
    orderBy?: TenantCapabilityOrderByWithAggregationInput | TenantCapabilityOrderByWithAggregationInput[]
    by: TenantCapabilityScalarFieldEnum[] | TenantCapabilityScalarFieldEnum
    having?: TenantCapabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCapabilityCountAggregateInputType | true
    _min?: TenantCapabilityMinAggregateInputType
    _max?: TenantCapabilityMaxAggregateInputType
  }

  export type TenantCapabilityGroupByOutputType = {
    id: string
    tenantId: string
    code: string
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantCapabilityCountAggregateOutputType | null
    _min: TenantCapabilityMinAggregateOutputType | null
    _max: TenantCapabilityMaxAggregateOutputType | null
  }

  type GetTenantCapabilityGroupByPayload<T extends TenantCapabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantCapabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantCapabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantCapabilityGroupByOutputType[P]>
            : GetScalarType<T[P], TenantCapabilityGroupByOutputType[P]>
        }
      >
    >


  export type TenantCapabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantCapability"]>

  export type TenantCapabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantCapability"]>

  export type TenantCapabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    code?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantCapability"]>

  export type TenantCapabilitySelectScalar = {
    id?: boolean
    tenantId?: boolean
    code?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantCapabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "code" | "enabled" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantCapability"]>
  export type TenantCapabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantCapabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantCapabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantCapabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantCapability"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      code: string
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantCapability"]>
    composites: {}
  }

  type TenantCapabilityGetPayload<S extends boolean | null | undefined | TenantCapabilityDefaultArgs> = $Result.GetResult<Prisma.$TenantCapabilityPayload, S>

  type TenantCapabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantCapabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCapabilityCountAggregateInputType | true
    }

  export interface TenantCapabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantCapability'], meta: { name: 'TenantCapability' } }
    /**
     * Find zero or one TenantCapability that matches the filter.
     * @param {TenantCapabilityFindUniqueArgs} args - Arguments to find a TenantCapability
     * @example
     * // Get one TenantCapability
     * const tenantCapability = await prisma.tenantCapability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantCapabilityFindUniqueArgs>(args: SelectSubset<T, TenantCapabilityFindUniqueArgs<ExtArgs>>): Prisma__TenantCapabilityClient<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantCapability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantCapabilityFindUniqueOrThrowArgs} args - Arguments to find a TenantCapability
     * @example
     * // Get one TenantCapability
     * const tenantCapability = await prisma.tenantCapability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantCapabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantCapabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantCapabilityClient<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantCapability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCapabilityFindFirstArgs} args - Arguments to find a TenantCapability
     * @example
     * // Get one TenantCapability
     * const tenantCapability = await prisma.tenantCapability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantCapabilityFindFirstArgs>(args?: SelectSubset<T, TenantCapabilityFindFirstArgs<ExtArgs>>): Prisma__TenantCapabilityClient<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantCapability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCapabilityFindFirstOrThrowArgs} args - Arguments to find a TenantCapability
     * @example
     * // Get one TenantCapability
     * const tenantCapability = await prisma.tenantCapability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantCapabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantCapabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantCapabilityClient<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantCapabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCapabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantCapabilities
     * const tenantCapabilities = await prisma.tenantCapability.findMany()
     * 
     * // Get first 10 TenantCapabilities
     * const tenantCapabilities = await prisma.tenantCapability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantCapabilityWithIdOnly = await prisma.tenantCapability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantCapabilityFindManyArgs>(args?: SelectSubset<T, TenantCapabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantCapability.
     * @param {TenantCapabilityCreateArgs} args - Arguments to create a TenantCapability.
     * @example
     * // Create one TenantCapability
     * const TenantCapability = await prisma.tenantCapability.create({
     *   data: {
     *     // ... data to create a TenantCapability
     *   }
     * })
     * 
     */
    create<T extends TenantCapabilityCreateArgs>(args: SelectSubset<T, TenantCapabilityCreateArgs<ExtArgs>>): Prisma__TenantCapabilityClient<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantCapabilities.
     * @param {TenantCapabilityCreateManyArgs} args - Arguments to create many TenantCapabilities.
     * @example
     * // Create many TenantCapabilities
     * const tenantCapability = await prisma.tenantCapability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCapabilityCreateManyArgs>(args?: SelectSubset<T, TenantCapabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantCapabilities and returns the data saved in the database.
     * @param {TenantCapabilityCreateManyAndReturnArgs} args - Arguments to create many TenantCapabilities.
     * @example
     * // Create many TenantCapabilities
     * const tenantCapability = await prisma.tenantCapability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantCapabilities and only return the `id`
     * const tenantCapabilityWithIdOnly = await prisma.tenantCapability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCapabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCapabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantCapability.
     * @param {TenantCapabilityDeleteArgs} args - Arguments to delete one TenantCapability.
     * @example
     * // Delete one TenantCapability
     * const TenantCapability = await prisma.tenantCapability.delete({
     *   where: {
     *     // ... filter to delete one TenantCapability
     *   }
     * })
     * 
     */
    delete<T extends TenantCapabilityDeleteArgs>(args: SelectSubset<T, TenantCapabilityDeleteArgs<ExtArgs>>): Prisma__TenantCapabilityClient<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantCapability.
     * @param {TenantCapabilityUpdateArgs} args - Arguments to update one TenantCapability.
     * @example
     * // Update one TenantCapability
     * const tenantCapability = await prisma.tenantCapability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantCapabilityUpdateArgs>(args: SelectSubset<T, TenantCapabilityUpdateArgs<ExtArgs>>): Prisma__TenantCapabilityClient<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantCapabilities.
     * @param {TenantCapabilityDeleteManyArgs} args - Arguments to filter TenantCapabilities to delete.
     * @example
     * // Delete a few TenantCapabilities
     * const { count } = await prisma.tenantCapability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantCapabilityDeleteManyArgs>(args?: SelectSubset<T, TenantCapabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCapabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantCapabilities
     * const tenantCapability = await prisma.tenantCapability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantCapabilityUpdateManyArgs>(args: SelectSubset<T, TenantCapabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantCapabilities and returns the data updated in the database.
     * @param {TenantCapabilityUpdateManyAndReturnArgs} args - Arguments to update many TenantCapabilities.
     * @example
     * // Update many TenantCapabilities
     * const tenantCapability = await prisma.tenantCapability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantCapabilities and only return the `id`
     * const tenantCapabilityWithIdOnly = await prisma.tenantCapability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantCapabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantCapabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantCapability.
     * @param {TenantCapabilityUpsertArgs} args - Arguments to update or create a TenantCapability.
     * @example
     * // Update or create a TenantCapability
     * const tenantCapability = await prisma.tenantCapability.upsert({
     *   create: {
     *     // ... data to create a TenantCapability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantCapability we want to update
     *   }
     * })
     */
    upsert<T extends TenantCapabilityUpsertArgs>(args: SelectSubset<T, TenantCapabilityUpsertArgs<ExtArgs>>): Prisma__TenantCapabilityClient<$Result.GetResult<Prisma.$TenantCapabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantCapabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCapabilityCountArgs} args - Arguments to filter TenantCapabilities to count.
     * @example
     * // Count the number of TenantCapabilities
     * const count = await prisma.tenantCapability.count({
     *   where: {
     *     // ... the filter for the TenantCapabilities we want to count
     *   }
     * })
    **/
    count<T extends TenantCapabilityCountArgs>(
      args?: Subset<T, TenantCapabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCapabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCapabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantCapabilityAggregateArgs>(args: Subset<T, TenantCapabilityAggregateArgs>): Prisma.PrismaPromise<GetTenantCapabilityAggregateType<T>>

    /**
     * Group by TenantCapability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCapabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantCapabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantCapabilityGroupByArgs['orderBy'] }
        : { orderBy?: TenantCapabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantCapabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantCapabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantCapability model
   */
  readonly fields: TenantCapabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantCapability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantCapabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantCapability model
   */
  interface TenantCapabilityFieldRefs {
    readonly id: FieldRef<"TenantCapability", 'String'>
    readonly tenantId: FieldRef<"TenantCapability", 'String'>
    readonly code: FieldRef<"TenantCapability", 'String'>
    readonly enabled: FieldRef<"TenantCapability", 'Boolean'>
    readonly createdAt: FieldRef<"TenantCapability", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantCapability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantCapability findUnique
   */
  export type TenantCapabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which TenantCapability to fetch.
     */
    where: TenantCapabilityWhereUniqueInput
  }

  /**
   * TenantCapability findUniqueOrThrow
   */
  export type TenantCapabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which TenantCapability to fetch.
     */
    where: TenantCapabilityWhereUniqueInput
  }

  /**
   * TenantCapability findFirst
   */
  export type TenantCapabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which TenantCapability to fetch.
     */
    where?: TenantCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantCapabilities to fetch.
     */
    orderBy?: TenantCapabilityOrderByWithRelationInput | TenantCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantCapabilities.
     */
    cursor?: TenantCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantCapabilities.
     */
    distinct?: TenantCapabilityScalarFieldEnum | TenantCapabilityScalarFieldEnum[]
  }

  /**
   * TenantCapability findFirstOrThrow
   */
  export type TenantCapabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which TenantCapability to fetch.
     */
    where?: TenantCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantCapabilities to fetch.
     */
    orderBy?: TenantCapabilityOrderByWithRelationInput | TenantCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantCapabilities.
     */
    cursor?: TenantCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantCapabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantCapabilities.
     */
    distinct?: TenantCapabilityScalarFieldEnum | TenantCapabilityScalarFieldEnum[]
  }

  /**
   * TenantCapability findMany
   */
  export type TenantCapabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * Filter, which TenantCapabilities to fetch.
     */
    where?: TenantCapabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantCapabilities to fetch.
     */
    orderBy?: TenantCapabilityOrderByWithRelationInput | TenantCapabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantCapabilities.
     */
    cursor?: TenantCapabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantCapabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantCapabilities.
     */
    skip?: number
    distinct?: TenantCapabilityScalarFieldEnum | TenantCapabilityScalarFieldEnum[]
  }

  /**
   * TenantCapability create
   */
  export type TenantCapabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantCapability.
     */
    data: XOR<TenantCapabilityCreateInput, TenantCapabilityUncheckedCreateInput>
  }

  /**
   * TenantCapability createMany
   */
  export type TenantCapabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantCapabilities.
     */
    data: TenantCapabilityCreateManyInput | TenantCapabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantCapability createManyAndReturn
   */
  export type TenantCapabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * The data used to create many TenantCapabilities.
     */
    data: TenantCapabilityCreateManyInput | TenantCapabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantCapability update
   */
  export type TenantCapabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantCapability.
     */
    data: XOR<TenantCapabilityUpdateInput, TenantCapabilityUncheckedUpdateInput>
    /**
     * Choose, which TenantCapability to update.
     */
    where: TenantCapabilityWhereUniqueInput
  }

  /**
   * TenantCapability updateMany
   */
  export type TenantCapabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantCapabilities.
     */
    data: XOR<TenantCapabilityUpdateManyMutationInput, TenantCapabilityUncheckedUpdateManyInput>
    /**
     * Filter which TenantCapabilities to update
     */
    where?: TenantCapabilityWhereInput
    /**
     * Limit how many TenantCapabilities to update.
     */
    limit?: number
  }

  /**
   * TenantCapability updateManyAndReturn
   */
  export type TenantCapabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * The data used to update TenantCapabilities.
     */
    data: XOR<TenantCapabilityUpdateManyMutationInput, TenantCapabilityUncheckedUpdateManyInput>
    /**
     * Filter which TenantCapabilities to update
     */
    where?: TenantCapabilityWhereInput
    /**
     * Limit how many TenantCapabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantCapability upsert
   */
  export type TenantCapabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantCapability to update in case it exists.
     */
    where: TenantCapabilityWhereUniqueInput
    /**
     * In case the TenantCapability found by the `where` argument doesn't exist, create a new TenantCapability with this data.
     */
    create: XOR<TenantCapabilityCreateInput, TenantCapabilityUncheckedCreateInput>
    /**
     * In case the TenantCapability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantCapabilityUpdateInput, TenantCapabilityUncheckedUpdateInput>
  }

  /**
   * TenantCapability delete
   */
  export type TenantCapabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
    /**
     * Filter which TenantCapability to delete.
     */
    where: TenantCapabilityWhereUniqueInput
  }

  /**
   * TenantCapability deleteMany
   */
  export type TenantCapabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantCapabilities to delete
     */
    where?: TenantCapabilityWhereInput
    /**
     * Limit how many TenantCapabilities to delete.
     */
    limit?: number
  }

  /**
   * TenantCapability without action
   */
  export type TenantCapabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCapability
     */
    select?: TenantCapabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantCapability
     */
    omit?: TenantCapabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantCapabilityInclude<ExtArgs> | null
  }


  /**
   * Model PrintAudit
   */

  export type AggregatePrintAudit = {
    _count: PrintAuditCountAggregateOutputType | null
    _avg: PrintAuditAvgAggregateOutputType | null
    _sum: PrintAuditSumAggregateOutputType | null
    _min: PrintAuditMinAggregateOutputType | null
    _max: PrintAuditMaxAggregateOutputType | null
  }

  export type PrintAuditAvgAggregateOutputType = {
    copies: number | null
  }

  export type PrintAuditSumAggregateOutputType = {
    copies: number | null
  }

  export type PrintAuditMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    documentType: string | null
    documentId: string | null
    documentNumber: string | null
    printerName: string | null
    paperSize: string | null
    copies: number | null
    printMode: string | null
    success: boolean | null
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    printTimestamp: Date | null
  }

  export type PrintAuditMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    documentType: string | null
    documentId: string | null
    documentNumber: string | null
    printerName: string | null
    paperSize: string | null
    copies: number | null
    printMode: string | null
    success: boolean | null
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    printTimestamp: Date | null
  }

  export type PrintAuditCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    documentType: number
    documentId: number
    documentNumber: number
    printerName: number
    paperSize: number
    copies: number
    printMode: number
    success: number
    errorMessage: number
    ipAddress: number
    userAgent: number
    printTimestamp: number
    _all: number
  }


  export type PrintAuditAvgAggregateInputType = {
    copies?: true
  }

  export type PrintAuditSumAggregateInputType = {
    copies?: true
  }

  export type PrintAuditMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    documentType?: true
    documentId?: true
    documentNumber?: true
    printerName?: true
    paperSize?: true
    copies?: true
    printMode?: true
    success?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    printTimestamp?: true
  }

  export type PrintAuditMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    documentType?: true
    documentId?: true
    documentNumber?: true
    printerName?: true
    paperSize?: true
    copies?: true
    printMode?: true
    success?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    printTimestamp?: true
  }

  export type PrintAuditCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    documentType?: true
    documentId?: true
    documentNumber?: true
    printerName?: true
    paperSize?: true
    copies?: true
    printMode?: true
    success?: true
    errorMessage?: true
    ipAddress?: true
    userAgent?: true
    printTimestamp?: true
    _all?: true
  }

  export type PrintAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrintAudit to aggregate.
     */
    where?: PrintAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintAudits to fetch.
     */
    orderBy?: PrintAuditOrderByWithRelationInput | PrintAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrintAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrintAudits
    **/
    _count?: true | PrintAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrintAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrintAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrintAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrintAuditMaxAggregateInputType
  }

  export type GetPrintAuditAggregateType<T extends PrintAuditAggregateArgs> = {
        [P in keyof T & keyof AggregatePrintAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrintAudit[P]>
      : GetScalarType<T[P], AggregatePrintAudit[P]>
  }




  export type PrintAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintAuditWhereInput
    orderBy?: PrintAuditOrderByWithAggregationInput | PrintAuditOrderByWithAggregationInput[]
    by: PrintAuditScalarFieldEnum[] | PrintAuditScalarFieldEnum
    having?: PrintAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrintAuditCountAggregateInputType | true
    _avg?: PrintAuditAvgAggregateInputType
    _sum?: PrintAuditSumAggregateInputType
    _min?: PrintAuditMinAggregateInputType
    _max?: PrintAuditMaxAggregateInputType
  }

  export type PrintAuditGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    documentType: string
    documentId: string
    documentNumber: string | null
    printerName: string | null
    paperSize: string | null
    copies: number
    printMode: string | null
    success: boolean
    errorMessage: string | null
    ipAddress: string | null
    userAgent: string | null
    printTimestamp: Date
    _count: PrintAuditCountAggregateOutputType | null
    _avg: PrintAuditAvgAggregateOutputType | null
    _sum: PrintAuditSumAggregateOutputType | null
    _min: PrintAuditMinAggregateOutputType | null
    _max: PrintAuditMaxAggregateOutputType | null
  }

  type GetPrintAuditGroupByPayload<T extends PrintAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrintAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrintAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrintAuditGroupByOutputType[P]>
            : GetScalarType<T[P], PrintAuditGroupByOutputType[P]>
        }
      >
    >


  export type PrintAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    documentType?: boolean
    documentId?: boolean
    documentNumber?: boolean
    printerName?: boolean
    paperSize?: boolean
    copies?: boolean
    printMode?: boolean
    success?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    printTimestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["printAudit"]>

  export type PrintAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    documentType?: boolean
    documentId?: boolean
    documentNumber?: boolean
    printerName?: boolean
    paperSize?: boolean
    copies?: boolean
    printMode?: boolean
    success?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    printTimestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["printAudit"]>

  export type PrintAuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    documentType?: boolean
    documentId?: boolean
    documentNumber?: boolean
    printerName?: boolean
    paperSize?: boolean
    copies?: boolean
    printMode?: boolean
    success?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    printTimestamp?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["printAudit"]>

  export type PrintAuditSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    documentType?: boolean
    documentId?: boolean
    documentNumber?: boolean
    printerName?: boolean
    paperSize?: boolean
    copies?: boolean
    printMode?: boolean
    success?: boolean
    errorMessage?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    printTimestamp?: boolean
  }

  export type PrintAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "documentType" | "documentId" | "documentNumber" | "printerName" | "paperSize" | "copies" | "printMode" | "success" | "errorMessage" | "ipAddress" | "userAgent" | "printTimestamp", ExtArgs["result"]["printAudit"]>
  export type PrintAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrintAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrintAuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PrintAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrintAudit"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      documentType: string
      documentId: string
      documentNumber: string | null
      printerName: string | null
      paperSize: string | null
      copies: number
      printMode: string | null
      success: boolean
      errorMessage: string | null
      ipAddress: string | null
      userAgent: string | null
      printTimestamp: Date
    }, ExtArgs["result"]["printAudit"]>
    composites: {}
  }

  type PrintAuditGetPayload<S extends boolean | null | undefined | PrintAuditDefaultArgs> = $Result.GetResult<Prisma.$PrintAuditPayload, S>

  type PrintAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrintAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrintAuditCountAggregateInputType | true
    }

  export interface PrintAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrintAudit'], meta: { name: 'PrintAudit' } }
    /**
     * Find zero or one PrintAudit that matches the filter.
     * @param {PrintAuditFindUniqueArgs} args - Arguments to find a PrintAudit
     * @example
     * // Get one PrintAudit
     * const printAudit = await prisma.printAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrintAuditFindUniqueArgs>(args: SelectSubset<T, PrintAuditFindUniqueArgs<ExtArgs>>): Prisma__PrintAuditClient<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrintAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrintAuditFindUniqueOrThrowArgs} args - Arguments to find a PrintAudit
     * @example
     * // Get one PrintAudit
     * const printAudit = await prisma.printAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrintAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, PrintAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrintAuditClient<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrintAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintAuditFindFirstArgs} args - Arguments to find a PrintAudit
     * @example
     * // Get one PrintAudit
     * const printAudit = await prisma.printAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrintAuditFindFirstArgs>(args?: SelectSubset<T, PrintAuditFindFirstArgs<ExtArgs>>): Prisma__PrintAuditClient<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrintAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintAuditFindFirstOrThrowArgs} args - Arguments to find a PrintAudit
     * @example
     * // Get one PrintAudit
     * const printAudit = await prisma.printAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrintAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, PrintAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrintAuditClient<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrintAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrintAudits
     * const printAudits = await prisma.printAudit.findMany()
     * 
     * // Get first 10 PrintAudits
     * const printAudits = await prisma.printAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const printAuditWithIdOnly = await prisma.printAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrintAuditFindManyArgs>(args?: SelectSubset<T, PrintAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrintAudit.
     * @param {PrintAuditCreateArgs} args - Arguments to create a PrintAudit.
     * @example
     * // Create one PrintAudit
     * const PrintAudit = await prisma.printAudit.create({
     *   data: {
     *     // ... data to create a PrintAudit
     *   }
     * })
     * 
     */
    create<T extends PrintAuditCreateArgs>(args: SelectSubset<T, PrintAuditCreateArgs<ExtArgs>>): Prisma__PrintAuditClient<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrintAudits.
     * @param {PrintAuditCreateManyArgs} args - Arguments to create many PrintAudits.
     * @example
     * // Create many PrintAudits
     * const printAudit = await prisma.printAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrintAuditCreateManyArgs>(args?: SelectSubset<T, PrintAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrintAudits and returns the data saved in the database.
     * @param {PrintAuditCreateManyAndReturnArgs} args - Arguments to create many PrintAudits.
     * @example
     * // Create many PrintAudits
     * const printAudit = await prisma.printAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrintAudits and only return the `id`
     * const printAuditWithIdOnly = await prisma.printAudit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrintAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, PrintAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrintAudit.
     * @param {PrintAuditDeleteArgs} args - Arguments to delete one PrintAudit.
     * @example
     * // Delete one PrintAudit
     * const PrintAudit = await prisma.printAudit.delete({
     *   where: {
     *     // ... filter to delete one PrintAudit
     *   }
     * })
     * 
     */
    delete<T extends PrintAuditDeleteArgs>(args: SelectSubset<T, PrintAuditDeleteArgs<ExtArgs>>): Prisma__PrintAuditClient<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrintAudit.
     * @param {PrintAuditUpdateArgs} args - Arguments to update one PrintAudit.
     * @example
     * // Update one PrintAudit
     * const printAudit = await prisma.printAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrintAuditUpdateArgs>(args: SelectSubset<T, PrintAuditUpdateArgs<ExtArgs>>): Prisma__PrintAuditClient<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrintAudits.
     * @param {PrintAuditDeleteManyArgs} args - Arguments to filter PrintAudits to delete.
     * @example
     * // Delete a few PrintAudits
     * const { count } = await prisma.printAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrintAuditDeleteManyArgs>(args?: SelectSubset<T, PrintAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrintAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrintAudits
     * const printAudit = await prisma.printAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrintAuditUpdateManyArgs>(args: SelectSubset<T, PrintAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrintAudits and returns the data updated in the database.
     * @param {PrintAuditUpdateManyAndReturnArgs} args - Arguments to update many PrintAudits.
     * @example
     * // Update many PrintAudits
     * const printAudit = await prisma.printAudit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrintAudits and only return the `id`
     * const printAuditWithIdOnly = await prisma.printAudit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrintAuditUpdateManyAndReturnArgs>(args: SelectSubset<T, PrintAuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrintAudit.
     * @param {PrintAuditUpsertArgs} args - Arguments to update or create a PrintAudit.
     * @example
     * // Update or create a PrintAudit
     * const printAudit = await prisma.printAudit.upsert({
     *   create: {
     *     // ... data to create a PrintAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrintAudit we want to update
     *   }
     * })
     */
    upsert<T extends PrintAuditUpsertArgs>(args: SelectSubset<T, PrintAuditUpsertArgs<ExtArgs>>): Prisma__PrintAuditClient<$Result.GetResult<Prisma.$PrintAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrintAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintAuditCountArgs} args - Arguments to filter PrintAudits to count.
     * @example
     * // Count the number of PrintAudits
     * const count = await prisma.printAudit.count({
     *   where: {
     *     // ... the filter for the PrintAudits we want to count
     *   }
     * })
    **/
    count<T extends PrintAuditCountArgs>(
      args?: Subset<T, PrintAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrintAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrintAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrintAuditAggregateArgs>(args: Subset<T, PrintAuditAggregateArgs>): Prisma.PrismaPromise<GetPrintAuditAggregateType<T>>

    /**
     * Group by PrintAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrintAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrintAuditGroupByArgs['orderBy'] }
        : { orderBy?: PrintAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrintAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrintAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrintAudit model
   */
  readonly fields: PrintAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrintAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrintAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrintAudit model
   */
  interface PrintAuditFieldRefs {
    readonly id: FieldRef<"PrintAudit", 'String'>
    readonly tenantId: FieldRef<"PrintAudit", 'String'>
    readonly userId: FieldRef<"PrintAudit", 'String'>
    readonly documentType: FieldRef<"PrintAudit", 'String'>
    readonly documentId: FieldRef<"PrintAudit", 'String'>
    readonly documentNumber: FieldRef<"PrintAudit", 'String'>
    readonly printerName: FieldRef<"PrintAudit", 'String'>
    readonly paperSize: FieldRef<"PrintAudit", 'String'>
    readonly copies: FieldRef<"PrintAudit", 'Int'>
    readonly printMode: FieldRef<"PrintAudit", 'String'>
    readonly success: FieldRef<"PrintAudit", 'Boolean'>
    readonly errorMessage: FieldRef<"PrintAudit", 'String'>
    readonly ipAddress: FieldRef<"PrintAudit", 'String'>
    readonly userAgent: FieldRef<"PrintAudit", 'String'>
    readonly printTimestamp: FieldRef<"PrintAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrintAudit findUnique
   */
  export type PrintAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * Filter, which PrintAudit to fetch.
     */
    where: PrintAuditWhereUniqueInput
  }

  /**
   * PrintAudit findUniqueOrThrow
   */
  export type PrintAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * Filter, which PrintAudit to fetch.
     */
    where: PrintAuditWhereUniqueInput
  }

  /**
   * PrintAudit findFirst
   */
  export type PrintAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * Filter, which PrintAudit to fetch.
     */
    where?: PrintAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintAudits to fetch.
     */
    orderBy?: PrintAuditOrderByWithRelationInput | PrintAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrintAudits.
     */
    cursor?: PrintAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrintAudits.
     */
    distinct?: PrintAuditScalarFieldEnum | PrintAuditScalarFieldEnum[]
  }

  /**
   * PrintAudit findFirstOrThrow
   */
  export type PrintAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * Filter, which PrintAudit to fetch.
     */
    where?: PrintAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintAudits to fetch.
     */
    orderBy?: PrintAuditOrderByWithRelationInput | PrintAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrintAudits.
     */
    cursor?: PrintAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrintAudits.
     */
    distinct?: PrintAuditScalarFieldEnum | PrintAuditScalarFieldEnum[]
  }

  /**
   * PrintAudit findMany
   */
  export type PrintAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * Filter, which PrintAudits to fetch.
     */
    where?: PrintAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintAudits to fetch.
     */
    orderBy?: PrintAuditOrderByWithRelationInput | PrintAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrintAudits.
     */
    cursor?: PrintAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintAudits.
     */
    skip?: number
    distinct?: PrintAuditScalarFieldEnum | PrintAuditScalarFieldEnum[]
  }

  /**
   * PrintAudit create
   */
  export type PrintAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a PrintAudit.
     */
    data: XOR<PrintAuditCreateInput, PrintAuditUncheckedCreateInput>
  }

  /**
   * PrintAudit createMany
   */
  export type PrintAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrintAudits.
     */
    data: PrintAuditCreateManyInput | PrintAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrintAudit createManyAndReturn
   */
  export type PrintAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * The data used to create many PrintAudits.
     */
    data: PrintAuditCreateManyInput | PrintAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrintAudit update
   */
  export type PrintAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a PrintAudit.
     */
    data: XOR<PrintAuditUpdateInput, PrintAuditUncheckedUpdateInput>
    /**
     * Choose, which PrintAudit to update.
     */
    where: PrintAuditWhereUniqueInput
  }

  /**
   * PrintAudit updateMany
   */
  export type PrintAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrintAudits.
     */
    data: XOR<PrintAuditUpdateManyMutationInput, PrintAuditUncheckedUpdateManyInput>
    /**
     * Filter which PrintAudits to update
     */
    where?: PrintAuditWhereInput
    /**
     * Limit how many PrintAudits to update.
     */
    limit?: number
  }

  /**
   * PrintAudit updateManyAndReturn
   */
  export type PrintAuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * The data used to update PrintAudits.
     */
    data: XOR<PrintAuditUpdateManyMutationInput, PrintAuditUncheckedUpdateManyInput>
    /**
     * Filter which PrintAudits to update
     */
    where?: PrintAuditWhereInput
    /**
     * Limit how many PrintAudits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrintAudit upsert
   */
  export type PrintAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the PrintAudit to update in case it exists.
     */
    where: PrintAuditWhereUniqueInput
    /**
     * In case the PrintAudit found by the `where` argument doesn't exist, create a new PrintAudit with this data.
     */
    create: XOR<PrintAuditCreateInput, PrintAuditUncheckedCreateInput>
    /**
     * In case the PrintAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrintAuditUpdateInput, PrintAuditUncheckedUpdateInput>
  }

  /**
   * PrintAudit delete
   */
  export type PrintAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
    /**
     * Filter which PrintAudit to delete.
     */
    where: PrintAuditWhereUniqueInput
  }

  /**
   * PrintAudit deleteMany
   */
  export type PrintAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrintAudits to delete
     */
    where?: PrintAuditWhereInput
    /**
     * Limit how many PrintAudits to delete.
     */
    limit?: number
  }

  /**
   * PrintAudit without action
   */
  export type PrintAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintAudit
     */
    select?: PrintAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrintAudit
     */
    omit?: PrintAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintAuditInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    domain: 'domain',
    status: 'status',
    tier: 'tier',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    authPolicyPrimary: 'authPolicyPrimary',
    authPolicyMfa: 'authPolicyMfa',
    authPolicyIdentifier: 'authPolicyIdentifier',
    authPolicyAllowFallback: 'authPolicyAllowFallback'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    roleId: 'roleId',
    avatar: 'avatar',
    phone: 'phone',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    failedLogins: 'failedLogins',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const PlatformAdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    department: 'department',
    avatar: 'avatar',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    failedLogins: 'failedLogins',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformAdminScalarFieldEnum = (typeof PlatformAdminScalarFieldEnum)[keyof typeof PlatformAdminScalarFieldEnum]


  export const PlatformAdminRefreshTokenScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    token: 'token',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type PlatformAdminRefreshTokenScalarFieldEnum = (typeof PlatformAdminRefreshTokenScalarFieldEnum)[keyof typeof PlatformAdminRefreshTokenScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    color: 'color',
    isSystem: 'isSystem',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    module: 'module',
    action: 'action',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const LicenseScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tier: 'tier',
    licenseKey: 'licenseKey',
    features: 'features',
    maxUsers: 'maxUsers',
    maxProducts: 'maxProducts',
    startsAt: 'startsAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LicenseScalarFieldEnum = (typeof LicenseScalarFieldEnum)[keyof typeof LicenseScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    parentId: 'parentId',
    name: 'name',
    slug: 'slug',
    description: 'description',
    image: 'image',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    categoryId: 'categoryId',
    sku: 'sku',
    barcode: 'barcode',
    name: 'name',
    description: 'description',
    unit: 'unit',
    price: 'price',
    cost: 'cost',
    taxRate: 'taxRate',
    minStock: 'minStock',
    maxStock: 'maxStock',
    reorderPoint: 'reorderPoint',
    reorderQty: 'reorderQty',
    weight: 'weight',
    dimensions: 'dimensions',
    images: 'images',
    attributes: 'attributes',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    code: 'code',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    manager: 'manager',
    type: 'type',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    productId: 'productId',
    warehouseId: 'warehouseId',
    quantity: 'quantity',
    reservedQty: 'reservedQty',
    availableQty: 'availableQty',
    batchNumber: 'batchNumber',
    lotNumber: 'lotNumber',
    serialNumber: 'serialNumber',
    expiryDate: 'expiryDate',
    location: 'location',
    costPrice: 'costPrice',
    lastCountedAt: 'lastCountedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    productId: 'productId',
    fromWarehouseId: 'fromWarehouseId',
    toWarehouseId: 'toWarehouseId',
    userId: 'userId',
    type: 'type',
    quantity: 'quantity',
    unitCost: 'unitCost',
    totalCost: 'totalCost',
    reference: 'reference',
    referenceType: 'referenceType',
    batchNumber: 'batchNumber',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    code: 'code',
    name: 'name',
    type: 'type',
    email: 'email',
    phone: 'phone',
    mobile: 'mobile',
    fax: 'fax',
    website: 'website',
    taxId: 'taxId',
    billingAddress: 'billingAddress',
    shippingAddress: 'shippingAddress',
    paymentTerms: 'paymentTerms',
    creditLimit: 'creditLimit',
    currentBalance: 'currentBalance',
    notes: 'notes',
    tags: 'tags',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    code: 'code',
    name: 'name',
    contactPerson: 'contactPerson',
    email: 'email',
    phone: 'phone',
    mobile: 'mobile',
    fax: 'fax',
    website: 'website',
    taxId: 'taxId',
    address: 'address',
    bankDetails: 'bankDetails',
    paymentTerms: 'paymentTerms',
    currency: 'currency',
    leadTime: 'leadTime',
    minimumOrder: 'minimumOrder',
    rating: 'rating',
    notes: 'notes',
    tags: 'tags',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const SupplierProductScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    supplierId: 'supplierId',
    productId: 'productId',
    supplierSku: 'supplierSku',
    unitPrice: 'unitPrice',
    minOrderQty: 'minOrderQty',
    leadTime: 'leadTime',
    isPreferred: 'isPreferred',
    lastOrderAt: 'lastOrderAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierProductScalarFieldEnum = (typeof SupplierProductScalarFieldEnum)[keyof typeof SupplierProductScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    orderNumber: 'orderNumber',
    type: 'type',
    status: 'status',
    customerId: 'customerId',
    supplierId: 'supplierId',
    warehouseId: 'warehouseId',
    createdById: 'createdById',
    approvedById: 'approvedById',
    orderDate: 'orderDate',
    expectedDate: 'expectedDate',
    shippedDate: 'shippedDate',
    deliveredDate: 'deliveredDate',
    shippingAddress: 'shippingAddress',
    billingAddress: 'billingAddress',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    shippingCost: 'shippingCost',
    discount: 'discount',
    discountType: 'discountType',
    total: 'total',
    currency: 'currency',
    exchangeRate: 'exchangeRate',
    paymentTerms: 'paymentTerms',
    paymentMethod: 'paymentMethod',
    notes: 'notes',
    internalNotes: 'internalNotes',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    sku: 'sku',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    shippedQty: 'shippedQty',
    receivedQty: 'receivedQty',
    unitPrice: 'unitPrice',
    unitCost: 'unitCost',
    discount: 'discount',
    discountType: 'discountType',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    total: 'total',
    notes: 'notes',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    orderId: 'orderId',
    customerId: 'customerId',
    createdById: 'createdById',
    invoiceNumber: 'invoiceNumber',
    type: 'type',
    status: 'status',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    discount: 'discount',
    shippingCost: 'shippingCost',
    total: 'total',
    paidAmount: 'paidAmount',
    balanceDue: 'balanceDue',
    currency: 'currency',
    exchangeRate: 'exchangeRate',
    notes: 'notes',
    terms: 'terms',
    footer: 'footer',
    metadata: 'metadata',
    sentAt: 'sentAt',
    viewedAt: 'viewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    productId: 'productId',
    sku: 'sku',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discount: 'discount',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    total: 'total',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceId: 'invoiceId',
    customerId: 'customerId',
    receivedById: 'receivedById',
    paymentNumber: 'paymentNumber',
    type: 'type',
    method: 'method',
    status: 'status',
    amount: 'amount',
    currency: 'currency',
    exchangeRate: 'exchangeRate',
    paymentDate: 'paymentDate',
    reference: 'reference',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    entityName: 'entityName',
    oldValues: 'oldValues',
    newValues: 'newValues',
    changedFields: 'changedFields',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    requestId: 'requestId',
    duration: 'duration',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    assetTag: 'assetTag',
    name: 'name',
    description: 'description',
    assetType: 'assetType',
    category: 'category',
    status: 'status',
    location: 'location',
    assignedTo: 'assignedTo',
    purchaseDate: 'purchaseDate',
    purchaseCost: 'purchaseCost',
    currentValue: 'currentValue',
    depreciationMethod: 'depreciationMethod',
    usefulLifeYears: 'usefulLifeYears',
    salvageValue: 'salvageValue',
    warrantyExpiry: 'warrantyExpiry',
    serialNumber: 'serialNumber',
    manufacturer: 'manufacturer',
    model: 'model',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const EInvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceId: 'invoiceId',
    invoiceType: 'invoiceType',
    status: 'status',
    lhdnUuid: 'lhdnUuid',
    lhdnLongId: 'lhdnLongId',
    lhdnSubmissionUid: 'lhdnSubmissionUid',
    submittedAt: 'submittedAt',
    validatedAt: 'validatedAt',
    cancelledAt: 'cancelledAt',
    rejectedAt: 'rejectedAt',
    requestJson: 'requestJson',
    responseJson: 'responseJson',
    documentHash: 'documentHash',
    rejectReason: 'rejectReason',
    validationErrors: 'validationErrors',
    retryCount: 'retryCount',
    lastRetryAt: 'lastRetryAt',
    originalEInvoiceId: 'originalEInvoiceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EInvoiceScalarFieldEnum = (typeof EInvoiceScalarFieldEnum)[keyof typeof EInvoiceScalarFieldEnum]


  export const EInvoiceItemScalarFieldEnum: {
    id: 'id',
    eInvoiceId: 'eInvoiceId',
    invoiceItemId: 'invoiceItemId',
    classificationCode: 'classificationCode',
    description: 'description',
    quantity: 'quantity',
    unitCode: 'unitCode',
    unitPrice: 'unitPrice',
    taxType: 'taxType',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    taxExemptReason: 'taxExemptReason',
    subtotal: 'subtotal',
    discountAmount: 'discountAmount',
    discountRate: 'discountRate',
    totalAmount: 'totalAmount',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EInvoiceItemScalarFieldEnum = (typeof EInvoiceItemScalarFieldEnum)[keyof typeof EInvoiceItemScalarFieldEnum]


  export const EInvoiceLogScalarFieldEnum: {
    id: 'id',
    eInvoiceId: 'eInvoiceId',
    action: 'action',
    status: 'status',
    message: 'message',
    requestData: 'requestData',
    responseData: 'responseData',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type EInvoiceLogScalarFieldEnum = (typeof EInvoiceLogScalarFieldEnum)[keyof typeof EInvoiceLogScalarFieldEnum]


  export const LhdnTokenScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    accessToken: 'accessToken',
    tokenType: 'tokenType',
    expiresAt: 'expiresAt',
    scope: 'scope',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LhdnTokenScalarFieldEnum = (typeof LhdnTokenScalarFieldEnum)[keyof typeof LhdnTokenScalarFieldEnum]


  export const LhdnCredentialScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    clientId: 'clientId',
    clientSecretEncrypted: 'clientSecretEncrypted',
    tin: 'tin',
    brn: 'brn',
    idType: 'idType',
    idValue: 'idValue',
    environment: 'environment',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LhdnCredentialScalarFieldEnum = (typeof LhdnCredentialScalarFieldEnum)[keyof typeof LhdnCredentialScalarFieldEnum]


  export const TenantCapabilityScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    code: 'code',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantCapabilityScalarFieldEnum = (typeof TenantCapabilityScalarFieldEnum)[keyof typeof TenantCapabilityScalarFieldEnum]


  export const PrintAuditScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    documentType: 'documentType',
    documentId: 'documentId',
    documentNumber: 'documentNumber',
    printerName: 'printerName',
    paperSize: 'paperSize',
    copies: 'copies',
    printMode: 'printMode',
    success: 'success',
    errorMessage: 'errorMessage',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    printTimestamp: 'printTimestamp'
  };

  export type PrintAuditScalarFieldEnum = (typeof PrintAuditScalarFieldEnum)[keyof typeof PrintAuditScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TenantStatus'
   */
  export type EnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus'>
    


  /**
   * Reference to a field of type 'TenantStatus[]'
   */
  export type ListEnumTenantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantStatus[]'>
    


  /**
   * Reference to a field of type 'LicenseTier'
   */
  export type EnumLicenseTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseTier'>
    


  /**
   * Reference to a field of type 'LicenseTier[]'
   */
  export type ListEnumLicenseTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseTier[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AuthPolicyPrimary'
   */
  export type EnumAuthPolicyPrimaryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthPolicyPrimary'>
    


  /**
   * Reference to a field of type 'AuthPolicyPrimary[]'
   */
  export type ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthPolicyPrimary[]'>
    


  /**
   * Reference to a field of type 'AuthPolicyMfa'
   */
  export type EnumAuthPolicyMfaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthPolicyMfa'>
    


  /**
   * Reference to a field of type 'AuthPolicyMfa[]'
   */
  export type ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthPolicyMfa[]'>
    


  /**
   * Reference to a field of type 'AuthPolicyIdentifier'
   */
  export type EnumAuthPolicyIdentifierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthPolicyIdentifier'>
    


  /**
   * Reference to a field of type 'AuthPolicyIdentifier[]'
   */
  export type ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthPolicyIdentifier[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


  /**
   * Reference to a field of type 'WarehouseType'
   */
  export type EnumWarehouseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WarehouseType'>
    


  /**
   * Reference to a field of type 'WarehouseType[]'
   */
  export type ListEnumWarehouseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WarehouseType[]'>
    


  /**
   * Reference to a field of type 'MovementType'
   */
  export type EnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType'>
    


  /**
   * Reference to a field of type 'MovementType[]'
   */
  export type ListEnumMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MovementType[]'>
    


  /**
   * Reference to a field of type 'CustomerType'
   */
  export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType'>
    


  /**
   * Reference to a field of type 'CustomerType[]'
   */
  export type ListEnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType[]'>
    


  /**
   * Reference to a field of type 'OrderType'
   */
  export type EnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType'>
    


  /**
   * Reference to a field of type 'OrderType[]'
   */
  export type ListEnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'AssetType'
   */
  export type EnumAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetType'>
    


  /**
   * Reference to a field of type 'AssetType[]'
   */
  export type ListEnumAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetType[]'>
    


  /**
   * Reference to a field of type 'AssetCategory'
   */
  export type EnumAssetCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetCategory'>
    


  /**
   * Reference to a field of type 'AssetCategory[]'
   */
  export type ListEnumAssetCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetCategory[]'>
    


  /**
   * Reference to a field of type 'AssetStatus'
   */
  export type EnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus'>
    


  /**
   * Reference to a field of type 'AssetStatus[]'
   */
  export type ListEnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus[]'>
    


  /**
   * Reference to a field of type 'DepreciationMethod'
   */
  export type EnumDepreciationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepreciationMethod'>
    


  /**
   * Reference to a field of type 'DepreciationMethod[]'
   */
  export type ListEnumDepreciationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepreciationMethod[]'>
    


  /**
   * Reference to a field of type 'EInvoiceType'
   */
  export type EnumEInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EInvoiceType'>
    


  /**
   * Reference to a field of type 'EInvoiceType[]'
   */
  export type ListEnumEInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EInvoiceType[]'>
    


  /**
   * Reference to a field of type 'EInvoiceStatus'
   */
  export type EnumEInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EInvoiceStatus'>
    


  /**
   * Reference to a field of type 'EInvoiceStatus[]'
   */
  export type ListEnumEInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EInvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'LhdnEnvironment'
   */
  export type EnumLhdnEnvironmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LhdnEnvironment'>
    


  /**
   * Reference to a field of type 'LhdnEnvironment[]'
   */
  export type ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LhdnEnvironment[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: UuidFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    tier?: EnumLicenseTierFilter<"Tenant"> | $Enums.LicenseTier
    settings?: JsonFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFilter<"Tenant"> | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFilter<"Tenant"> | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFilter<"Tenant"> | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFilter<"Tenant"> | boolean
    users?: UserListRelationFilter
    products?: ProductListRelationFilter
    categories?: CategoryListRelationFilter
    customers?: CustomerListRelationFilter
    suppliers?: SupplierListRelationFilter
    warehouses?: WarehouseListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    licenses?: LicenseListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    assets?: AssetListRelationFilter
    roles?: RoleListRelationFilter
    eInvoices?: EInvoiceListRelationFilter
    lhdnToken?: XOR<LhdnTokenNullableScalarRelationFilter, LhdnTokenWhereInput> | null
    lhdnCredential?: XOR<LhdnCredentialNullableScalarRelationFilter, LhdnCredentialWhereInput> | null
    capabilities?: TenantCapabilityListRelationFilter
    printAudits?: PrintAuditListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrderInput | SortOrder
    status?: SortOrder
    tier?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    authPolicyPrimary?: SortOrder
    authPolicyMfa?: SortOrder
    authPolicyIdentifier?: SortOrder
    authPolicyAllowFallback?: SortOrder
    users?: UserOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    suppliers?: SupplierOrderByRelationAggregateInput
    warehouses?: WarehouseOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    licenses?: LicenseOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    roles?: RoleOrderByRelationAggregateInput
    eInvoices?: EInvoiceOrderByRelationAggregateInput
    lhdnToken?: LhdnTokenOrderByWithRelationInput
    lhdnCredential?: LhdnCredentialOrderByWithRelationInput
    capabilities?: TenantCapabilityOrderByRelationAggregateInput
    printAudits?: PrintAuditOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    status?: EnumTenantStatusFilter<"Tenant"> | $Enums.TenantStatus
    tier?: EnumLicenseTierFilter<"Tenant"> | $Enums.LicenseTier
    settings?: JsonFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFilter<"Tenant"> | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFilter<"Tenant"> | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFilter<"Tenant"> | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFilter<"Tenant"> | boolean
    users?: UserListRelationFilter
    products?: ProductListRelationFilter
    categories?: CategoryListRelationFilter
    customers?: CustomerListRelationFilter
    suppliers?: SupplierListRelationFilter
    warehouses?: WarehouseListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    licenses?: LicenseListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    assets?: AssetListRelationFilter
    roles?: RoleListRelationFilter
    eInvoices?: EInvoiceListRelationFilter
    lhdnToken?: XOR<LhdnTokenNullableScalarRelationFilter, LhdnTokenWhereInput> | null
    lhdnCredential?: XOR<LhdnCredentialNullableScalarRelationFilter, LhdnCredentialWhereInput> | null
    capabilities?: TenantCapabilityListRelationFilter
    printAudits?: PrintAuditListRelationFilter
  }, "id" | "slug" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrderInput | SortOrder
    status?: SortOrder
    tier?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    authPolicyPrimary?: SortOrder
    authPolicyMfa?: SortOrder
    authPolicyIdentifier?: SortOrder
    authPolicyAllowFallback?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    status?: EnumTenantStatusWithAggregatesFilter<"Tenant"> | $Enums.TenantStatus
    tier?: EnumLicenseTierWithAggregatesFilter<"Tenant"> | $Enums.LicenseTier
    settings?: JsonWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryWithAggregatesFilter<"Tenant"> | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaWithAggregatesFilter<"Tenant"> | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierWithAggregatesFilter<"Tenant"> | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolWithAggregatesFilter<"Tenant"> | boolean
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    tenantId?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    roleId?: UuidNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    failedLogins?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    customRole?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    ordersCreated?: OrderListRelationFilter
    ordersApproved?: OrderListRelationFilter
    invoicesCreated?: InvoiceListRelationFilter
    paymentsReceived?: PaymentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    printAudits?: PrintAuditListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    roleId?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    customRole?: RoleOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    ordersCreated?: OrderOrderByRelationAggregateInput
    ordersApproved?: OrderOrderByRelationAggregateInput
    invoicesCreated?: InvoiceOrderByRelationAggregateInput
    paymentsReceived?: PaymentOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    printAudits?: PrintAuditOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: UserTenantIdEmailCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    roleId?: UuidNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    failedLogins?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    customRole?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    ordersCreated?: OrderListRelationFilter
    ordersApproved?: OrderListRelationFilter
    invoicesCreated?: InvoiceListRelationFilter
    paymentsReceived?: PaymentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    printAudits?: PrintAuditListRelationFilter
  }, "id" | "tenantId_email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    roleId?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    tenantId?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    roleId?: UuidNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"User"> | string | null
    failedLogins?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: UuidFilter<"RefreshToken"> | string
    userId?: UuidFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: UuidFilter<"RefreshToken"> | string
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RefreshToken"> | string
    userId?: UuidWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userAgent?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type PlatformAdminWhereInput = {
    AND?: PlatformAdminWhereInput | PlatformAdminWhereInput[]
    OR?: PlatformAdminWhereInput[]
    NOT?: PlatformAdminWhereInput | PlatformAdminWhereInput[]
    id?: UuidFilter<"PlatformAdmin"> | string
    email?: StringFilter<"PlatformAdmin"> | string
    name?: StringFilter<"PlatformAdmin"> | string
    password?: StringFilter<"PlatformAdmin"> | string
    role?: StringFilter<"PlatformAdmin"> | string
    department?: StringNullableFilter<"PlatformAdmin"> | string | null
    avatar?: StringNullableFilter<"PlatformAdmin"> | string | null
    isActive?: BoolFilter<"PlatformAdmin"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"PlatformAdmin"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"PlatformAdmin"> | string | null
    failedLogins?: IntFilter<"PlatformAdmin"> | number
    lockedUntil?: DateTimeNullableFilter<"PlatformAdmin"> | Date | string | null
    createdAt?: DateTimeFilter<"PlatformAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformAdmin"> | Date | string
    refreshTokens?: PlatformAdminRefreshTokenListRelationFilter
  }

  export type PlatformAdminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refreshTokens?: PlatformAdminRefreshTokenOrderByRelationAggregateInput
  }

  export type PlatformAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: PlatformAdminWhereInput | PlatformAdminWhereInput[]
    OR?: PlatformAdminWhereInput[]
    NOT?: PlatformAdminWhereInput | PlatformAdminWhereInput[]
    name?: StringFilter<"PlatformAdmin"> | string
    password?: StringFilter<"PlatformAdmin"> | string
    role?: StringFilter<"PlatformAdmin"> | string
    department?: StringNullableFilter<"PlatformAdmin"> | string | null
    avatar?: StringNullableFilter<"PlatformAdmin"> | string | null
    isActive?: BoolFilter<"PlatformAdmin"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"PlatformAdmin"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"PlatformAdmin"> | string | null
    failedLogins?: IntFilter<"PlatformAdmin"> | number
    lockedUntil?: DateTimeNullableFilter<"PlatformAdmin"> | Date | string | null
    createdAt?: DateTimeFilter<"PlatformAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformAdmin"> | Date | string
    refreshTokens?: PlatformAdminRefreshTokenListRelationFilter
  }, "id" | "email">

  export type PlatformAdminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformAdminCountOrderByAggregateInput
    _avg?: PlatformAdminAvgOrderByAggregateInput
    _max?: PlatformAdminMaxOrderByAggregateInput
    _min?: PlatformAdminMinOrderByAggregateInput
    _sum?: PlatformAdminSumOrderByAggregateInput
  }

  export type PlatformAdminScalarWhereWithAggregatesInput = {
    AND?: PlatformAdminScalarWhereWithAggregatesInput | PlatformAdminScalarWhereWithAggregatesInput[]
    OR?: PlatformAdminScalarWhereWithAggregatesInput[]
    NOT?: PlatformAdminScalarWhereWithAggregatesInput | PlatformAdminScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlatformAdmin"> | string
    email?: StringWithAggregatesFilter<"PlatformAdmin"> | string
    name?: StringWithAggregatesFilter<"PlatformAdmin"> | string
    password?: StringWithAggregatesFilter<"PlatformAdmin"> | string
    role?: StringWithAggregatesFilter<"PlatformAdmin"> | string
    department?: StringNullableWithAggregatesFilter<"PlatformAdmin"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"PlatformAdmin"> | string | null
    isActive?: BoolWithAggregatesFilter<"PlatformAdmin"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"PlatformAdmin"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"PlatformAdmin"> | string | null
    failedLogins?: IntWithAggregatesFilter<"PlatformAdmin"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"PlatformAdmin"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlatformAdmin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformAdmin"> | Date | string
  }

  export type PlatformAdminRefreshTokenWhereInput = {
    AND?: PlatformAdminRefreshTokenWhereInput | PlatformAdminRefreshTokenWhereInput[]
    OR?: PlatformAdminRefreshTokenWhereInput[]
    NOT?: PlatformAdminRefreshTokenWhereInput | PlatformAdminRefreshTokenWhereInput[]
    id?: UuidFilter<"PlatformAdminRefreshToken"> | string
    adminId?: UuidFilter<"PlatformAdminRefreshToken"> | string
    token?: StringFilter<"PlatformAdminRefreshToken"> | string
    userAgent?: StringNullableFilter<"PlatformAdminRefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"PlatformAdminRefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"PlatformAdminRefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"PlatformAdminRefreshToken"> | Date | string
    admin?: XOR<PlatformAdminScalarRelationFilter, PlatformAdminWhereInput>
  }

  export type PlatformAdminRefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    admin?: PlatformAdminOrderByWithRelationInput
  }

  export type PlatformAdminRefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PlatformAdminRefreshTokenWhereInput | PlatformAdminRefreshTokenWhereInput[]
    OR?: PlatformAdminRefreshTokenWhereInput[]
    NOT?: PlatformAdminRefreshTokenWhereInput | PlatformAdminRefreshTokenWhereInput[]
    adminId?: UuidFilter<"PlatformAdminRefreshToken"> | string
    userAgent?: StringNullableFilter<"PlatformAdminRefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"PlatformAdminRefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"PlatformAdminRefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"PlatformAdminRefreshToken"> | Date | string
    admin?: XOR<PlatformAdminScalarRelationFilter, PlatformAdminWhereInput>
  }, "id" | "token">

  export type PlatformAdminRefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: PlatformAdminRefreshTokenCountOrderByAggregateInput
    _max?: PlatformAdminRefreshTokenMaxOrderByAggregateInput
    _min?: PlatformAdminRefreshTokenMinOrderByAggregateInput
  }

  export type PlatformAdminRefreshTokenScalarWhereWithAggregatesInput = {
    AND?: PlatformAdminRefreshTokenScalarWhereWithAggregatesInput | PlatformAdminRefreshTokenScalarWhereWithAggregatesInput[]
    OR?: PlatformAdminRefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: PlatformAdminRefreshTokenScalarWhereWithAggregatesInput | PlatformAdminRefreshTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlatformAdminRefreshToken"> | string
    adminId?: UuidWithAggregatesFilter<"PlatformAdminRefreshToken"> | string
    token?: StringWithAggregatesFilter<"PlatformAdminRefreshToken"> | string
    userAgent?: StringNullableWithAggregatesFilter<"PlatformAdminRefreshToken"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PlatformAdminRefreshToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"PlatformAdminRefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PlatformAdminRefreshToken"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: UuidFilter<"Role"> | string
    tenantId?: UuidFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    displayName?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    color?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    users?: UserListRelationFilter
    permissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    permissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_name?: RoleTenantIdNameCompoundUniqueInput
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    tenantId?: UuidFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    displayName?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    color?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    users?: UserListRelationFilter
    permissions?: RolePermissionListRelationFilter
  }, "id" | "tenantId_name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Role"> | string
    tenantId?: UuidWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    displayName?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    color?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    isActive?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: UuidFilter<"Permission"> | string
    code?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    sortOrder?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    module?: SortOrder
    action?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    sortOrder?: IntFilter<"Permission"> | number
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "code">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    module?: SortOrder
    action?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Permission"> | string
    code?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    module?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    sortOrder?: IntWithAggregatesFilter<"Permission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: UuidFilter<"RolePermission"> | string
    roleId?: UuidFilter<"RolePermission"> | string
    permissionId?: UuidFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: UuidFilter<"RolePermission"> | string
    permissionId?: UuidFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RolePermission"> | string
    roleId?: UuidWithAggregatesFilter<"RolePermission"> | string
    permissionId?: UuidWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type LicenseWhereInput = {
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    id?: UuidFilter<"License"> | string
    tenantId?: UuidFilter<"License"> | string
    tier?: EnumLicenseTierFilter<"License"> | $Enums.LicenseTier
    licenseKey?: StringFilter<"License"> | string
    features?: JsonFilter<"License">
    maxUsers?: IntFilter<"License"> | number
    maxProducts?: IntNullableFilter<"License"> | number | null
    startsAt?: DateTimeFilter<"License"> | Date | string
    expiresAt?: DateTimeFilter<"License"> | Date | string
    isActive?: BoolFilter<"License"> | boolean
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type LicenseOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tier?: SortOrder
    licenseKey?: SortOrder
    features?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrderInput | SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type LicenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    licenseKey?: string
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    tenantId?: UuidFilter<"License"> | string
    tier?: EnumLicenseTierFilter<"License"> | $Enums.LicenseTier
    features?: JsonFilter<"License">
    maxUsers?: IntFilter<"License"> | number
    maxProducts?: IntNullableFilter<"License"> | number | null
    startsAt?: DateTimeFilter<"License"> | Date | string
    expiresAt?: DateTimeFilter<"License"> | Date | string
    isActive?: BoolFilter<"License"> | boolean
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "licenseKey">

  export type LicenseOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tier?: SortOrder
    licenseKey?: SortOrder
    features?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrderInput | SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LicenseCountOrderByAggregateInput
    _avg?: LicenseAvgOrderByAggregateInput
    _max?: LicenseMaxOrderByAggregateInput
    _min?: LicenseMinOrderByAggregateInput
    _sum?: LicenseSumOrderByAggregateInput
  }

  export type LicenseScalarWhereWithAggregatesInput = {
    AND?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    OR?: LicenseScalarWhereWithAggregatesInput[]
    NOT?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"License"> | string
    tenantId?: UuidWithAggregatesFilter<"License"> | string
    tier?: EnumLicenseTierWithAggregatesFilter<"License"> | $Enums.LicenseTier
    licenseKey?: StringWithAggregatesFilter<"License"> | string
    features?: JsonWithAggregatesFilter<"License">
    maxUsers?: IntWithAggregatesFilter<"License"> | number
    maxProducts?: IntNullableWithAggregatesFilter<"License"> | number | null
    startsAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
    isActive?: BoolWithAggregatesFilter<"License"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: UuidFilter<"Category"> | string
    tenantId?: UuidFilter<"Category"> | string
    parentId?: UuidNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    image?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_slug?: CategoryTenantIdSlugCompoundUniqueInput
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    tenantId?: UuidFilter<"Category"> | string
    parentId?: UuidNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    image?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }, "id" | "tenantId_slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Category"> | string
    tenantId?: UuidWithAggregatesFilter<"Category"> | string
    parentId?: UuidNullableWithAggregatesFilter<"Category"> | string | null
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    image?: StringNullableWithAggregatesFilter<"Category"> | string | null
    sortOrder?: IntWithAggregatesFilter<"Category"> | number
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    tenantId?: UuidFilter<"Product"> | string
    categoryId?: UuidNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    minStock?: IntFilter<"Product"> | number
    maxStock?: IntFilter<"Product"> | number
    reorderPoint?: IntFilter<"Product"> | number
    reorderQty?: IntFilter<"Product"> | number
    weight?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"Product">
    images?: JsonFilter<"Product">
    attributes?: JsonFilter<"Product">
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    inventoryItems?: InventoryItemListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    orderItems?: OrderItemListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
    supplierProducts?: SupplierProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    taxRate?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    images?: SortOrder
    attributes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    supplierProducts?: SupplierProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_sku?: ProductTenantIdSkuCompoundUniqueInput
    tenantId_barcode?: ProductTenantIdBarcodeCompoundUniqueInput
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    tenantId?: UuidFilter<"Product"> | string
    categoryId?: UuidNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    minStock?: IntFilter<"Product"> | number
    maxStock?: IntFilter<"Product"> | number
    reorderPoint?: IntFilter<"Product"> | number
    reorderQty?: IntFilter<"Product"> | number
    weight?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"Product">
    images?: JsonFilter<"Product">
    attributes?: JsonFilter<"Product">
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    inventoryItems?: InventoryItemListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    orderItems?: OrderItemListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
    supplierProducts?: SupplierProductListRelationFilter
  }, "id" | "tenantId_sku" | "tenantId_barcode">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    unit?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    taxRate?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    images?: SortOrder
    attributes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    tenantId?: UuidWithAggregatesFilter<"Product"> | string
    categoryId?: UuidNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringWithAggregatesFilter<"Product"> | string
    barcode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    unit?: StringWithAggregatesFilter<"Product"> | string
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    minStock?: IntWithAggregatesFilter<"Product"> | number
    maxStock?: IntWithAggregatesFilter<"Product"> | number
    reorderPoint?: IntWithAggregatesFilter<"Product"> | number
    reorderQty?: IntWithAggregatesFilter<"Product"> | number
    weight?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableWithAggregatesFilter<"Product">
    images?: JsonWithAggregatesFilter<"Product">
    attributes?: JsonWithAggregatesFilter<"Product">
    status?: EnumProductStatusWithAggregatesFilter<"Product"> | $Enums.ProductStatus
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: UuidFilter<"Warehouse"> | string
    tenantId?: UuidFilter<"Warehouse"> | string
    code?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    email?: StringNullableFilter<"Warehouse"> | string | null
    manager?: StringNullableFilter<"Warehouse"> | string | null
    type?: EnumWarehouseTypeFilter<"Warehouse"> | $Enums.WarehouseType
    isDefault?: BoolFilter<"Warehouse"> | boolean
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Warehouse"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    inventoryItems?: InventoryItemListRelationFilter
    movementsFrom?: InventoryMovementListRelationFilter
    movementsTo?: InventoryMovementListRelationFilter
    ordersShipFrom?: OrderListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    manager?: SortOrderInput | SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    movementsFrom?: InventoryMovementOrderByRelationAggregateInput
    movementsTo?: InventoryMovementOrderByRelationAggregateInput
    ordersShipFrom?: OrderOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_code?: WarehouseTenantIdCodeCompoundUniqueInput
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    tenantId?: UuidFilter<"Warehouse"> | string
    code?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    email?: StringNullableFilter<"Warehouse"> | string | null
    manager?: StringNullableFilter<"Warehouse"> | string | null
    type?: EnumWarehouseTypeFilter<"Warehouse"> | $Enums.WarehouseType
    isDefault?: BoolFilter<"Warehouse"> | boolean
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Warehouse"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    inventoryItems?: InventoryItemListRelationFilter
    movementsFrom?: InventoryMovementListRelationFilter
    movementsTo?: InventoryMovementListRelationFilter
    ordersShipFrom?: OrderListRelationFilter
  }, "id" | "tenantId_code">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    manager?: SortOrderInput | SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Warehouse"> | string
    tenantId?: UuidWithAggregatesFilter<"Warehouse"> | string
    code?: StringWithAggregatesFilter<"Warehouse"> | string
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    address?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    email?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    manager?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    type?: EnumWarehouseTypeWithAggregatesFilter<"Warehouse"> | $Enums.WarehouseType
    isDefault?: BoolWithAggregatesFilter<"Warehouse"> | boolean
    isActive?: BoolWithAggregatesFilter<"Warehouse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Warehouse"> | Date | string | null
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: UuidFilter<"InventoryItem"> | string
    tenantId?: UuidFilter<"InventoryItem"> | string
    productId?: UuidFilter<"InventoryItem"> | string
    warehouseId?: UuidFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQty?: IntFilter<"InventoryItem"> | number
    availableQty?: IntFilter<"InventoryItem"> | number
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    costPrice?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    reservedQty?: SortOrder
    availableQty?: SortOrder
    batchNumber?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    costPrice?: SortOrderInput | SortOrder
    lastCountedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_productId_warehouseId_batchNumber?: InventoryItemTenantIdProductIdWarehouseIdBatchNumberCompoundUniqueInput
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    tenantId?: UuidFilter<"InventoryItem"> | string
    productId?: UuidFilter<"InventoryItem"> | string
    warehouseId?: UuidFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQty?: IntFilter<"InventoryItem"> | number
    availableQty?: IntFilter<"InventoryItem"> | number
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    costPrice?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }, "id" | "tenantId_productId_warehouseId_batchNumber">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    reservedQty?: SortOrder
    availableQty?: SortOrder
    batchNumber?: SortOrderInput | SortOrder
    lotNumber?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    costPrice?: SortOrderInput | SortOrder
    lastCountedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InventoryItem"> | string
    tenantId?: UuidWithAggregatesFilter<"InventoryItem"> | string
    productId?: UuidWithAggregatesFilter<"InventoryItem"> | string
    warehouseId?: UuidWithAggregatesFilter<"InventoryItem"> | string
    quantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    reservedQty?: IntWithAggregatesFilter<"InventoryItem"> | number
    availableQty?: IntWithAggregatesFilter<"InventoryItem"> | number
    batchNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"InventoryItem"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    costPrice?: DecimalNullableWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: DateTimeNullableWithAggregatesFilter<"InventoryItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: UuidFilter<"InventoryMovement"> | string
    tenantId?: UuidFilter<"InventoryMovement"> | string
    productId?: UuidFilter<"InventoryMovement"> | string
    fromWarehouseId?: UuidNullableFilter<"InventoryMovement"> | string | null
    toWarehouseId?: UuidNullableFilter<"InventoryMovement"> | string | null
    userId?: UuidFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    unitCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceType?: StringNullableFilter<"InventoryMovement"> | string | null
    batchNumber?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    fromWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    toWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    fromWarehouseId?: SortOrderInput | SortOrder
    toWarehouseId?: SortOrderInput | SortOrder
    userId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    fromWarehouse?: WarehouseOrderByWithRelationInput
    toWarehouse?: WarehouseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    tenantId?: UuidFilter<"InventoryMovement"> | string
    productId?: UuidFilter<"InventoryMovement"> | string
    fromWarehouseId?: UuidNullableFilter<"InventoryMovement"> | string | null
    toWarehouseId?: UuidNullableFilter<"InventoryMovement"> | string | null
    userId?: UuidFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    unitCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceType?: StringNullableFilter<"InventoryMovement"> | string | null
    batchNumber?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    fromWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    toWarehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    fromWarehouseId?: SortOrderInput | SortOrder
    toWarehouseId?: SortOrderInput | SortOrder
    userId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    referenceType?: SortOrderInput | SortOrder
    batchNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InventoryMovement"> | string
    tenantId?: UuidWithAggregatesFilter<"InventoryMovement"> | string
    productId?: UuidWithAggregatesFilter<"InventoryMovement"> | string
    fromWarehouseId?: UuidNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    toWarehouseId?: UuidNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    userId?: UuidWithAggregatesFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeWithAggregatesFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: IntWithAggregatesFilter<"InventoryMovement"> | number
    unitCost?: DecimalNullableWithAggregatesFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableWithAggregatesFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    reference?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    referenceType?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    batchNumber?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: UuidFilter<"Customer"> | string
    tenantId?: UuidFilter<"Customer"> | string
    code?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    mobile?: StringNullableFilter<"Customer"> | string | null
    fax?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    taxId?: StringNullableFilter<"Customer"> | string | null
    billingAddress?: JsonNullableFilter<"Customer">
    shippingAddress?: JsonNullableFilter<"Customer">
    paymentTerms?: IntFilter<"Customer"> | number
    creditLimit?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Customer"> | string | null
    tags?: JsonFilter<"Customer">
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_code?: CustomerTenantIdCodeCompoundUniqueInput
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    tenantId?: UuidFilter<"Customer"> | string
    code?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    mobile?: StringNullableFilter<"Customer"> | string | null
    fax?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    taxId?: StringNullableFilter<"Customer"> | string | null
    billingAddress?: JsonNullableFilter<"Customer">
    shippingAddress?: JsonNullableFilter<"Customer">
    paymentTerms?: IntFilter<"Customer"> | number
    creditLimit?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Customer"> | string | null
    tags?: JsonFilter<"Customer">
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "tenantId_code">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Customer"> | string
    tenantId?: UuidWithAggregatesFilter<"Customer"> | string
    code?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    type?: EnumCustomerTypeWithAggregatesFilter<"Customer"> | $Enums.CustomerType
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    fax?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    website?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    billingAddress?: JsonNullableWithAggregatesFilter<"Customer">
    shippingAddress?: JsonNullableWithAggregatesFilter<"Customer">
    paymentTerms?: IntWithAggregatesFilter<"Customer"> | number
    creditLimit?: DecimalWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    tags?: JsonWithAggregatesFilter<"Customer">
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: UuidFilter<"Supplier"> | string
    tenantId?: UuidFilter<"Supplier"> | string
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    mobile?: StringNullableFilter<"Supplier"> | string | null
    fax?: StringNullableFilter<"Supplier"> | string | null
    website?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    address?: JsonNullableFilter<"Supplier">
    bankDetails?: JsonNullableFilter<"Supplier">
    paymentTerms?: IntFilter<"Supplier"> | number
    currency?: StringFilter<"Supplier"> | string
    leadTime?: IntFilter<"Supplier"> | number
    minimumOrder?: DecimalFilter<"Supplier"> | Decimal | DecimalJsLike | number | string
    rating?: IntNullableFilter<"Supplier"> | number | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    tags?: JsonFilter<"Supplier">
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
    supplierProducts?: SupplierProductListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bankDetails?: SortOrderInput | SortOrder
    paymentTerms?: SortOrder
    currency?: SortOrder
    leadTime?: SortOrder
    minimumOrder?: SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    supplierProducts?: SupplierProductOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_code?: SupplierTenantIdCodeCompoundUniqueInput
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    tenantId?: UuidFilter<"Supplier"> | string
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    mobile?: StringNullableFilter<"Supplier"> | string | null
    fax?: StringNullableFilter<"Supplier"> | string | null
    website?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    address?: JsonNullableFilter<"Supplier">
    bankDetails?: JsonNullableFilter<"Supplier">
    paymentTerms?: IntFilter<"Supplier"> | number
    currency?: StringFilter<"Supplier"> | string
    leadTime?: IntFilter<"Supplier"> | number
    minimumOrder?: DecimalFilter<"Supplier"> | Decimal | DecimalJsLike | number | string
    rating?: IntNullableFilter<"Supplier"> | number | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    tags?: JsonFilter<"Supplier">
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    orders?: OrderListRelationFilter
    supplierProducts?: SupplierProductListRelationFilter
  }, "id" | "tenantId_code">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    bankDetails?: SortOrderInput | SortOrder
    paymentTerms?: SortOrder
    currency?: SortOrder
    leadTime?: SortOrder
    minimumOrder?: SortOrder
    rating?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Supplier"> | string
    tenantId?: UuidWithAggregatesFilter<"Supplier"> | string
    code?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contactPerson?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    fax?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    website?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: JsonNullableWithAggregatesFilter<"Supplier">
    bankDetails?: JsonNullableWithAggregatesFilter<"Supplier">
    paymentTerms?: IntWithAggregatesFilter<"Supplier"> | number
    currency?: StringWithAggregatesFilter<"Supplier"> | string
    leadTime?: IntWithAggregatesFilter<"Supplier"> | number
    minimumOrder?: DecimalWithAggregatesFilter<"Supplier"> | Decimal | DecimalJsLike | number | string
    rating?: IntNullableWithAggregatesFilter<"Supplier"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    tags?: JsonWithAggregatesFilter<"Supplier">
    isActive?: BoolWithAggregatesFilter<"Supplier"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Supplier"> | Date | string | null
  }

  export type SupplierProductWhereInput = {
    AND?: SupplierProductWhereInput | SupplierProductWhereInput[]
    OR?: SupplierProductWhereInput[]
    NOT?: SupplierProductWhereInput | SupplierProductWhereInput[]
    id?: UuidFilter<"SupplierProduct"> | string
    tenantId?: UuidFilter<"SupplierProduct"> | string
    supplierId?: UuidFilter<"SupplierProduct"> | string
    productId?: UuidFilter<"SupplierProduct"> | string
    supplierSku?: StringNullableFilter<"SupplierProduct"> | string | null
    unitPrice?: DecimalFilter<"SupplierProduct"> | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFilter<"SupplierProduct"> | number
    leadTime?: IntNullableFilter<"SupplierProduct"> | number | null
    isPreferred?: BoolFilter<"SupplierProduct"> | boolean
    lastOrderAt?: DateTimeNullableFilter<"SupplierProduct"> | Date | string | null
    createdAt?: DateTimeFilter<"SupplierProduct"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierProduct"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type SupplierProductOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    supplierSku?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    minOrderQty?: SortOrder
    leadTime?: SortOrderInput | SortOrder
    isPreferred?: SortOrder
    lastOrderAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SupplierProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_supplierId_productId?: SupplierProductTenantIdSupplierIdProductIdCompoundUniqueInput
    AND?: SupplierProductWhereInput | SupplierProductWhereInput[]
    OR?: SupplierProductWhereInput[]
    NOT?: SupplierProductWhereInput | SupplierProductWhereInput[]
    tenantId?: UuidFilter<"SupplierProduct"> | string
    supplierId?: UuidFilter<"SupplierProduct"> | string
    productId?: UuidFilter<"SupplierProduct"> | string
    supplierSku?: StringNullableFilter<"SupplierProduct"> | string | null
    unitPrice?: DecimalFilter<"SupplierProduct"> | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFilter<"SupplierProduct"> | number
    leadTime?: IntNullableFilter<"SupplierProduct"> | number | null
    isPreferred?: BoolFilter<"SupplierProduct"> | boolean
    lastOrderAt?: DateTimeNullableFilter<"SupplierProduct"> | Date | string | null
    createdAt?: DateTimeFilter<"SupplierProduct"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierProduct"> | Date | string
    supplier?: XOR<SupplierScalarRelationFilter, SupplierWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "tenantId_supplierId_productId">

  export type SupplierProductOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    supplierSku?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    minOrderQty?: SortOrder
    leadTime?: SortOrderInput | SortOrder
    isPreferred?: SortOrder
    lastOrderAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierProductCountOrderByAggregateInput
    _avg?: SupplierProductAvgOrderByAggregateInput
    _max?: SupplierProductMaxOrderByAggregateInput
    _min?: SupplierProductMinOrderByAggregateInput
    _sum?: SupplierProductSumOrderByAggregateInput
  }

  export type SupplierProductScalarWhereWithAggregatesInput = {
    AND?: SupplierProductScalarWhereWithAggregatesInput | SupplierProductScalarWhereWithAggregatesInput[]
    OR?: SupplierProductScalarWhereWithAggregatesInput[]
    NOT?: SupplierProductScalarWhereWithAggregatesInput | SupplierProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SupplierProduct"> | string
    tenantId?: UuidWithAggregatesFilter<"SupplierProduct"> | string
    supplierId?: UuidWithAggregatesFilter<"SupplierProduct"> | string
    productId?: UuidWithAggregatesFilter<"SupplierProduct"> | string
    supplierSku?: StringNullableWithAggregatesFilter<"SupplierProduct"> | string | null
    unitPrice?: DecimalWithAggregatesFilter<"SupplierProduct"> | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntWithAggregatesFilter<"SupplierProduct"> | number
    leadTime?: IntNullableWithAggregatesFilter<"SupplierProduct"> | number | null
    isPreferred?: BoolWithAggregatesFilter<"SupplierProduct"> | boolean
    lastOrderAt?: DateTimeNullableWithAggregatesFilter<"SupplierProduct"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupplierProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierProduct"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: UuidFilter<"Order"> | string
    tenantId?: UuidFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    type?: EnumOrderTypeFilter<"Order"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    customerId?: UuidNullableFilter<"Order"> | string | null
    supplierId?: UuidNullableFilter<"Order"> | string | null
    warehouseId?: UuidNullableFilter<"Order"> | string | null
    createdById?: UuidFilter<"Order"> | string
    approvedById?: UuidNullableFilter<"Order"> | string | null
    orderDate?: DateTimeFilter<"Order"> | Date | string
    expectedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    shippedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    shippingAddress?: JsonNullableFilter<"Order">
    billingAddress?: JsonNullableFilter<"Order">
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountType?: StringNullableFilter<"Order"> | string | null
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Order"> | string
    exchangeRate?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    paymentTerms?: IntNullableFilter<"Order"> | number | null
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    tags?: JsonFilter<"Order">
    metadata?: JsonFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: OrderItemListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    customerId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    warehouseId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrderInput | SortOrder
    shippedDate?: SortOrderInput | SortOrder
    deliveredDate?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    shippingCost?: SortOrder
    discount?: SortOrder
    discountType?: SortOrderInput | SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_orderNumber?: OrderTenantIdOrderNumberCompoundUniqueInput
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    tenantId?: UuidFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    type?: EnumOrderTypeFilter<"Order"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    customerId?: UuidNullableFilter<"Order"> | string | null
    supplierId?: UuidNullableFilter<"Order"> | string | null
    warehouseId?: UuidNullableFilter<"Order"> | string | null
    createdById?: UuidFilter<"Order"> | string
    approvedById?: UuidNullableFilter<"Order"> | string | null
    orderDate?: DateTimeFilter<"Order"> | Date | string
    expectedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    shippedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    shippingAddress?: JsonNullableFilter<"Order">
    billingAddress?: JsonNullableFilter<"Order">
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountType?: StringNullableFilter<"Order"> | string | null
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Order"> | string
    exchangeRate?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    paymentTerms?: IntNullableFilter<"Order"> | number | null
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    tags?: JsonFilter<"Order">
    metadata?: JsonFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    supplier?: XOR<SupplierNullableScalarRelationFilter, SupplierWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    items?: OrderItemListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "tenantId_orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    customerId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    warehouseId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrderInput | SortOrder
    shippedDate?: SortOrderInput | SortOrder
    deliveredDate?: SortOrderInput | SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    billingAddress?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    shippingCost?: SortOrder
    discount?: SortOrder
    discountType?: SortOrderInput | SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Order"> | string
    tenantId?: UuidWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    type?: EnumOrderTypeWithAggregatesFilter<"Order"> | $Enums.OrderType
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    customerId?: UuidNullableWithAggregatesFilter<"Order"> | string | null
    supplierId?: UuidNullableWithAggregatesFilter<"Order"> | string | null
    warehouseId?: UuidNullableWithAggregatesFilter<"Order"> | string | null
    createdById?: UuidWithAggregatesFilter<"Order"> | string
    approvedById?: UuidNullableWithAggregatesFilter<"Order"> | string | null
    orderDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    expectedDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    shippedDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveredDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    shippingAddress?: JsonNullableWithAggregatesFilter<"Order">
    billingAddress?: JsonNullableWithAggregatesFilter<"Order">
    subtotal?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountType?: StringNullableWithAggregatesFilter<"Order"> | string | null
    total?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Order"> | string
    exchangeRate?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    paymentTerms?: IntNullableWithAggregatesFilter<"Order"> | number | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    internalNotes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    tags?: JsonWithAggregatesFilter<"Order">
    metadata?: JsonWithAggregatesFilter<"Order">
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: UuidFilter<"OrderItem"> | string
    orderId?: UuidFilter<"OrderItem"> | string
    productId?: UuidFilter<"OrderItem"> | string
    sku?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    shippedQty?: IntFilter<"OrderItem"> | number
    receivedQty?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    discountType?: StringNullableFilter<"OrderItem"> | string | null
    taxRate?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"OrderItem"> | string | null
    sortOrder?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    shippedQty?: SortOrder
    receivedQty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    discount?: SortOrder
    discountType?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: UuidFilter<"OrderItem"> | string
    productId?: UuidFilter<"OrderItem"> | string
    sku?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    shippedQty?: IntFilter<"OrderItem"> | number
    receivedQty?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    discountType?: StringNullableFilter<"OrderItem"> | string | null
    taxRate?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"OrderItem"> | string | null
    sortOrder?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    shippedQty?: SortOrder
    receivedQty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrderInput | SortOrder
    discount?: SortOrder
    discountType?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OrderItem"> | string
    orderId?: UuidWithAggregatesFilter<"OrderItem"> | string
    productId?: UuidWithAggregatesFilter<"OrderItem"> | string
    sku?: StringWithAggregatesFilter<"OrderItem"> | string
    name?: StringWithAggregatesFilter<"OrderItem"> | string
    description?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    shippedQty?: IntWithAggregatesFilter<"OrderItem"> | number
    receivedQty?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    discountType?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    taxRate?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    sortOrder?: IntWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    tenantId?: UuidFilter<"Invoice"> | string
    orderId?: UuidNullableFilter<"Invoice"> | string | null
    customerId?: UuidFilter<"Invoice"> | string
    createdById?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    exchangeRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    terms?: StringNullableFilter<"Invoice"> | string | null
    footer?: StringNullableFilter<"Invoice"> | string | null
    metadata?: JsonFilter<"Invoice">
    sentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    viewedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
    eInvoices?: EInvoiceListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    notes?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    footer?: SortOrderInput | SortOrder
    metadata?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    viewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    eInvoices?: EInvoiceOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_invoiceNumber?: InvoiceTenantIdInvoiceNumberCompoundUniqueInput
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    tenantId?: UuidFilter<"Invoice"> | string
    orderId?: UuidNullableFilter<"Invoice"> | string | null
    customerId?: UuidFilter<"Invoice"> | string
    createdById?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    exchangeRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    terms?: StringNullableFilter<"Invoice"> | string | null
    footer?: StringNullableFilter<"Invoice"> | string | null
    metadata?: JsonFilter<"Invoice">
    sentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    viewedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    items?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
    eInvoices?: EInvoiceListRelationFilter
  }, "id" | "tenantId_invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    notes?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    footer?: SortOrderInput | SortOrder
    metadata?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    viewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Invoice"> | string
    tenantId?: UuidWithAggregatesFilter<"Invoice"> | string
    orderId?: UuidNullableWithAggregatesFilter<"Invoice"> | string | null
    customerId?: UuidWithAggregatesFilter<"Invoice"> | string
    createdById?: UuidWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    type?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    exchangeRate?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    terms?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    footer?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    metadata?: JsonWithAggregatesFilter<"Invoice">
    sentAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    viewedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: UuidFilter<"InvoiceItem"> | string
    invoiceId?: UuidFilter<"InvoiceItem"> | string
    productId?: UuidNullableFilter<"InvoiceItem"> | string | null
    sku?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    description?: StringNullableFilter<"InvoiceItem"> | string | null
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    eInvoiceItems?: EInvoiceItemListRelationFilter
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    eInvoiceItems?: EInvoiceItemOrderByRelationAggregateInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: UuidFilter<"InvoiceItem"> | string
    productId?: UuidNullableFilter<"InvoiceItem"> | string | null
    sku?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    description?: StringNullableFilter<"InvoiceItem"> | string | null
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    eInvoiceItems?: EInvoiceItemListRelationFilter
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: UuidWithAggregatesFilter<"InvoiceItem"> | string
    productId?: UuidNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    sku?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    name?: StringWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    sortOrder?: IntWithAggregatesFilter<"InvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    tenantId?: UuidFilter<"Payment"> | string
    invoiceId?: UuidNullableFilter<"Payment"> | string | null
    customerId?: UuidFilter<"Payment"> | string
    receivedById?: UuidFilter<"Payment"> | string
    paymentNumber?: StringFilter<"Payment"> | string
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    exchangeRate?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    receivedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    receivedById?: SortOrder
    paymentNumber?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    receivedBy?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_paymentNumber?: PaymentTenantIdPaymentNumberCompoundUniqueInput
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    tenantId?: UuidFilter<"Payment"> | string
    invoiceId?: UuidNullableFilter<"Payment"> | string | null
    customerId?: UuidFilter<"Payment"> | string
    receivedById?: UuidFilter<"Payment"> | string
    paymentNumber?: StringFilter<"Payment"> | string
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    exchangeRate?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    receivedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tenantId_paymentNumber">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    receivedById?: SortOrder
    paymentNumber?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    tenantId?: UuidWithAggregatesFilter<"Payment"> | string
    invoiceId?: UuidNullableWithAggregatesFilter<"Payment"> | string | null
    customerId?: UuidWithAggregatesFilter<"Payment"> | string
    receivedById?: UuidWithAggregatesFilter<"Payment"> | string
    paymentNumber?: StringWithAggregatesFilter<"Payment"> | string
    type?: EnumPaymentTypeWithAggregatesFilter<"Payment"> | $Enums.PaymentType
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    exchangeRate?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    tenantId?: UuidFilter<"AuditLog"> | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    entityName?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    changedFields?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    requestId?: StringNullableFilter<"AuditLog"> | string | null
    duration?: IntNullableFilter<"AuditLog"> | number | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityName?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    changedFields?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: UuidFilter<"AuditLog"> | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    entityName?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    changedFields?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    requestId?: StringNullableFilter<"AuditLog"> | string | null
    duration?: IntNullableFilter<"AuditLog"> | number | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    entityName?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    changedFields?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    tenantId?: UuidWithAggregatesFilter<"AuditLog"> | string
    userId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: UuidNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityName?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    changedFields?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    duration?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: UuidFilter<"Asset"> | string
    tenantId?: UuidFilter<"Asset"> | string
    assetTag?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    assetType?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    category?: EnumAssetCategoryFilter<"Asset"> | $Enums.AssetCategory
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    location?: StringFilter<"Asset"> | string
    assignedTo?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeFilter<"Asset"> | Date | string
    purchaseCost?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFilter<"Asset"> | $Enums.DepreciationMethod
    usefulLifeYears?: IntNullableFilter<"Asset"> | number | null
    salvageValue?: DecimalNullableFilter<"Asset"> | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: DateTimeNullableFilter<"Asset"> | Date | string | null
    serialNumber?: StringNullableFilter<"Asset"> | string | null
    manufacturer?: StringNullableFilter<"Asset"> | string | null
    model?: StringNullableFilter<"Asset"> | string | null
    notes?: StringNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    assetTag?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    assetType?: SortOrder
    category?: SortOrder
    status?: SortOrder
    location?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    purchaseDate?: SortOrder
    purchaseCost?: SortOrder
    currentValue?: SortOrder
    depreciationMethod?: SortOrder
    usefulLifeYears?: SortOrderInput | SortOrder
    salvageValue?: SortOrderInput | SortOrder
    warrantyExpiry?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_assetTag?: AssetTenantIdAssetTagCompoundUniqueInput
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    tenantId?: UuidFilter<"Asset"> | string
    assetTag?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    assetType?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    category?: EnumAssetCategoryFilter<"Asset"> | $Enums.AssetCategory
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    location?: StringFilter<"Asset"> | string
    assignedTo?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeFilter<"Asset"> | Date | string
    purchaseCost?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFilter<"Asset"> | $Enums.DepreciationMethod
    usefulLifeYears?: IntNullableFilter<"Asset"> | number | null
    salvageValue?: DecimalNullableFilter<"Asset"> | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: DateTimeNullableFilter<"Asset"> | Date | string | null
    serialNumber?: StringNullableFilter<"Asset"> | string | null
    manufacturer?: StringNullableFilter<"Asset"> | string | null
    model?: StringNullableFilter<"Asset"> | string | null
    notes?: StringNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_assetTag">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    assetTag?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    assetType?: SortOrder
    category?: SortOrder
    status?: SortOrder
    location?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    purchaseDate?: SortOrder
    purchaseCost?: SortOrder
    currentValue?: SortOrder
    depreciationMethod?: SortOrder
    usefulLifeYears?: SortOrderInput | SortOrder
    salvageValue?: SortOrderInput | SortOrder
    warrantyExpiry?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    manufacturer?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Asset"> | string
    tenantId?: UuidWithAggregatesFilter<"Asset"> | string
    assetTag?: StringWithAggregatesFilter<"Asset"> | string
    name?: StringWithAggregatesFilter<"Asset"> | string
    description?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    assetType?: EnumAssetTypeWithAggregatesFilter<"Asset"> | $Enums.AssetType
    category?: EnumAssetCategoryWithAggregatesFilter<"Asset"> | $Enums.AssetCategory
    status?: EnumAssetStatusWithAggregatesFilter<"Asset"> | $Enums.AssetStatus
    location?: StringWithAggregatesFilter<"Asset"> | string
    assignedTo?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    purchaseDate?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    purchaseCost?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodWithAggregatesFilter<"Asset"> | $Enums.DepreciationMethod
    usefulLifeYears?: IntNullableWithAggregatesFilter<"Asset"> | number | null
    salvageValue?: DecimalNullableWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    manufacturer?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    model?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
  }

  export type EInvoiceWhereInput = {
    AND?: EInvoiceWhereInput | EInvoiceWhereInput[]
    OR?: EInvoiceWhereInput[]
    NOT?: EInvoiceWhereInput | EInvoiceWhereInput[]
    id?: UuidFilter<"EInvoice"> | string
    tenantId?: UuidFilter<"EInvoice"> | string
    invoiceId?: UuidFilter<"EInvoice"> | string
    invoiceType?: EnumEInvoiceTypeFilter<"EInvoice"> | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFilter<"EInvoice"> | $Enums.EInvoiceStatus
    lhdnUuid?: StringNullableFilter<"EInvoice"> | string | null
    lhdnLongId?: StringNullableFilter<"EInvoice"> | string | null
    lhdnSubmissionUid?: StringNullableFilter<"EInvoice"> | string | null
    submittedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    validatedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    requestJson?: JsonNullableFilter<"EInvoice">
    responseJson?: JsonNullableFilter<"EInvoice">
    documentHash?: StringNullableFilter<"EInvoice"> | string | null
    rejectReason?: StringNullableFilter<"EInvoice"> | string | null
    validationErrors?: JsonNullableFilter<"EInvoice">
    retryCount?: IntFilter<"EInvoice"> | number
    lastRetryAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    originalEInvoiceId?: UuidNullableFilter<"EInvoice"> | string | null
    createdAt?: DateTimeFilter<"EInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"EInvoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    originalEInvoice?: XOR<EInvoiceNullableScalarRelationFilter, EInvoiceWhereInput> | null
    relatedEInvoices?: EInvoiceListRelationFilter
    items?: EInvoiceItemListRelationFilter
    logs?: EInvoiceLogListRelationFilter
  }

  export type EInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    invoiceType?: SortOrder
    status?: SortOrder
    lhdnUuid?: SortOrderInput | SortOrder
    lhdnLongId?: SortOrderInput | SortOrder
    lhdnSubmissionUid?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    requestJson?: SortOrderInput | SortOrder
    responseJson?: SortOrderInput | SortOrder
    documentHash?: SortOrderInput | SortOrder
    rejectReason?: SortOrderInput | SortOrder
    validationErrors?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    originalEInvoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    originalEInvoice?: EInvoiceOrderByWithRelationInput
    relatedEInvoices?: EInvoiceOrderByRelationAggregateInput
    items?: EInvoiceItemOrderByRelationAggregateInput
    logs?: EInvoiceLogOrderByRelationAggregateInput
  }

  export type EInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lhdnUuid?: string
    AND?: EInvoiceWhereInput | EInvoiceWhereInput[]
    OR?: EInvoiceWhereInput[]
    NOT?: EInvoiceWhereInput | EInvoiceWhereInput[]
    tenantId?: UuidFilter<"EInvoice"> | string
    invoiceId?: UuidFilter<"EInvoice"> | string
    invoiceType?: EnumEInvoiceTypeFilter<"EInvoice"> | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFilter<"EInvoice"> | $Enums.EInvoiceStatus
    lhdnLongId?: StringNullableFilter<"EInvoice"> | string | null
    lhdnSubmissionUid?: StringNullableFilter<"EInvoice"> | string | null
    submittedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    validatedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    requestJson?: JsonNullableFilter<"EInvoice">
    responseJson?: JsonNullableFilter<"EInvoice">
    documentHash?: StringNullableFilter<"EInvoice"> | string | null
    rejectReason?: StringNullableFilter<"EInvoice"> | string | null
    validationErrors?: JsonNullableFilter<"EInvoice">
    retryCount?: IntFilter<"EInvoice"> | number
    lastRetryAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    originalEInvoiceId?: UuidNullableFilter<"EInvoice"> | string | null
    createdAt?: DateTimeFilter<"EInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"EInvoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    originalEInvoice?: XOR<EInvoiceNullableScalarRelationFilter, EInvoiceWhereInput> | null
    relatedEInvoices?: EInvoiceListRelationFilter
    items?: EInvoiceItemListRelationFilter
    logs?: EInvoiceLogListRelationFilter
  }, "id" | "lhdnUuid">

  export type EInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    invoiceType?: SortOrder
    status?: SortOrder
    lhdnUuid?: SortOrderInput | SortOrder
    lhdnLongId?: SortOrderInput | SortOrder
    lhdnSubmissionUid?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    requestJson?: SortOrderInput | SortOrder
    responseJson?: SortOrderInput | SortOrder
    documentHash?: SortOrderInput | SortOrder
    rejectReason?: SortOrderInput | SortOrder
    validationErrors?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    originalEInvoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EInvoiceCountOrderByAggregateInput
    _avg?: EInvoiceAvgOrderByAggregateInput
    _max?: EInvoiceMaxOrderByAggregateInput
    _min?: EInvoiceMinOrderByAggregateInput
    _sum?: EInvoiceSumOrderByAggregateInput
  }

  export type EInvoiceScalarWhereWithAggregatesInput = {
    AND?: EInvoiceScalarWhereWithAggregatesInput | EInvoiceScalarWhereWithAggregatesInput[]
    OR?: EInvoiceScalarWhereWithAggregatesInput[]
    NOT?: EInvoiceScalarWhereWithAggregatesInput | EInvoiceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EInvoice"> | string
    tenantId?: UuidWithAggregatesFilter<"EInvoice"> | string
    invoiceId?: UuidWithAggregatesFilter<"EInvoice"> | string
    invoiceType?: EnumEInvoiceTypeWithAggregatesFilter<"EInvoice"> | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusWithAggregatesFilter<"EInvoice"> | $Enums.EInvoiceStatus
    lhdnUuid?: StringNullableWithAggregatesFilter<"EInvoice"> | string | null
    lhdnLongId?: StringNullableWithAggregatesFilter<"EInvoice"> | string | null
    lhdnSubmissionUid?: StringNullableWithAggregatesFilter<"EInvoice"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"EInvoice"> | Date | string | null
    validatedAt?: DateTimeNullableWithAggregatesFilter<"EInvoice"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"EInvoice"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"EInvoice"> | Date | string | null
    requestJson?: JsonNullableWithAggregatesFilter<"EInvoice">
    responseJson?: JsonNullableWithAggregatesFilter<"EInvoice">
    documentHash?: StringNullableWithAggregatesFilter<"EInvoice"> | string | null
    rejectReason?: StringNullableWithAggregatesFilter<"EInvoice"> | string | null
    validationErrors?: JsonNullableWithAggregatesFilter<"EInvoice">
    retryCount?: IntWithAggregatesFilter<"EInvoice"> | number
    lastRetryAt?: DateTimeNullableWithAggregatesFilter<"EInvoice"> | Date | string | null
    originalEInvoiceId?: UuidNullableWithAggregatesFilter<"EInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EInvoice"> | Date | string
  }

  export type EInvoiceItemWhereInput = {
    AND?: EInvoiceItemWhereInput | EInvoiceItemWhereInput[]
    OR?: EInvoiceItemWhereInput[]
    NOT?: EInvoiceItemWhereInput | EInvoiceItemWhereInput[]
    id?: UuidFilter<"EInvoiceItem"> | string
    eInvoiceId?: UuidFilter<"EInvoiceItem"> | string
    invoiceItemId?: UuidNullableFilter<"EInvoiceItem"> | string | null
    classificationCode?: StringFilter<"EInvoiceItem"> | string
    description?: StringFilter<"EInvoiceItem"> | string
    quantity?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitCode?: StringFilter<"EInvoiceItem"> | string
    unitPrice?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxType?: StringFilter<"EInvoiceItem"> | string
    taxRate?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxExemptReason?: StringNullableFilter<"EInvoiceItem"> | string | null
    subtotal?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFilter<"EInvoiceItem"> | number
    createdAt?: DateTimeFilter<"EInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"EInvoiceItem"> | Date | string
    eInvoice?: XOR<EInvoiceScalarRelationFilter, EInvoiceWhereInput>
    invoiceItem?: XOR<InvoiceItemNullableScalarRelationFilter, InvoiceItemWhereInput> | null
  }

  export type EInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    invoiceItemId?: SortOrderInput | SortOrder
    classificationCode?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitCode?: SortOrder
    unitPrice?: SortOrder
    taxType?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    taxExemptReason?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountRate?: SortOrder
    totalAmount?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    eInvoice?: EInvoiceOrderByWithRelationInput
    invoiceItem?: InvoiceItemOrderByWithRelationInput
  }

  export type EInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EInvoiceItemWhereInput | EInvoiceItemWhereInput[]
    OR?: EInvoiceItemWhereInput[]
    NOT?: EInvoiceItemWhereInput | EInvoiceItemWhereInput[]
    eInvoiceId?: UuidFilter<"EInvoiceItem"> | string
    invoiceItemId?: UuidNullableFilter<"EInvoiceItem"> | string | null
    classificationCode?: StringFilter<"EInvoiceItem"> | string
    description?: StringFilter<"EInvoiceItem"> | string
    quantity?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitCode?: StringFilter<"EInvoiceItem"> | string
    unitPrice?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxType?: StringFilter<"EInvoiceItem"> | string
    taxRate?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxExemptReason?: StringNullableFilter<"EInvoiceItem"> | string | null
    subtotal?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFilter<"EInvoiceItem"> | number
    createdAt?: DateTimeFilter<"EInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"EInvoiceItem"> | Date | string
    eInvoice?: XOR<EInvoiceScalarRelationFilter, EInvoiceWhereInput>
    invoiceItem?: XOR<InvoiceItemNullableScalarRelationFilter, InvoiceItemWhereInput> | null
  }, "id">

  export type EInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    invoiceItemId?: SortOrderInput | SortOrder
    classificationCode?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitCode?: SortOrder
    unitPrice?: SortOrder
    taxType?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    taxExemptReason?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountRate?: SortOrder
    totalAmount?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EInvoiceItemCountOrderByAggregateInput
    _avg?: EInvoiceItemAvgOrderByAggregateInput
    _max?: EInvoiceItemMaxOrderByAggregateInput
    _min?: EInvoiceItemMinOrderByAggregateInput
    _sum?: EInvoiceItemSumOrderByAggregateInput
  }

  export type EInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: EInvoiceItemScalarWhereWithAggregatesInput | EInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: EInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: EInvoiceItemScalarWhereWithAggregatesInput | EInvoiceItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EInvoiceItem"> | string
    eInvoiceId?: UuidWithAggregatesFilter<"EInvoiceItem"> | string
    invoiceItemId?: UuidNullableWithAggregatesFilter<"EInvoiceItem"> | string | null
    classificationCode?: StringWithAggregatesFilter<"EInvoiceItem"> | string
    description?: StringWithAggregatesFilter<"EInvoiceItem"> | string
    quantity?: DecimalWithAggregatesFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitCode?: StringWithAggregatesFilter<"EInvoiceItem"> | string
    unitPrice?: DecimalWithAggregatesFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxType?: StringWithAggregatesFilter<"EInvoiceItem"> | string
    taxRate?: DecimalWithAggregatesFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxExemptReason?: StringNullableWithAggregatesFilter<"EInvoiceItem"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalWithAggregatesFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    sortOrder?: IntWithAggregatesFilter<"EInvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EInvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EInvoiceItem"> | Date | string
  }

  export type EInvoiceLogWhereInput = {
    AND?: EInvoiceLogWhereInput | EInvoiceLogWhereInput[]
    OR?: EInvoiceLogWhereInput[]
    NOT?: EInvoiceLogWhereInput | EInvoiceLogWhereInput[]
    id?: UuidFilter<"EInvoiceLog"> | string
    eInvoiceId?: UuidFilter<"EInvoiceLog"> | string
    action?: StringFilter<"EInvoiceLog"> | string
    status?: EnumEInvoiceStatusFilter<"EInvoiceLog"> | $Enums.EInvoiceStatus
    message?: StringNullableFilter<"EInvoiceLog"> | string | null
    requestData?: JsonNullableFilter<"EInvoiceLog">
    responseData?: JsonNullableFilter<"EInvoiceLog">
    errorCode?: StringNullableFilter<"EInvoiceLog"> | string | null
    errorMessage?: StringNullableFilter<"EInvoiceLog"> | string | null
    ipAddress?: StringNullableFilter<"EInvoiceLog"> | string | null
    userAgent?: StringNullableFilter<"EInvoiceLog"> | string | null
    createdAt?: DateTimeFilter<"EInvoiceLog"> | Date | string
    eInvoice?: XOR<EInvoiceScalarRelationFilter, EInvoiceWhereInput>
  }

  export type EInvoiceLogOrderByWithRelationInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    eInvoice?: EInvoiceOrderByWithRelationInput
  }

  export type EInvoiceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EInvoiceLogWhereInput | EInvoiceLogWhereInput[]
    OR?: EInvoiceLogWhereInput[]
    NOT?: EInvoiceLogWhereInput | EInvoiceLogWhereInput[]
    eInvoiceId?: UuidFilter<"EInvoiceLog"> | string
    action?: StringFilter<"EInvoiceLog"> | string
    status?: EnumEInvoiceStatusFilter<"EInvoiceLog"> | $Enums.EInvoiceStatus
    message?: StringNullableFilter<"EInvoiceLog"> | string | null
    requestData?: JsonNullableFilter<"EInvoiceLog">
    responseData?: JsonNullableFilter<"EInvoiceLog">
    errorCode?: StringNullableFilter<"EInvoiceLog"> | string | null
    errorMessage?: StringNullableFilter<"EInvoiceLog"> | string | null
    ipAddress?: StringNullableFilter<"EInvoiceLog"> | string | null
    userAgent?: StringNullableFilter<"EInvoiceLog"> | string | null
    createdAt?: DateTimeFilter<"EInvoiceLog"> | Date | string
    eInvoice?: XOR<EInvoiceScalarRelationFilter, EInvoiceWhereInput>
  }, "id">

  export type EInvoiceLogOrderByWithAggregationInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EInvoiceLogCountOrderByAggregateInput
    _max?: EInvoiceLogMaxOrderByAggregateInput
    _min?: EInvoiceLogMinOrderByAggregateInput
  }

  export type EInvoiceLogScalarWhereWithAggregatesInput = {
    AND?: EInvoiceLogScalarWhereWithAggregatesInput | EInvoiceLogScalarWhereWithAggregatesInput[]
    OR?: EInvoiceLogScalarWhereWithAggregatesInput[]
    NOT?: EInvoiceLogScalarWhereWithAggregatesInput | EInvoiceLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"EInvoiceLog"> | string
    eInvoiceId?: UuidWithAggregatesFilter<"EInvoiceLog"> | string
    action?: StringWithAggregatesFilter<"EInvoiceLog"> | string
    status?: EnumEInvoiceStatusWithAggregatesFilter<"EInvoiceLog"> | $Enums.EInvoiceStatus
    message?: StringNullableWithAggregatesFilter<"EInvoiceLog"> | string | null
    requestData?: JsonNullableWithAggregatesFilter<"EInvoiceLog">
    responseData?: JsonNullableWithAggregatesFilter<"EInvoiceLog">
    errorCode?: StringNullableWithAggregatesFilter<"EInvoiceLog"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"EInvoiceLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"EInvoiceLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"EInvoiceLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EInvoiceLog"> | Date | string
  }

  export type LhdnTokenWhereInput = {
    AND?: LhdnTokenWhereInput | LhdnTokenWhereInput[]
    OR?: LhdnTokenWhereInput[]
    NOT?: LhdnTokenWhereInput | LhdnTokenWhereInput[]
    id?: UuidFilter<"LhdnToken"> | string
    tenantId?: UuidFilter<"LhdnToken"> | string
    accessToken?: StringFilter<"LhdnToken"> | string
    tokenType?: StringFilter<"LhdnToken"> | string
    expiresAt?: DateTimeFilter<"LhdnToken"> | Date | string
    scope?: StringNullableFilter<"LhdnToken"> | string | null
    createdAt?: DateTimeFilter<"LhdnToken"> | Date | string
    updatedAt?: DateTimeFilter<"LhdnToken"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type LhdnTokenOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type LhdnTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: LhdnTokenWhereInput | LhdnTokenWhereInput[]
    OR?: LhdnTokenWhereInput[]
    NOT?: LhdnTokenWhereInput | LhdnTokenWhereInput[]
    accessToken?: StringFilter<"LhdnToken"> | string
    tokenType?: StringFilter<"LhdnToken"> | string
    expiresAt?: DateTimeFilter<"LhdnToken"> | Date | string
    scope?: StringNullableFilter<"LhdnToken"> | string | null
    createdAt?: DateTimeFilter<"LhdnToken"> | Date | string
    updatedAt?: DateTimeFilter<"LhdnToken"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type LhdnTokenOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LhdnTokenCountOrderByAggregateInput
    _max?: LhdnTokenMaxOrderByAggregateInput
    _min?: LhdnTokenMinOrderByAggregateInput
  }

  export type LhdnTokenScalarWhereWithAggregatesInput = {
    AND?: LhdnTokenScalarWhereWithAggregatesInput | LhdnTokenScalarWhereWithAggregatesInput[]
    OR?: LhdnTokenScalarWhereWithAggregatesInput[]
    NOT?: LhdnTokenScalarWhereWithAggregatesInput | LhdnTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LhdnToken"> | string
    tenantId?: UuidWithAggregatesFilter<"LhdnToken"> | string
    accessToken?: StringWithAggregatesFilter<"LhdnToken"> | string
    tokenType?: StringWithAggregatesFilter<"LhdnToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"LhdnToken"> | Date | string
    scope?: StringNullableWithAggregatesFilter<"LhdnToken"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LhdnToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LhdnToken"> | Date | string
  }

  export type LhdnCredentialWhereInput = {
    AND?: LhdnCredentialWhereInput | LhdnCredentialWhereInput[]
    OR?: LhdnCredentialWhereInput[]
    NOT?: LhdnCredentialWhereInput | LhdnCredentialWhereInput[]
    id?: UuidFilter<"LhdnCredential"> | string
    tenantId?: UuidFilter<"LhdnCredential"> | string
    clientId?: StringFilter<"LhdnCredential"> | string
    clientSecretEncrypted?: StringFilter<"LhdnCredential"> | string
    tin?: StringFilter<"LhdnCredential"> | string
    brn?: StringNullableFilter<"LhdnCredential"> | string | null
    idType?: StringFilter<"LhdnCredential"> | string
    idValue?: StringFilter<"LhdnCredential"> | string
    environment?: EnumLhdnEnvironmentFilter<"LhdnCredential"> | $Enums.LhdnEnvironment
    isActive?: BoolFilter<"LhdnCredential"> | boolean
    createdAt?: DateTimeFilter<"LhdnCredential"> | Date | string
    updatedAt?: DateTimeFilter<"LhdnCredential"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type LhdnCredentialOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecretEncrypted?: SortOrder
    tin?: SortOrder
    brn?: SortOrderInput | SortOrder
    idType?: SortOrder
    idValue?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type LhdnCredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: LhdnCredentialWhereInput | LhdnCredentialWhereInput[]
    OR?: LhdnCredentialWhereInput[]
    NOT?: LhdnCredentialWhereInput | LhdnCredentialWhereInput[]
    clientId?: StringFilter<"LhdnCredential"> | string
    clientSecretEncrypted?: StringFilter<"LhdnCredential"> | string
    tin?: StringFilter<"LhdnCredential"> | string
    brn?: StringNullableFilter<"LhdnCredential"> | string | null
    idType?: StringFilter<"LhdnCredential"> | string
    idValue?: StringFilter<"LhdnCredential"> | string
    environment?: EnumLhdnEnvironmentFilter<"LhdnCredential"> | $Enums.LhdnEnvironment
    isActive?: BoolFilter<"LhdnCredential"> | boolean
    createdAt?: DateTimeFilter<"LhdnCredential"> | Date | string
    updatedAt?: DateTimeFilter<"LhdnCredential"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type LhdnCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecretEncrypted?: SortOrder
    tin?: SortOrder
    brn?: SortOrderInput | SortOrder
    idType?: SortOrder
    idValue?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LhdnCredentialCountOrderByAggregateInput
    _max?: LhdnCredentialMaxOrderByAggregateInput
    _min?: LhdnCredentialMinOrderByAggregateInput
  }

  export type LhdnCredentialScalarWhereWithAggregatesInput = {
    AND?: LhdnCredentialScalarWhereWithAggregatesInput | LhdnCredentialScalarWhereWithAggregatesInput[]
    OR?: LhdnCredentialScalarWhereWithAggregatesInput[]
    NOT?: LhdnCredentialScalarWhereWithAggregatesInput | LhdnCredentialScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LhdnCredential"> | string
    tenantId?: UuidWithAggregatesFilter<"LhdnCredential"> | string
    clientId?: StringWithAggregatesFilter<"LhdnCredential"> | string
    clientSecretEncrypted?: StringWithAggregatesFilter<"LhdnCredential"> | string
    tin?: StringWithAggregatesFilter<"LhdnCredential"> | string
    brn?: StringNullableWithAggregatesFilter<"LhdnCredential"> | string | null
    idType?: StringWithAggregatesFilter<"LhdnCredential"> | string
    idValue?: StringWithAggregatesFilter<"LhdnCredential"> | string
    environment?: EnumLhdnEnvironmentWithAggregatesFilter<"LhdnCredential"> | $Enums.LhdnEnvironment
    isActive?: BoolWithAggregatesFilter<"LhdnCredential"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LhdnCredential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LhdnCredential"> | Date | string
  }

  export type TenantCapabilityWhereInput = {
    AND?: TenantCapabilityWhereInput | TenantCapabilityWhereInput[]
    OR?: TenantCapabilityWhereInput[]
    NOT?: TenantCapabilityWhereInput | TenantCapabilityWhereInput[]
    id?: UuidFilter<"TenantCapability"> | string
    tenantId?: UuidFilter<"TenantCapability"> | string
    code?: StringFilter<"TenantCapability"> | string
    enabled?: BoolFilter<"TenantCapability"> | boolean
    createdAt?: DateTimeFilter<"TenantCapability"> | Date | string
    updatedAt?: DateTimeFilter<"TenantCapability"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantCapabilityOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantCapabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_code?: TenantCapabilityTenantIdCodeCompoundUniqueInput
    AND?: TenantCapabilityWhereInput | TenantCapabilityWhereInput[]
    OR?: TenantCapabilityWhereInput[]
    NOT?: TenantCapabilityWhereInput | TenantCapabilityWhereInput[]
    tenantId?: UuidFilter<"TenantCapability"> | string
    code?: StringFilter<"TenantCapability"> | string
    enabled?: BoolFilter<"TenantCapability"> | boolean
    createdAt?: DateTimeFilter<"TenantCapability"> | Date | string
    updatedAt?: DateTimeFilter<"TenantCapability"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_code">

  export type TenantCapabilityOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCapabilityCountOrderByAggregateInput
    _max?: TenantCapabilityMaxOrderByAggregateInput
    _min?: TenantCapabilityMinOrderByAggregateInput
  }

  export type TenantCapabilityScalarWhereWithAggregatesInput = {
    AND?: TenantCapabilityScalarWhereWithAggregatesInput | TenantCapabilityScalarWhereWithAggregatesInput[]
    OR?: TenantCapabilityScalarWhereWithAggregatesInput[]
    NOT?: TenantCapabilityScalarWhereWithAggregatesInput | TenantCapabilityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TenantCapability"> | string
    tenantId?: UuidWithAggregatesFilter<"TenantCapability"> | string
    code?: StringWithAggregatesFilter<"TenantCapability"> | string
    enabled?: BoolWithAggregatesFilter<"TenantCapability"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TenantCapability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantCapability"> | Date | string
  }

  export type PrintAuditWhereInput = {
    AND?: PrintAuditWhereInput | PrintAuditWhereInput[]
    OR?: PrintAuditWhereInput[]
    NOT?: PrintAuditWhereInput | PrintAuditWhereInput[]
    id?: UuidFilter<"PrintAudit"> | string
    tenantId?: UuidFilter<"PrintAudit"> | string
    userId?: UuidFilter<"PrintAudit"> | string
    documentType?: StringFilter<"PrintAudit"> | string
    documentId?: UuidFilter<"PrintAudit"> | string
    documentNumber?: StringNullableFilter<"PrintAudit"> | string | null
    printerName?: StringNullableFilter<"PrintAudit"> | string | null
    paperSize?: StringNullableFilter<"PrintAudit"> | string | null
    copies?: IntFilter<"PrintAudit"> | number
    printMode?: StringNullableFilter<"PrintAudit"> | string | null
    success?: BoolFilter<"PrintAudit"> | boolean
    errorMessage?: StringNullableFilter<"PrintAudit"> | string | null
    ipAddress?: StringNullableFilter<"PrintAudit"> | string | null
    userAgent?: StringNullableFilter<"PrintAudit"> | string | null
    printTimestamp?: DateTimeFilter<"PrintAudit"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PrintAuditOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentId?: SortOrder
    documentNumber?: SortOrderInput | SortOrder
    printerName?: SortOrderInput | SortOrder
    paperSize?: SortOrderInput | SortOrder
    copies?: SortOrder
    printMode?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    printTimestamp?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PrintAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrintAuditWhereInput | PrintAuditWhereInput[]
    OR?: PrintAuditWhereInput[]
    NOT?: PrintAuditWhereInput | PrintAuditWhereInput[]
    tenantId?: UuidFilter<"PrintAudit"> | string
    userId?: UuidFilter<"PrintAudit"> | string
    documentType?: StringFilter<"PrintAudit"> | string
    documentId?: UuidFilter<"PrintAudit"> | string
    documentNumber?: StringNullableFilter<"PrintAudit"> | string | null
    printerName?: StringNullableFilter<"PrintAudit"> | string | null
    paperSize?: StringNullableFilter<"PrintAudit"> | string | null
    copies?: IntFilter<"PrintAudit"> | number
    printMode?: StringNullableFilter<"PrintAudit"> | string | null
    success?: BoolFilter<"PrintAudit"> | boolean
    errorMessage?: StringNullableFilter<"PrintAudit"> | string | null
    ipAddress?: StringNullableFilter<"PrintAudit"> | string | null
    userAgent?: StringNullableFilter<"PrintAudit"> | string | null
    printTimestamp?: DateTimeFilter<"PrintAudit"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PrintAuditOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentId?: SortOrder
    documentNumber?: SortOrderInput | SortOrder
    printerName?: SortOrderInput | SortOrder
    paperSize?: SortOrderInput | SortOrder
    copies?: SortOrder
    printMode?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    printTimestamp?: SortOrder
    _count?: PrintAuditCountOrderByAggregateInput
    _avg?: PrintAuditAvgOrderByAggregateInput
    _max?: PrintAuditMaxOrderByAggregateInput
    _min?: PrintAuditMinOrderByAggregateInput
    _sum?: PrintAuditSumOrderByAggregateInput
  }

  export type PrintAuditScalarWhereWithAggregatesInput = {
    AND?: PrintAuditScalarWhereWithAggregatesInput | PrintAuditScalarWhereWithAggregatesInput[]
    OR?: PrintAuditScalarWhereWithAggregatesInput[]
    NOT?: PrintAuditScalarWhereWithAggregatesInput | PrintAuditScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PrintAudit"> | string
    tenantId?: UuidWithAggregatesFilter<"PrintAudit"> | string
    userId?: UuidWithAggregatesFilter<"PrintAudit"> | string
    documentType?: StringWithAggregatesFilter<"PrintAudit"> | string
    documentId?: UuidWithAggregatesFilter<"PrintAudit"> | string
    documentNumber?: StringNullableWithAggregatesFilter<"PrintAudit"> | string | null
    printerName?: StringNullableWithAggregatesFilter<"PrintAudit"> | string | null
    paperSize?: StringNullableWithAggregatesFilter<"PrintAudit"> | string | null
    copies?: IntWithAggregatesFilter<"PrintAudit"> | number
    printMode?: StringNullableWithAggregatesFilter<"PrintAudit"> | string | null
    success?: BoolWithAggregatesFilter<"PrintAudit"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"PrintAudit"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"PrintAudit"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"PrintAudit"> | string | null
    printTimestamp?: DateTimeWithAggregatesFilter<"PrintAudit"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: string
    department?: string | null
    avatar?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: PlatformAdminRefreshTokenCreateNestedManyWithoutAdminInput
  }

  export type PlatformAdminUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: string
    department?: string | null
    avatar?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: PlatformAdminRefreshTokenUncheckedCreateNestedManyWithoutAdminInput
  }

  export type PlatformAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: PlatformAdminRefreshTokenUpdateManyWithoutAdminNestedInput
  }

  export type PlatformAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: PlatformAdminRefreshTokenUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type PlatformAdminCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: string
    department?: string | null
    avatar?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminRefreshTokenCreateInput = {
    id?: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    admin: PlatformAdminCreateNestedOneWithoutRefreshTokensInput
  }

  export type PlatformAdminRefreshTokenUncheckedCreateInput = {
    id?: string
    adminId: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PlatformAdminRefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: PlatformAdminUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type PlatformAdminRefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminRefreshTokenCreateManyInput = {
    id?: string
    adminId: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PlatformAdminRefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminRefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutRolesInput
    users?: UserCreateNestedManyWithoutCustomRoleInput
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutCustomRoleInput
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutRolesNestedInput
    users?: UserUpdateManyWithoutCustomRoleNestedInput
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutCustomRoleNestedInput
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    module: string
    action: string
    sortOrder?: number
    createdAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    module: string
    action: string
    sortOrder?: number
    createdAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    module: string
    action: string
    sortOrder?: number
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseCreateInput = {
    id?: string
    tier: $Enums.LicenseTier
    licenseKey: string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProducts?: number | null
    startsAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLicensesInput
  }

  export type LicenseUncheckedCreateInput = {
    id?: string
    tenantId: string
    tier: $Enums.LicenseTier
    licenseKey: string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProducts?: number | null
    startsAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    licenseKey?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLicensesNestedInput
  }

  export type LicenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    licenseKey?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseCreateManyInput = {
    id?: string
    tenantId: string
    tier: $Enums.LicenseTier
    licenseKey: string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProducts?: number | null
    startsAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    licenseKey?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    licenseKey?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    tenantId: string
    parentId?: string | null
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    tenantId: string
    parentId?: string | null
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    tenantId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    tenantId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarehouseCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutWarehousesInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    movementsFrom?: InventoryMovementCreateNestedManyWithoutFromWarehouseInput
    movementsTo?: InventoryMovementCreateNestedManyWithoutToWarehouseInput
    ordersShipFrom?: OrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    movementsFrom?: InventoryMovementUncheckedCreateNestedManyWithoutFromWarehouseInput
    movementsTo?: InventoryMovementUncheckedCreateNestedManyWithoutToWarehouseInput
    ordersShipFrom?: OrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutWarehousesNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    movementsFrom?: InventoryMovementUpdateManyWithoutFromWarehouseNestedInput
    movementsTo?: InventoryMovementUpdateManyWithoutToWarehouseNestedInput
    ordersShipFrom?: OrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    movementsFrom?: InventoryMovementUncheckedUpdateManyWithoutFromWarehouseNestedInput
    movementsTo?: InventoryMovementUncheckedUpdateManyWithoutToWarehouseNestedInput
    ordersShipFrom?: OrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WarehouseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryItemCreateInput = {
    id?: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    tenantId: string
    productId: string
    warehouseId: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    tenantId: string
    productId: string
    warehouseId: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryMovementsInput
    product: ProductCreateNestedOneWithoutInventoryMovementsInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutMovementsFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutMovementsToInput
    user: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: string
    tenantId: string
    productId: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryMovementsNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutMovementsFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutMovementsToNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementCreateManyInput = {
    id?: string
    tenantId: string
    productId: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierCreateInput = {
    id?: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutSuppliersInput
    orders?: OrderCreateNestedManyWithoutSupplierInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutSupplierInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
    orders?: OrderUpdateManyWithoutSupplierNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutSupplierNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierProductCreateInput = {
    id?: string
    tenantId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutSupplierProductsInput
    product: ProductCreateNestedOneWithoutSupplierProductsInput
  }

  export type SupplierProductUncheckedCreateInput = {
    id?: string
    tenantId: string
    supplierId: string
    productId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutSupplierProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutSupplierProductsNestedInput
  }

  export type SupplierProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductCreateManyInput = {
    id?: string
    tenantId: string
    supplierId: string
    productId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    supplier?: SupplierCreateNestedOneWithoutOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutOrdersShipFromInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
    approvedBy?: UserCreateNestedOneWithoutOrdersApprovedInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutOrdersShipFromNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    approvedBy?: UserUpdateOneWithoutOrdersApprovedNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    createdBy: UserCreateNestedOneWithoutInvoicesCreatedInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoicesCreatedNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceItemCreateInput = {
    id?: string
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
    eInvoiceItems?: EInvoiceItemCreateNestedManyWithoutInvoiceItemInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    productId?: string | null
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    eInvoiceItems?: EInvoiceItemUncheckedCreateNestedManyWithoutInvoiceItemInput
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
    eInvoiceItems?: EInvoiceItemUpdateManyWithoutInvoiceItemNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eInvoiceItems?: EInvoiceItemUncheckedUpdateManyWithoutInvoiceItemNestedInput
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    productId?: string | null
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    customer: CustomerCreateNestedOneWithoutPaymentsInput
    receivedBy: UserCreateNestedOneWithoutPaymentsReceivedInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    customerId: string
    receivedById: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    customerId: string
    receivedById: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    assetTag: string
    name: string
    description?: string | null
    assetType: $Enums.AssetType
    category: $Enums.AssetCategory
    status?: $Enums.AssetStatus
    location: string
    assignedTo?: string | null
    purchaseDate: Date | string
    purchaseCost: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    depreciationMethod?: $Enums.DepreciationMethod
    usefulLifeYears?: number | null
    salvageValue?: Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: Date | string | null
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    tenantId: string
    assetTag: string
    name: string
    description?: string | null
    assetType: $Enums.AssetType
    category: $Enums.AssetCategory
    status?: $Enums.AssetStatus
    location: string
    assignedTo?: string | null
    purchaseDate: Date | string
    purchaseCost: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    depreciationMethod?: $Enums.DepreciationMethod
    usefulLifeYears?: number | null
    salvageValue?: Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: Date | string | null
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetTag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    category?: EnumAssetCategoryFieldUpdateOperationsInput | $Enums.AssetCategory
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFieldUpdateOperationsInput | $Enums.DepreciationMethod
    usefulLifeYears?: NullableIntFieldUpdateOperationsInput | number | null
    salvageValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    assetTag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    category?: EnumAssetCategoryFieldUpdateOperationsInput | $Enums.AssetCategory
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFieldUpdateOperationsInput | $Enums.DepreciationMethod
    usefulLifeYears?: NullableIntFieldUpdateOperationsInput | number | null
    salvageValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetCreateManyInput = {
    id?: string
    tenantId: string
    assetTag: string
    name: string
    description?: string | null
    assetType: $Enums.AssetType
    category: $Enums.AssetCategory
    status?: $Enums.AssetStatus
    location: string
    assignedTo?: string | null
    purchaseDate: Date | string
    purchaseCost: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    depreciationMethod?: $Enums.DepreciationMethod
    usefulLifeYears?: number | null
    salvageValue?: Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: Date | string | null
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetTag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    category?: EnumAssetCategoryFieldUpdateOperationsInput | $Enums.AssetCategory
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFieldUpdateOperationsInput | $Enums.DepreciationMethod
    usefulLifeYears?: NullableIntFieldUpdateOperationsInput | number | null
    salvageValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    assetTag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    category?: EnumAssetCategoryFieldUpdateOperationsInput | $Enums.AssetCategory
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFieldUpdateOperationsInput | $Enums.DepreciationMethod
    usefulLifeYears?: NullableIntFieldUpdateOperationsInput | number | null
    salvageValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EInvoiceCreateInput = {
    id?: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEInvoicesInput
    invoice: InvoiceCreateNestedOneWithoutEInvoicesInput
    originalEInvoice?: EInvoiceCreateNestedOneWithoutRelatedEInvoicesInput
    relatedEInvoices?: EInvoiceCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedEInvoices?: EInvoiceUncheckedCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemUncheckedCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogUncheckedCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEInvoicesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEInvoicesNestedInput
    originalEInvoice?: EInvoiceUpdateOneWithoutRelatedEInvoicesNestedInput
    relatedEInvoices?: EInvoiceUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEInvoices?: EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUncheckedUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUncheckedUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceCreateManyInput = {
    id?: string
    tenantId: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceItemCreateInput = {
    id?: string
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    eInvoice: EInvoiceCreateNestedOneWithoutItemsInput
    invoiceItem?: InvoiceItemCreateNestedOneWithoutEInvoiceItemsInput
  }

  export type EInvoiceItemUncheckedCreateInput = {
    id?: string
    eInvoiceId: string
    invoiceItemId?: string | null
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eInvoice?: EInvoiceUpdateOneRequiredWithoutItemsNestedInput
    invoiceItem?: InvoiceItemUpdateOneWithoutEInvoiceItemsNestedInput
  }

  export type EInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eInvoiceId?: StringFieldUpdateOperationsInput | string
    invoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceItemCreateManyInput = {
    id?: string
    eInvoiceId: string
    invoiceItemId?: string | null
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eInvoiceId?: StringFieldUpdateOperationsInput | string
    invoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceLogCreateInput = {
    id?: string
    action: string
    status: $Enums.EInvoiceStatus
    message?: string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    eInvoice: EInvoiceCreateNestedOneWithoutLogsInput
  }

  export type EInvoiceLogUncheckedCreateInput = {
    id?: string
    eInvoiceId: string
    action: string
    status: $Enums.EInvoiceStatus
    message?: string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type EInvoiceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eInvoice?: EInvoiceUpdateOneRequiredWithoutLogsNestedInput
  }

  export type EInvoiceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eInvoiceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceLogCreateManyInput = {
    id?: string
    eInvoiceId: string
    action: string
    status: $Enums.EInvoiceStatus
    message?: string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type EInvoiceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eInvoiceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnTokenCreateInput = {
    id?: string
    accessToken: string
    tokenType: string
    expiresAt: Date | string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLhdnTokenInput
  }

  export type LhdnTokenUncheckedCreateInput = {
    id?: string
    tenantId: string
    accessToken: string
    tokenType: string
    expiresAt: Date | string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LhdnTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    tokenType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLhdnTokenNestedInput
  }

  export type LhdnTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    tokenType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnTokenCreateManyInput = {
    id?: string
    tenantId: string
    accessToken: string
    tokenType: string
    expiresAt: Date | string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LhdnTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    tokenType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    tokenType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnCredentialCreateInput = {
    id?: string
    clientId: string
    clientSecretEncrypted: string
    tin: string
    brn?: string | null
    idType: string
    idValue: string
    environment?: $Enums.LhdnEnvironment
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLhdnCredentialInput
  }

  export type LhdnCredentialUncheckedCreateInput = {
    id?: string
    tenantId: string
    clientId: string
    clientSecretEncrypted: string
    tin: string
    brn?: string | null
    idType: string
    idValue: string
    environment?: $Enums.LhdnEnvironment
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LhdnCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretEncrypted?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    brn?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: StringFieldUpdateOperationsInput | string
    idValue?: StringFieldUpdateOperationsInput | string
    environment?: EnumLhdnEnvironmentFieldUpdateOperationsInput | $Enums.LhdnEnvironment
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLhdnCredentialNestedInput
  }

  export type LhdnCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretEncrypted?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    brn?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: StringFieldUpdateOperationsInput | string
    idValue?: StringFieldUpdateOperationsInput | string
    environment?: EnumLhdnEnvironmentFieldUpdateOperationsInput | $Enums.LhdnEnvironment
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnCredentialCreateManyInput = {
    id?: string
    tenantId: string
    clientId: string
    clientSecretEncrypted: string
    tin: string
    brn?: string | null
    idType: string
    idValue: string
    environment?: $Enums.LhdnEnvironment
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LhdnCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretEncrypted?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    brn?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: StringFieldUpdateOperationsInput | string
    idValue?: StringFieldUpdateOperationsInput | string
    environment?: EnumLhdnEnvironmentFieldUpdateOperationsInput | $Enums.LhdnEnvironment
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretEncrypted?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    brn?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: StringFieldUpdateOperationsInput | string
    idValue?: StringFieldUpdateOperationsInput | string
    environment?: EnumLhdnEnvironmentFieldUpdateOperationsInput | $Enums.LhdnEnvironment
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCapabilityCreateInput = {
    id?: string
    code: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCapabilitiesInput
  }

  export type TenantCapabilityUncheckedCreateInput = {
    id?: string
    tenantId: string
    code: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantCapabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCapabilitiesNestedInput
  }

  export type TenantCapabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCapabilityCreateManyInput = {
    id?: string
    tenantId: string
    code: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantCapabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCapabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintAuditCreateInput = {
    id?: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
    tenant: TenantCreateNestedOneWithoutPrintAuditsInput
    user: UserCreateNestedOneWithoutPrintAuditsInput
  }

  export type PrintAuditUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
  }

  export type PrintAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPrintAuditsNestedInput
    user?: UserUpdateOneRequiredWithoutPrintAuditsNestedInput
  }

  export type PrintAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintAuditCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
  }

  export type PrintAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type EnumLicenseTierFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseTier | EnumLicenseTierFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseTier[] | ListEnumLicenseTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseTier[] | ListEnumLicenseTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseTierFilter<$PrismaModel> | $Enums.LicenseTier
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumAuthPolicyPrimaryFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyPrimary | EnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyPrimary[] | ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyPrimary[] | ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyPrimaryFilter<$PrismaModel> | $Enums.AuthPolicyPrimary
  }

  export type EnumAuthPolicyMfaFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyMfa | EnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyMfa[] | ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyMfa[] | ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyMfaFilter<$PrismaModel> | $Enums.AuthPolicyMfa
  }

  export type EnumAuthPolicyIdentifierFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyIdentifier | EnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyIdentifier[] | ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyIdentifier[] | ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyIdentifierFilter<$PrismaModel> | $Enums.AuthPolicyIdentifier
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type WarehouseListRelationFilter = {
    every?: WarehouseWhereInput
    some?: WarehouseWhereInput
    none?: WarehouseWhereInput
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type LicenseListRelationFilter = {
    every?: LicenseWhereInput
    some?: LicenseWhereInput
    none?: LicenseWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type EInvoiceListRelationFilter = {
    every?: EInvoiceWhereInput
    some?: EInvoiceWhereInput
    none?: EInvoiceWhereInput
  }

  export type LhdnTokenNullableScalarRelationFilter = {
    is?: LhdnTokenWhereInput | null
    isNot?: LhdnTokenWhereInput | null
  }

  export type LhdnCredentialNullableScalarRelationFilter = {
    is?: LhdnCredentialWhereInput | null
    isNot?: LhdnCredentialWhereInput | null
  }

  export type TenantCapabilityListRelationFilter = {
    every?: TenantCapabilityWhereInput
    some?: TenantCapabilityWhereInput
    none?: TenantCapabilityWhereInput
  }

  export type PrintAuditListRelationFilter = {
    every?: PrintAuditWhereInput
    some?: PrintAuditWhereInput
    none?: PrintAuditWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCapabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrintAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    authPolicyPrimary?: SortOrder
    authPolicyMfa?: SortOrder
    authPolicyIdentifier?: SortOrder
    authPolicyAllowFallback?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    authPolicyPrimary?: SortOrder
    authPolicyMfa?: SortOrder
    authPolicyIdentifier?: SortOrder
    authPolicyAllowFallback?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    authPolicyPrimary?: SortOrder
    authPolicyMfa?: SortOrder
    authPolicyIdentifier?: SortOrder
    authPolicyAllowFallback?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type EnumLicenseTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseTier | EnumLicenseTierFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseTier[] | ListEnumLicenseTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseTier[] | ListEnumLicenseTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseTierWithAggregatesFilter<$PrismaModel> | $Enums.LicenseTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseTierFilter<$PrismaModel>
    _max?: NestedEnumLicenseTierFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAuthPolicyPrimaryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyPrimary | EnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyPrimary[] | ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyPrimary[] | ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyPrimaryWithAggregatesFilter<$PrismaModel> | $Enums.AuthPolicyPrimary
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthPolicyPrimaryFilter<$PrismaModel>
    _max?: NestedEnumAuthPolicyPrimaryFilter<$PrismaModel>
  }

  export type EnumAuthPolicyMfaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyMfa | EnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyMfa[] | ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyMfa[] | ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyMfaWithAggregatesFilter<$PrismaModel> | $Enums.AuthPolicyMfa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthPolicyMfaFilter<$PrismaModel>
    _max?: NestedEnumAuthPolicyMfaFilter<$PrismaModel>
  }

  export type EnumAuthPolicyIdentifierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyIdentifier | EnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyIdentifier[] | ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyIdentifier[] | ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyIdentifierWithAggregatesFilter<$PrismaModel> | $Enums.AuthPolicyIdentifier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthPolicyIdentifierFilter<$PrismaModel>
    _max?: NestedEnumAuthPolicyIdentifierFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    roleId?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedLogins?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    roleId?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    roleId?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedLogins?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PlatformAdminRefreshTokenListRelationFilter = {
    every?: PlatformAdminRefreshTokenWhereInput
    some?: PlatformAdminRefreshTokenWhereInput
    none?: PlatformAdminRefreshTokenWhereInput
  }

  export type PlatformAdminRefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformAdminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformAdminAvgOrderByAggregateInput = {
    failedLogins?: SortOrder
  }

  export type PlatformAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformAdminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    department?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLogins?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformAdminSumOrderByAggregateInput = {
    failedLogins?: SortOrder
  }

  export type PlatformAdminScalarRelationFilter = {
    is?: PlatformAdminWhereInput
    isNot?: PlatformAdminWhereInput
  }

  export type PlatformAdminRefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PlatformAdminRefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PlatformAdminRefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    token?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleTenantIdNameCompoundUniqueInput = {
    tenantId: string
    name: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isSystem?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    action?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    action?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    module?: SortOrder
    action?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LicenseCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tier?: SortOrder
    licenseKey?: SortOrder
    features?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LicenseAvgOrderByAggregateInput = {
    maxUsers?: SortOrder
    maxProducts?: SortOrder
  }

  export type LicenseMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tier?: SortOrder
    licenseKey?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LicenseMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tier?: SortOrder
    licenseKey?: SortOrder
    maxUsers?: SortOrder
    maxProducts?: SortOrder
    startsAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LicenseSumOrderByAggregateInput = {
    maxUsers?: SortOrder
    maxProducts?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryTenantIdSlugCompoundUniqueInput = {
    tenantId: string
    slug: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    image?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type SupplierProductListRelationFilter = {
    every?: SupplierProductWhereInput
    some?: SupplierProductWhereInput
    none?: SupplierProductWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTenantIdSkuCompoundUniqueInput = {
    tenantId: string
    sku: string
  }

  export type ProductTenantIdBarcodeCompoundUniqueInput = {
    tenantId: string
    barcode: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    taxRate?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    images?: SortOrder
    attributes?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    taxRate?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    weight?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    taxRate?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    weight?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    categoryId?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    taxRate?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    weight?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    taxRate?: SortOrder
    minStock?: SortOrder
    maxStock?: SortOrder
    reorderPoint?: SortOrder
    reorderQty?: SortOrder
    weight?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type EnumWarehouseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WarehouseType | EnumWarehouseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WarehouseType[] | ListEnumWarehouseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WarehouseType[] | ListEnumWarehouseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWarehouseTypeFilter<$PrismaModel> | $Enums.WarehouseType
  }

  export type WarehouseTenantIdCodeCompoundUniqueInput = {
    tenantId: string
    code: string
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    manager?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    manager?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    manager?: SortOrder
    type?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumWarehouseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WarehouseType | EnumWarehouseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WarehouseType[] | ListEnumWarehouseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WarehouseType[] | ListEnumWarehouseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWarehouseTypeWithAggregatesFilter<$PrismaModel> | $Enums.WarehouseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWarehouseTypeFilter<$PrismaModel>
    _max?: NestedEnumWarehouseTypeFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type WarehouseScalarRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type InventoryItemTenantIdProductIdWarehouseIdBatchNumberCompoundUniqueInput = {
    tenantId: string
    productId: string
    warehouseId: string
    batchNumber: string
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    reservedQty?: SortOrder
    availableQty?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    location?: SortOrder
    costPrice?: SortOrder
    lastCountedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQty?: SortOrder
    availableQty?: SortOrder
    costPrice?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    reservedQty?: SortOrder
    availableQty?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    location?: SortOrder
    costPrice?: SortOrder
    lastCountedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    warehouseId?: SortOrder
    quantity?: SortOrder
    reservedQty?: SortOrder
    availableQty?: SortOrder
    batchNumber?: SortOrder
    lotNumber?: SortOrder
    serialNumber?: SortOrder
    expiryDate?: SortOrder
    location?: SortOrder
    costPrice?: SortOrder
    lastCountedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    reservedQty?: SortOrder
    availableQty?: SortOrder
    costPrice?: SortOrder
  }

  export type EnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type WarehouseNullableScalarRelationFilter = {
    is?: WarehouseWhereInput | null
    isNot?: WarehouseWhereInput | null
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    batchNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    batchNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    productId?: SortOrder
    fromWarehouseId?: SortOrder
    toWarehouseId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
    reference?: SortOrder
    referenceType?: SortOrder
    batchNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitCost?: SortOrder
    totalCost?: SortOrder
  }

  export type EnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type EnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type CustomerTenantIdCodeCompoundUniqueInput = {
    tenantId: string
    code: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    taxId?: SortOrder
    billingAddress?: SortOrder
    shippingAddress?: SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
  }

  export type EnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type SupplierTenantIdCodeCompoundUniqueInput = {
    tenantId: string
    code: string
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    taxId?: SortOrder
    address?: SortOrder
    bankDetails?: SortOrder
    paymentTerms?: SortOrder
    currency?: SortOrder
    leadTime?: SortOrder
    minimumOrder?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    paymentTerms?: SortOrder
    leadTime?: SortOrder
    minimumOrder?: SortOrder
    rating?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    currency?: SortOrder
    leadTime?: SortOrder
    minimumOrder?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contactPerson?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    mobile?: SortOrder
    fax?: SortOrder
    website?: SortOrder
    taxId?: SortOrder
    paymentTerms?: SortOrder
    currency?: SortOrder
    leadTime?: SortOrder
    minimumOrder?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    paymentTerms?: SortOrder
    leadTime?: SortOrder
    minimumOrder?: SortOrder
    rating?: SortOrder
  }

  export type SupplierScalarRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type SupplierProductTenantIdSupplierIdProductIdCompoundUniqueInput = {
    tenantId: string
    supplierId: string
    productId: string
  }

  export type SupplierProductCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    supplierSku?: SortOrder
    unitPrice?: SortOrder
    minOrderQty?: SortOrder
    leadTime?: SortOrder
    isPreferred?: SortOrder
    lastOrderAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierProductAvgOrderByAggregateInput = {
    unitPrice?: SortOrder
    minOrderQty?: SortOrder
    leadTime?: SortOrder
  }

  export type SupplierProductMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    supplierSku?: SortOrder
    unitPrice?: SortOrder
    minOrderQty?: SortOrder
    leadTime?: SortOrder
    isPreferred?: SortOrder
    lastOrderAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierProductMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    productId?: SortOrder
    supplierSku?: SortOrder
    unitPrice?: SortOrder
    minOrderQty?: SortOrder
    leadTime?: SortOrder
    isPreferred?: SortOrder
    lastOrderAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierProductSumOrderByAggregateInput = {
    unitPrice?: SortOrder
    minOrderQty?: SortOrder
    leadTime?: SortOrder
  }

  export type EnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SupplierNullableScalarRelationFilter = {
    is?: SupplierWhereInput | null
    isNot?: SupplierWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type OrderTenantIdOrderNumberCompoundUniqueInput = {
    tenantId: string
    orderNumber: string
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    shippedDate?: SortOrder
    deliveredDate?: SortOrder
    shippingAddress?: SortOrder
    billingAddress?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    shippingCost?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    internalNotes?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    shippingCost?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    exchangeRate?: SortOrder
    paymentTerms?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    shippedDate?: SortOrder
    deliveredDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    shippingCost?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    internalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    customerId?: SortOrder
    supplierId?: SortOrder
    warehouseId?: SortOrder
    createdById?: SortOrder
    approvedById?: SortOrder
    orderDate?: SortOrder
    expectedDate?: SortOrder
    shippedDate?: SortOrder
    deliveredDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    shippingCost?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    notes?: SortOrder
    internalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    shippingCost?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    exchangeRate?: SortOrder
    paymentTerms?: SortOrder
  }

  export type EnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    shippedQty?: SortOrder
    receivedQty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    shippedQty?: SortOrder
    receivedQty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    shippedQty?: SortOrder
    receivedQty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    shippedQty?: SortOrder
    receivedQty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    discount?: SortOrder
    discountType?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    shippedQty?: SortOrder
    receivedQty?: SortOrder
    unitPrice?: SortOrder
    unitCost?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type InvoiceTenantIdInvoiceNumberCompoundUniqueInput = {
    tenantId: string
    invoiceNumber: string
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    footer?: SortOrder
    metadata?: SortOrder
    sentAt?: SortOrder
    viewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    exchangeRate?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    footer?: SortOrder
    sentAt?: SortOrder
    viewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
    invoiceNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    footer?: SortOrder
    sentAt?: SortOrder
    viewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discount?: SortOrder
    shippingCost?: SortOrder
    total?: SortOrder
    paidAmount?: SortOrder
    balanceDue?: SortOrder
    exchangeRate?: SortOrder
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type EInvoiceItemListRelationFilter = {
    every?: EInvoiceItemWhereInput
    some?: EInvoiceItemWhereInput
    none?: EInvoiceItemWhereInput
  }

  export type EInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PaymentTenantIdPaymentNumberCompoundUniqueInput = {
    tenantId: string
    paymentNumber: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    customerId?: SortOrder
    receivedById?: SortOrder
    paymentNumber?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    customerId?: SortOrder
    receivedById?: SortOrder
    paymentNumber?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    customerId?: SortOrder
    receivedById?: SortOrder
    paymentNumber?: SortOrder
    type?: SortOrder
    method?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchangeRate?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    changedFields?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    entityName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeFilter<$PrismaModel> | $Enums.AssetType
  }

  export type EnumAssetCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetCategory | EnumAssetCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AssetCategory[] | ListEnumAssetCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetCategory[] | ListEnumAssetCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetCategoryFilter<$PrismaModel> | $Enums.AssetCategory
  }

  export type EnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type EnumDepreciationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DepreciationMethod | EnumDepreciationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DepreciationMethod[] | ListEnumDepreciationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepreciationMethod[] | ListEnumDepreciationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDepreciationMethodFilter<$PrismaModel> | $Enums.DepreciationMethod
  }

  export type AssetTenantIdAssetTagCompoundUniqueInput = {
    tenantId: string
    assetTag: string
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    assetTag?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assetType?: SortOrder
    category?: SortOrder
    status?: SortOrder
    location?: SortOrder
    assignedTo?: SortOrder
    purchaseDate?: SortOrder
    purchaseCost?: SortOrder
    currentValue?: SortOrder
    depreciationMethod?: SortOrder
    usefulLifeYears?: SortOrder
    salvageValue?: SortOrder
    warrantyExpiry?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    purchaseCost?: SortOrder
    currentValue?: SortOrder
    usefulLifeYears?: SortOrder
    salvageValue?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    assetTag?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assetType?: SortOrder
    category?: SortOrder
    status?: SortOrder
    location?: SortOrder
    assignedTo?: SortOrder
    purchaseDate?: SortOrder
    purchaseCost?: SortOrder
    currentValue?: SortOrder
    depreciationMethod?: SortOrder
    usefulLifeYears?: SortOrder
    salvageValue?: SortOrder
    warrantyExpiry?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    assetTag?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assetType?: SortOrder
    category?: SortOrder
    status?: SortOrder
    location?: SortOrder
    assignedTo?: SortOrder
    purchaseDate?: SortOrder
    purchaseCost?: SortOrder
    currentValue?: SortOrder
    depreciationMethod?: SortOrder
    usefulLifeYears?: SortOrder
    salvageValue?: SortOrder
    warrantyExpiry?: SortOrder
    serialNumber?: SortOrder
    manufacturer?: SortOrder
    model?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    purchaseCost?: SortOrder
    currentValue?: SortOrder
    usefulLifeYears?: SortOrder
    salvageValue?: SortOrder
  }

  export type EnumAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetTypeFilter<$PrismaModel>
  }

  export type EnumAssetCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetCategory | EnumAssetCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AssetCategory[] | ListEnumAssetCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetCategory[] | ListEnumAssetCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AssetCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetCategoryFilter<$PrismaModel>
    _max?: NestedEnumAssetCategoryFilter<$PrismaModel>
  }

  export type EnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type EnumDepreciationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepreciationMethod | EnumDepreciationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DepreciationMethod[] | ListEnumDepreciationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepreciationMethod[] | ListEnumDepreciationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDepreciationMethodWithAggregatesFilter<$PrismaModel> | $Enums.DepreciationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepreciationMethodFilter<$PrismaModel>
    _max?: NestedEnumDepreciationMethodFilter<$PrismaModel>
  }

  export type EnumEInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EInvoiceType | EnumEInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EInvoiceType[] | ListEnumEInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EInvoiceType[] | ListEnumEInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEInvoiceTypeFilter<$PrismaModel> | $Enums.EInvoiceType
  }

  export type EnumEInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EInvoiceStatus | EnumEInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EInvoiceStatus[] | ListEnumEInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EInvoiceStatus[] | ListEnumEInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEInvoiceStatusFilter<$PrismaModel> | $Enums.EInvoiceStatus
  }

  export type EInvoiceNullableScalarRelationFilter = {
    is?: EInvoiceWhereInput | null
    isNot?: EInvoiceWhereInput | null
  }

  export type EInvoiceLogListRelationFilter = {
    every?: EInvoiceLogWhereInput
    some?: EInvoiceLogWhereInput
    none?: EInvoiceLogWhereInput
  }

  export type EInvoiceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    invoiceType?: SortOrder
    status?: SortOrder
    lhdnUuid?: SortOrder
    lhdnLongId?: SortOrder
    lhdnSubmissionUid?: SortOrder
    submittedAt?: SortOrder
    validatedAt?: SortOrder
    cancelledAt?: SortOrder
    rejectedAt?: SortOrder
    requestJson?: SortOrder
    responseJson?: SortOrder
    documentHash?: SortOrder
    rejectReason?: SortOrder
    validationErrors?: SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrder
    originalEInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EInvoiceAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    invoiceType?: SortOrder
    status?: SortOrder
    lhdnUuid?: SortOrder
    lhdnLongId?: SortOrder
    lhdnSubmissionUid?: SortOrder
    submittedAt?: SortOrder
    validatedAt?: SortOrder
    cancelledAt?: SortOrder
    rejectedAt?: SortOrder
    documentHash?: SortOrder
    rejectReason?: SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrder
    originalEInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceId?: SortOrder
    invoiceType?: SortOrder
    status?: SortOrder
    lhdnUuid?: SortOrder
    lhdnLongId?: SortOrder
    lhdnSubmissionUid?: SortOrder
    submittedAt?: SortOrder
    validatedAt?: SortOrder
    cancelledAt?: SortOrder
    rejectedAt?: SortOrder
    documentHash?: SortOrder
    rejectReason?: SortOrder
    retryCount?: SortOrder
    lastRetryAt?: SortOrder
    originalEInvoiceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EInvoiceSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumEInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EInvoiceType | EnumEInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EInvoiceType[] | ListEnumEInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EInvoiceType[] | ListEnumEInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.EInvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumEInvoiceTypeFilter<$PrismaModel>
  }

  export type EnumEInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EInvoiceStatus | EnumEInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EInvoiceStatus[] | ListEnumEInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EInvoiceStatus[] | ListEnumEInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.EInvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumEInvoiceStatusFilter<$PrismaModel>
  }

  export type EInvoiceScalarRelationFilter = {
    is?: EInvoiceWhereInput
    isNot?: EInvoiceWhereInput
  }

  export type InvoiceItemNullableScalarRelationFilter = {
    is?: InvoiceItemWhereInput | null
    isNot?: InvoiceItemWhereInput | null
  }

  export type EInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    invoiceItemId?: SortOrder
    classificationCode?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitCode?: SortOrder
    unitPrice?: SortOrder
    taxType?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    taxExemptReason?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountRate?: SortOrder
    totalAmount?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EInvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountRate?: SortOrder
    totalAmount?: SortOrder
    sortOrder?: SortOrder
  }

  export type EInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    invoiceItemId?: SortOrder
    classificationCode?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitCode?: SortOrder
    unitPrice?: SortOrder
    taxType?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    taxExemptReason?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountRate?: SortOrder
    totalAmount?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    invoiceItemId?: SortOrder
    classificationCode?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitCode?: SortOrder
    unitPrice?: SortOrder
    taxType?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    taxExemptReason?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountRate?: SortOrder
    totalAmount?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EInvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    discountRate?: SortOrder
    totalAmount?: SortOrder
    sortOrder?: SortOrder
  }

  export type EInvoiceLogCountOrderByAggregateInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    message?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EInvoiceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    message?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EInvoiceLogMinOrderByAggregateInput = {
    id?: SortOrder
    eInvoiceId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    message?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LhdnTokenCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LhdnTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LhdnTokenMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    accessToken?: SortOrder
    tokenType?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLhdnEnvironmentFilter<$PrismaModel = never> = {
    equals?: $Enums.LhdnEnvironment | EnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    in?: $Enums.LhdnEnvironment[] | ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.LhdnEnvironment[] | ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    not?: NestedEnumLhdnEnvironmentFilter<$PrismaModel> | $Enums.LhdnEnvironment
  }

  export type LhdnCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecretEncrypted?: SortOrder
    tin?: SortOrder
    brn?: SortOrder
    idType?: SortOrder
    idValue?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LhdnCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecretEncrypted?: SortOrder
    tin?: SortOrder
    brn?: SortOrder
    idType?: SortOrder
    idValue?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LhdnCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    clientId?: SortOrder
    clientSecretEncrypted?: SortOrder
    tin?: SortOrder
    brn?: SortOrder
    idType?: SortOrder
    idValue?: SortOrder
    environment?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLhdnEnvironmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LhdnEnvironment | EnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    in?: $Enums.LhdnEnvironment[] | ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.LhdnEnvironment[] | ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    not?: NestedEnumLhdnEnvironmentWithAggregatesFilter<$PrismaModel> | $Enums.LhdnEnvironment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLhdnEnvironmentFilter<$PrismaModel>
    _max?: NestedEnumLhdnEnvironmentFilter<$PrismaModel>
  }

  export type TenantCapabilityTenantIdCodeCompoundUniqueInput = {
    tenantId: string
    code: string
  }

  export type TenantCapabilityCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantCapabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantCapabilityMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    code?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrintAuditCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentId?: SortOrder
    documentNumber?: SortOrder
    printerName?: SortOrder
    paperSize?: SortOrder
    copies?: SortOrder
    printMode?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    printTimestamp?: SortOrder
  }

  export type PrintAuditAvgOrderByAggregateInput = {
    copies?: SortOrder
  }

  export type PrintAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentId?: SortOrder
    documentNumber?: SortOrder
    printerName?: SortOrder
    paperSize?: SortOrder
    copies?: SortOrder
    printMode?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    printTimestamp?: SortOrder
  }

  export type PrintAuditMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    documentType?: SortOrder
    documentId?: SortOrder
    documentNumber?: SortOrder
    printerName?: SortOrder
    paperSize?: SortOrder
    copies?: SortOrder
    printMode?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    printTimestamp?: SortOrder
  }

  export type PrintAuditSumOrderByAggregateInput = {
    copies?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutTenantInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type WarehouseCreateNestedManyWithoutTenantInput = {
    create?: XOR<WarehouseCreateWithoutTenantInput, WarehouseUncheckedCreateWithoutTenantInput> | WarehouseCreateWithoutTenantInput[] | WarehouseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutTenantInput | WarehouseCreateOrConnectWithoutTenantInput[]
    createMany?: WarehouseCreateManyTenantInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutTenantInput = {
    create?: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput> | InventoryItemCreateWithoutTenantInput[] | InventoryItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTenantInput | InventoryItemCreateOrConnectWithoutTenantInput[]
    createMany?: InventoryItemCreateManyTenantInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutTenantInput = {
    create?: XOR<InventoryMovementCreateWithoutTenantInput, InventoryMovementUncheckedCreateWithoutTenantInput> | InventoryMovementCreateWithoutTenantInput[] | InventoryMovementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutTenantInput | InventoryMovementCreateOrConnectWithoutTenantInput[]
    createMany?: InventoryMovementCreateManyTenantInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type LicenseCreateNestedManyWithoutTenantInput = {
    create?: XOR<LicenseCreateWithoutTenantInput, LicenseUncheckedCreateWithoutTenantInput> | LicenseCreateWithoutTenantInput[] | LicenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutTenantInput | LicenseCreateOrConnectWithoutTenantInput[]
    createMany?: LicenseCreateManyTenantInputEnvelope
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutTenantInput = {
    create?: XOR<AssetCreateWithoutTenantInput, AssetUncheckedCreateWithoutTenantInput> | AssetCreateWithoutTenantInput[] | AssetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutTenantInput | AssetCreateOrConnectWithoutTenantInput[]
    createMany?: AssetCreateManyTenantInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type RoleCreateNestedManyWithoutTenantInput = {
    create?: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput> | RoleCreateWithoutTenantInput[] | RoleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutTenantInput | RoleCreateOrConnectWithoutTenantInput[]
    createMany?: RoleCreateManyTenantInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type EInvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<EInvoiceCreateWithoutTenantInput, EInvoiceUncheckedCreateWithoutTenantInput> | EInvoiceCreateWithoutTenantInput[] | EInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutTenantInput | EInvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: EInvoiceCreateManyTenantInputEnvelope
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
  }

  export type LhdnTokenCreateNestedOneWithoutTenantInput = {
    create?: XOR<LhdnTokenCreateWithoutTenantInput, LhdnTokenUncheckedCreateWithoutTenantInput>
    connectOrCreate?: LhdnTokenCreateOrConnectWithoutTenantInput
    connect?: LhdnTokenWhereUniqueInput
  }

  export type LhdnCredentialCreateNestedOneWithoutTenantInput = {
    create?: XOR<LhdnCredentialCreateWithoutTenantInput, LhdnCredentialUncheckedCreateWithoutTenantInput>
    connectOrCreate?: LhdnCredentialCreateOrConnectWithoutTenantInput
    connect?: LhdnCredentialWhereUniqueInput
  }

  export type TenantCapabilityCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantCapabilityCreateWithoutTenantInput, TenantCapabilityUncheckedCreateWithoutTenantInput> | TenantCapabilityCreateWithoutTenantInput[] | TenantCapabilityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantCapabilityCreateOrConnectWithoutTenantInput | TenantCapabilityCreateOrConnectWithoutTenantInput[]
    createMany?: TenantCapabilityCreateManyTenantInputEnvelope
    connect?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
  }

  export type PrintAuditCreateNestedManyWithoutTenantInput = {
    create?: XOR<PrintAuditCreateWithoutTenantInput, PrintAuditUncheckedCreateWithoutTenantInput> | PrintAuditCreateWithoutTenantInput[] | PrintAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrintAuditCreateOrConnectWithoutTenantInput | PrintAuditCreateOrConnectWithoutTenantInput[]
    createMany?: PrintAuditCreateManyTenantInputEnvelope
    connect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type WarehouseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WarehouseCreateWithoutTenantInput, WarehouseUncheckedCreateWithoutTenantInput> | WarehouseCreateWithoutTenantInput[] | WarehouseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutTenantInput | WarehouseCreateOrConnectWithoutTenantInput[]
    createMany?: WarehouseCreateManyTenantInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput> | InventoryItemCreateWithoutTenantInput[] | InventoryItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTenantInput | InventoryItemCreateOrConnectWithoutTenantInput[]
    createMany?: InventoryItemCreateManyTenantInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InventoryMovementCreateWithoutTenantInput, InventoryMovementUncheckedCreateWithoutTenantInput> | InventoryMovementCreateWithoutTenantInput[] | InventoryMovementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutTenantInput | InventoryMovementCreateOrConnectWithoutTenantInput[]
    createMany?: InventoryMovementCreateManyTenantInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type LicenseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LicenseCreateWithoutTenantInput, LicenseUncheckedCreateWithoutTenantInput> | LicenseCreateWithoutTenantInput[] | LicenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutTenantInput | LicenseCreateOrConnectWithoutTenantInput[]
    createMany?: LicenseCreateManyTenantInputEnvelope
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AssetCreateWithoutTenantInput, AssetUncheckedCreateWithoutTenantInput> | AssetCreateWithoutTenantInput[] | AssetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutTenantInput | AssetCreateOrConnectWithoutTenantInput[]
    createMany?: AssetCreateManyTenantInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput> | RoleCreateWithoutTenantInput[] | RoleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutTenantInput | RoleCreateOrConnectWithoutTenantInput[]
    createMany?: RoleCreateManyTenantInputEnvelope
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type EInvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EInvoiceCreateWithoutTenantInput, EInvoiceUncheckedCreateWithoutTenantInput> | EInvoiceCreateWithoutTenantInput[] | EInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutTenantInput | EInvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: EInvoiceCreateManyTenantInputEnvelope
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
  }

  export type LhdnTokenUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<LhdnTokenCreateWithoutTenantInput, LhdnTokenUncheckedCreateWithoutTenantInput>
    connectOrCreate?: LhdnTokenCreateOrConnectWithoutTenantInput
    connect?: LhdnTokenWhereUniqueInput
  }

  export type LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<LhdnCredentialCreateWithoutTenantInput, LhdnCredentialUncheckedCreateWithoutTenantInput>
    connectOrCreate?: LhdnCredentialCreateOrConnectWithoutTenantInput
    connect?: LhdnCredentialWhereUniqueInput
  }

  export type TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantCapabilityCreateWithoutTenantInput, TenantCapabilityUncheckedCreateWithoutTenantInput> | TenantCapabilityCreateWithoutTenantInput[] | TenantCapabilityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantCapabilityCreateOrConnectWithoutTenantInput | TenantCapabilityCreateOrConnectWithoutTenantInput[]
    createMany?: TenantCapabilityCreateManyTenantInputEnvelope
    connect?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
  }

  export type PrintAuditUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PrintAuditCreateWithoutTenantInput, PrintAuditUncheckedCreateWithoutTenantInput> | PrintAuditCreateWithoutTenantInput[] | PrintAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrintAuditCreateOrConnectWithoutTenantInput | PrintAuditCreateOrConnectWithoutTenantInput[]
    createMany?: PrintAuditCreateManyTenantInputEnvelope
    connect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumTenantStatusFieldUpdateOperationsInput = {
    set?: $Enums.TenantStatus
  }

  export type EnumLicenseTierFieldUpdateOperationsInput = {
    set?: $Enums.LicenseTier
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumAuthPolicyPrimaryFieldUpdateOperationsInput = {
    set?: $Enums.AuthPolicyPrimary
  }

  export type EnumAuthPolicyMfaFieldUpdateOperationsInput = {
    set?: $Enums.AuthPolicyMfa
  }

  export type EnumAuthPolicyIdentifierFieldUpdateOperationsInput = {
    set?: $Enums.AuthPolicyIdentifier
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTenantInput | ProductUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTenantInput | ProductUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTenantInput | ProductUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutTenantInput | CategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutTenantInput | CategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutTenantInput | CategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutTenantInput | SupplierUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutTenantInput | SupplierUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutTenantInput | SupplierUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type WarehouseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WarehouseCreateWithoutTenantInput, WarehouseUncheckedCreateWithoutTenantInput> | WarehouseCreateWithoutTenantInput[] | WarehouseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutTenantInput | WarehouseCreateOrConnectWithoutTenantInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutTenantInput | WarehouseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WarehouseCreateManyTenantInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutTenantInput | WarehouseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutTenantInput | WarehouseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput> | InventoryItemCreateWithoutTenantInput[] | InventoryItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTenantInput | InventoryItemCreateOrConnectWithoutTenantInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutTenantInput | InventoryItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InventoryItemCreateManyTenantInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutTenantInput | InventoryItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutTenantInput | InventoryItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutTenantInput, InventoryMovementUncheckedCreateWithoutTenantInput> | InventoryMovementCreateWithoutTenantInput[] | InventoryMovementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutTenantInput | InventoryMovementCreateOrConnectWithoutTenantInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutTenantInput | InventoryMovementUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InventoryMovementCreateManyTenantInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutTenantInput | InventoryMovementUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutTenantInput | InventoryMovementUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTenantInput | OrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTenantInput | OrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTenantInput | OrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LicenseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LicenseCreateWithoutTenantInput, LicenseUncheckedCreateWithoutTenantInput> | LicenseCreateWithoutTenantInput[] | LicenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutTenantInput | LicenseCreateOrConnectWithoutTenantInput[]
    upsert?: LicenseUpsertWithWhereUniqueWithoutTenantInput | LicenseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LicenseCreateManyTenantInputEnvelope
    set?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    disconnect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    delete?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    update?: LicenseUpdateWithWhereUniqueWithoutTenantInput | LicenseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LicenseUpdateManyWithWhereWithoutTenantInput | LicenseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AssetCreateWithoutTenantInput, AssetUncheckedCreateWithoutTenantInput> | AssetCreateWithoutTenantInput[] | AssetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutTenantInput | AssetCreateOrConnectWithoutTenantInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutTenantInput | AssetUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AssetCreateManyTenantInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutTenantInput | AssetUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutTenantInput | AssetUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type RoleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput> | RoleCreateWithoutTenantInput[] | RoleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutTenantInput | RoleCreateOrConnectWithoutTenantInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutTenantInput | RoleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RoleCreateManyTenantInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutTenantInput | RoleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutTenantInput | RoleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type EInvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EInvoiceCreateWithoutTenantInput, EInvoiceUncheckedCreateWithoutTenantInput> | EInvoiceCreateWithoutTenantInput[] | EInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutTenantInput | EInvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: EInvoiceUpsertWithWhereUniqueWithoutTenantInput | EInvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EInvoiceCreateManyTenantInputEnvelope
    set?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    disconnect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    delete?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    update?: EInvoiceUpdateWithWhereUniqueWithoutTenantInput | EInvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EInvoiceUpdateManyWithWhereWithoutTenantInput | EInvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EInvoiceScalarWhereInput | EInvoiceScalarWhereInput[]
  }

  export type LhdnTokenUpdateOneWithoutTenantNestedInput = {
    create?: XOR<LhdnTokenCreateWithoutTenantInput, LhdnTokenUncheckedCreateWithoutTenantInput>
    connectOrCreate?: LhdnTokenCreateOrConnectWithoutTenantInput
    upsert?: LhdnTokenUpsertWithoutTenantInput
    disconnect?: LhdnTokenWhereInput | boolean
    delete?: LhdnTokenWhereInput | boolean
    connect?: LhdnTokenWhereUniqueInput
    update?: XOR<XOR<LhdnTokenUpdateToOneWithWhereWithoutTenantInput, LhdnTokenUpdateWithoutTenantInput>, LhdnTokenUncheckedUpdateWithoutTenantInput>
  }

  export type LhdnCredentialUpdateOneWithoutTenantNestedInput = {
    create?: XOR<LhdnCredentialCreateWithoutTenantInput, LhdnCredentialUncheckedCreateWithoutTenantInput>
    connectOrCreate?: LhdnCredentialCreateOrConnectWithoutTenantInput
    upsert?: LhdnCredentialUpsertWithoutTenantInput
    disconnect?: LhdnCredentialWhereInput | boolean
    delete?: LhdnCredentialWhereInput | boolean
    connect?: LhdnCredentialWhereUniqueInput
    update?: XOR<XOR<LhdnCredentialUpdateToOneWithWhereWithoutTenantInput, LhdnCredentialUpdateWithoutTenantInput>, LhdnCredentialUncheckedUpdateWithoutTenantInput>
  }

  export type TenantCapabilityUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantCapabilityCreateWithoutTenantInput, TenantCapabilityUncheckedCreateWithoutTenantInput> | TenantCapabilityCreateWithoutTenantInput[] | TenantCapabilityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantCapabilityCreateOrConnectWithoutTenantInput | TenantCapabilityCreateOrConnectWithoutTenantInput[]
    upsert?: TenantCapabilityUpsertWithWhereUniqueWithoutTenantInput | TenantCapabilityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantCapabilityCreateManyTenantInputEnvelope
    set?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
    disconnect?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
    delete?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
    connect?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
    update?: TenantCapabilityUpdateWithWhereUniqueWithoutTenantInput | TenantCapabilityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantCapabilityUpdateManyWithWhereWithoutTenantInput | TenantCapabilityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantCapabilityScalarWhereInput | TenantCapabilityScalarWhereInput[]
  }

  export type PrintAuditUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PrintAuditCreateWithoutTenantInput, PrintAuditUncheckedCreateWithoutTenantInput> | PrintAuditCreateWithoutTenantInput[] | PrintAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrintAuditCreateOrConnectWithoutTenantInput | PrintAuditCreateOrConnectWithoutTenantInput[]
    upsert?: PrintAuditUpsertWithWhereUniqueWithoutTenantInput | PrintAuditUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PrintAuditCreateManyTenantInputEnvelope
    set?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    disconnect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    delete?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    connect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    update?: PrintAuditUpdateWithWhereUniqueWithoutTenantInput | PrintAuditUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PrintAuditUpdateManyWithWhereWithoutTenantInput | PrintAuditUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PrintAuditScalarWhereInput | PrintAuditScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTenantInput | ProductUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTenantInput | ProductUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTenantInput | ProductUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput> | CategoryCreateWithoutTenantInput[] | CategoryUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTenantInput | CategoryCreateOrConnectWithoutTenantInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutTenantInput | CategoryUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CategoryCreateManyTenantInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutTenantInput | CategoryUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutTenantInput | CategoryUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutTenantInput | SupplierUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutTenantInput | SupplierUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutTenantInput | SupplierUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type WarehouseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WarehouseCreateWithoutTenantInput, WarehouseUncheckedCreateWithoutTenantInput> | WarehouseCreateWithoutTenantInput[] | WarehouseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutTenantInput | WarehouseCreateOrConnectWithoutTenantInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutTenantInput | WarehouseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WarehouseCreateManyTenantInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutTenantInput | WarehouseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutTenantInput | WarehouseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput> | InventoryItemCreateWithoutTenantInput[] | InventoryItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTenantInput | InventoryItemCreateOrConnectWithoutTenantInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutTenantInput | InventoryItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InventoryItemCreateManyTenantInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutTenantInput | InventoryItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutTenantInput | InventoryItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutTenantInput, InventoryMovementUncheckedCreateWithoutTenantInput> | InventoryMovementCreateWithoutTenantInput[] | InventoryMovementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutTenantInput | InventoryMovementCreateOrConnectWithoutTenantInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutTenantInput | InventoryMovementUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InventoryMovementCreateManyTenantInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutTenantInput | InventoryMovementUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutTenantInput | InventoryMovementUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput> | OrderCreateWithoutTenantInput[] | OrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTenantInput | OrderCreateOrConnectWithoutTenantInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTenantInput | OrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: OrderCreateManyTenantInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTenantInput | OrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTenantInput | OrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LicenseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LicenseCreateWithoutTenantInput, LicenseUncheckedCreateWithoutTenantInput> | LicenseCreateWithoutTenantInput[] | LicenseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutTenantInput | LicenseCreateOrConnectWithoutTenantInput[]
    upsert?: LicenseUpsertWithWhereUniqueWithoutTenantInput | LicenseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LicenseCreateManyTenantInputEnvelope
    set?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    disconnect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    delete?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    update?: LicenseUpdateWithWhereUniqueWithoutTenantInput | LicenseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LicenseUpdateManyWithWhereWithoutTenantInput | LicenseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AssetCreateWithoutTenantInput, AssetUncheckedCreateWithoutTenantInput> | AssetCreateWithoutTenantInput[] | AssetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutTenantInput | AssetCreateOrConnectWithoutTenantInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutTenantInput | AssetUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AssetCreateManyTenantInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutTenantInput | AssetUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutTenantInput | AssetUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput> | RoleCreateWithoutTenantInput[] | RoleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutTenantInput | RoleCreateOrConnectWithoutTenantInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutTenantInput | RoleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RoleCreateManyTenantInputEnvelope
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutTenantInput | RoleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutTenantInput | RoleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type EInvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EInvoiceCreateWithoutTenantInput, EInvoiceUncheckedCreateWithoutTenantInput> | EInvoiceCreateWithoutTenantInput[] | EInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutTenantInput | EInvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: EInvoiceUpsertWithWhereUniqueWithoutTenantInput | EInvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EInvoiceCreateManyTenantInputEnvelope
    set?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    disconnect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    delete?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    update?: EInvoiceUpdateWithWhereUniqueWithoutTenantInput | EInvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EInvoiceUpdateManyWithWhereWithoutTenantInput | EInvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EInvoiceScalarWhereInput | EInvoiceScalarWhereInput[]
  }

  export type LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<LhdnTokenCreateWithoutTenantInput, LhdnTokenUncheckedCreateWithoutTenantInput>
    connectOrCreate?: LhdnTokenCreateOrConnectWithoutTenantInput
    upsert?: LhdnTokenUpsertWithoutTenantInput
    disconnect?: LhdnTokenWhereInput | boolean
    delete?: LhdnTokenWhereInput | boolean
    connect?: LhdnTokenWhereUniqueInput
    update?: XOR<XOR<LhdnTokenUpdateToOneWithWhereWithoutTenantInput, LhdnTokenUpdateWithoutTenantInput>, LhdnTokenUncheckedUpdateWithoutTenantInput>
  }

  export type LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<LhdnCredentialCreateWithoutTenantInput, LhdnCredentialUncheckedCreateWithoutTenantInput>
    connectOrCreate?: LhdnCredentialCreateOrConnectWithoutTenantInput
    upsert?: LhdnCredentialUpsertWithoutTenantInput
    disconnect?: LhdnCredentialWhereInput | boolean
    delete?: LhdnCredentialWhereInput | boolean
    connect?: LhdnCredentialWhereUniqueInput
    update?: XOR<XOR<LhdnCredentialUpdateToOneWithWhereWithoutTenantInput, LhdnCredentialUpdateWithoutTenantInput>, LhdnCredentialUncheckedUpdateWithoutTenantInput>
  }

  export type TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantCapabilityCreateWithoutTenantInput, TenantCapabilityUncheckedCreateWithoutTenantInput> | TenantCapabilityCreateWithoutTenantInput[] | TenantCapabilityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantCapabilityCreateOrConnectWithoutTenantInput | TenantCapabilityCreateOrConnectWithoutTenantInput[]
    upsert?: TenantCapabilityUpsertWithWhereUniqueWithoutTenantInput | TenantCapabilityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantCapabilityCreateManyTenantInputEnvelope
    set?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
    disconnect?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
    delete?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
    connect?: TenantCapabilityWhereUniqueInput | TenantCapabilityWhereUniqueInput[]
    update?: TenantCapabilityUpdateWithWhereUniqueWithoutTenantInput | TenantCapabilityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantCapabilityUpdateManyWithWhereWithoutTenantInput | TenantCapabilityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantCapabilityScalarWhereInput | TenantCapabilityScalarWhereInput[]
  }

  export type PrintAuditUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PrintAuditCreateWithoutTenantInput, PrintAuditUncheckedCreateWithoutTenantInput> | PrintAuditCreateWithoutTenantInput[] | PrintAuditUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrintAuditCreateOrConnectWithoutTenantInput | PrintAuditCreateOrConnectWithoutTenantInput[]
    upsert?: PrintAuditUpsertWithWhereUniqueWithoutTenantInput | PrintAuditUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PrintAuditCreateManyTenantInputEnvelope
    set?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    disconnect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    delete?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    connect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    update?: PrintAuditUpdateWithWhereUniqueWithoutTenantInput | PrintAuditUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PrintAuditUpdateManyWithWhereWithoutTenantInput | PrintAuditUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PrintAuditScalarWhereInput | PrintAuditScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput> | OrderCreateWithoutApprovedByInput[] | OrderUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutApprovedByInput | OrderCreateOrConnectWithoutApprovedByInput[]
    createMany?: OrderCreateManyApprovedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PrintAuditCreateNestedManyWithoutUserInput = {
    create?: XOR<PrintAuditCreateWithoutUserInput, PrintAuditUncheckedCreateWithoutUserInput> | PrintAuditCreateWithoutUserInput[] | PrintAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrintAuditCreateOrConnectWithoutUserInput | PrintAuditCreateOrConnectWithoutUserInput[]
    createMany?: PrintAuditCreateManyUserInputEnvelope
    connect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput> | OrderCreateWithoutApprovedByInput[] | OrderUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutApprovedByInput | OrderCreateOrConnectWithoutApprovedByInput[]
    createMany?: OrderCreateManyApprovedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PrintAuditUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PrintAuditCreateWithoutUserInput, PrintAuditUncheckedCreateWithoutUserInput> | PrintAuditCreateWithoutUserInput[] | PrintAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrintAuditCreateOrConnectWithoutUserInput | PrintAuditCreateOrConnectWithoutUserInput[]
    createMany?: PrintAuditCreateManyUserInputEnvelope
    connect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutUserInput | InventoryMovementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutUserInput | InventoryMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutUserInput | InventoryMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCreatedByInput | OrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCreatedByInput | OrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCreatedByInput | OrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput> | OrderCreateWithoutApprovedByInput[] | OrderUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutApprovedByInput | OrderCreateOrConnectWithoutApprovedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutApprovedByInput | OrderUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: OrderCreateManyApprovedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutApprovedByInput | OrderUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutApprovedByInput | OrderUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatedByInput | InvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceivedByInput | PaymentUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceivedByInput | PaymentUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceivedByInput | PaymentUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PrintAuditUpdateManyWithoutUserNestedInput = {
    create?: XOR<PrintAuditCreateWithoutUserInput, PrintAuditUncheckedCreateWithoutUserInput> | PrintAuditCreateWithoutUserInput[] | PrintAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrintAuditCreateOrConnectWithoutUserInput | PrintAuditCreateOrConnectWithoutUserInput[]
    upsert?: PrintAuditUpsertWithWhereUniqueWithoutUserInput | PrintAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PrintAuditCreateManyUserInputEnvelope
    set?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    disconnect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    delete?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    connect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    update?: PrintAuditUpdateWithWhereUniqueWithoutUserInput | PrintAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PrintAuditUpdateManyWithWhereWithoutUserInput | PrintAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PrintAuditScalarWhereInput | PrintAuditScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutUserInput | InventoryMovementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutUserInput | InventoryMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutUserInput | InventoryMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput> | OrderCreateWithoutCreatedByInput[] | OrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatedByInput | OrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCreatedByInput | OrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrderCreateManyCreatedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCreatedByInput | OrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCreatedByInput | OrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput> | OrderCreateWithoutApprovedByInput[] | OrderUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutApprovedByInput | OrderCreateOrConnectWithoutApprovedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutApprovedByInput | OrderUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: OrderCreateManyApprovedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutApprovedByInput | OrderUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutApprovedByInput | OrderUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput> | InvoiceCreateWithoutCreatedByInput[] | InvoiceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCreatedByInput | InvoiceCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceCreateManyCreatedByInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCreatedByInput | InvoiceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput> | PaymentCreateWithoutReceivedByInput[] | PaymentUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceivedByInput | PaymentCreateOrConnectWithoutReceivedByInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceivedByInput | PaymentUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: PaymentCreateManyReceivedByInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceivedByInput | PaymentUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceivedByInput | PaymentUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PrintAuditUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PrintAuditCreateWithoutUserInput, PrintAuditUncheckedCreateWithoutUserInput> | PrintAuditCreateWithoutUserInput[] | PrintAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PrintAuditCreateOrConnectWithoutUserInput | PrintAuditCreateOrConnectWithoutUserInput[]
    upsert?: PrintAuditUpsertWithWhereUniqueWithoutUserInput | PrintAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PrintAuditCreateManyUserInputEnvelope
    set?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    disconnect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    delete?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    connect?: PrintAuditWhereUniqueInput | PrintAuditWhereUniqueInput[]
    update?: PrintAuditUpdateWithWhereUniqueWithoutUserInput | PrintAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PrintAuditUpdateManyWithWhereWithoutUserInput | PrintAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PrintAuditScalarWhereInput | PrintAuditScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type PlatformAdminRefreshTokenCreateNestedManyWithoutAdminInput = {
    create?: XOR<PlatformAdminRefreshTokenCreateWithoutAdminInput, PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput> | PlatformAdminRefreshTokenCreateWithoutAdminInput[] | PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput | PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput[]
    createMany?: PlatformAdminRefreshTokenCreateManyAdminInputEnvelope
    connect?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
  }

  export type PlatformAdminRefreshTokenUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<PlatformAdminRefreshTokenCreateWithoutAdminInput, PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput> | PlatformAdminRefreshTokenCreateWithoutAdminInput[] | PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput | PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput[]
    createMany?: PlatformAdminRefreshTokenCreateManyAdminInputEnvelope
    connect?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
  }

  export type PlatformAdminRefreshTokenUpdateManyWithoutAdminNestedInput = {
    create?: XOR<PlatformAdminRefreshTokenCreateWithoutAdminInput, PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput> | PlatformAdminRefreshTokenCreateWithoutAdminInput[] | PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput | PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput[]
    upsert?: PlatformAdminRefreshTokenUpsertWithWhereUniqueWithoutAdminInput | PlatformAdminRefreshTokenUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: PlatformAdminRefreshTokenCreateManyAdminInputEnvelope
    set?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
    disconnect?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
    delete?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
    connect?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
    update?: PlatformAdminRefreshTokenUpdateWithWhereUniqueWithoutAdminInput | PlatformAdminRefreshTokenUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: PlatformAdminRefreshTokenUpdateManyWithWhereWithoutAdminInput | PlatformAdminRefreshTokenUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: PlatformAdminRefreshTokenScalarWhereInput | PlatformAdminRefreshTokenScalarWhereInput[]
  }

  export type PlatformAdminRefreshTokenUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<PlatformAdminRefreshTokenCreateWithoutAdminInput, PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput> | PlatformAdminRefreshTokenCreateWithoutAdminInput[] | PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput | PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput[]
    upsert?: PlatformAdminRefreshTokenUpsertWithWhereUniqueWithoutAdminInput | PlatformAdminRefreshTokenUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: PlatformAdminRefreshTokenCreateManyAdminInputEnvelope
    set?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
    disconnect?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
    delete?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
    connect?: PlatformAdminRefreshTokenWhereUniqueInput | PlatformAdminRefreshTokenWhereUniqueInput[]
    update?: PlatformAdminRefreshTokenUpdateWithWhereUniqueWithoutAdminInput | PlatformAdminRefreshTokenUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: PlatformAdminRefreshTokenUpdateManyWithWhereWithoutAdminInput | PlatformAdminRefreshTokenUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: PlatformAdminRefreshTokenScalarWhereInput | PlatformAdminRefreshTokenScalarWhereInput[]
  }

  export type PlatformAdminCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<PlatformAdminCreateWithoutRefreshTokensInput, PlatformAdminUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: PlatformAdminCreateOrConnectWithoutRefreshTokensInput
    connect?: PlatformAdminWhereUniqueInput
  }

  export type PlatformAdminUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<PlatformAdminCreateWithoutRefreshTokensInput, PlatformAdminUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: PlatformAdminCreateOrConnectWithoutRefreshTokensInput
    upsert?: PlatformAdminUpsertWithoutRefreshTokensInput
    connect?: PlatformAdminWhereUniqueInput
    update?: XOR<XOR<PlatformAdminUpdateToOneWithWhereWithoutRefreshTokensInput, PlatformAdminUpdateWithoutRefreshTokensInput>, PlatformAdminUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type TenantCreateNestedOneWithoutRolesInput = {
    create?: XOR<TenantCreateWithoutRolesInput, TenantUncheckedCreateWithoutRolesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRolesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCustomRoleInput = {
    create?: XOR<UserCreateWithoutCustomRoleInput, UserUncheckedCreateWithoutCustomRoleInput> | UserCreateWithoutCustomRoleInput[] | UserUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomRoleInput | UserCreateOrConnectWithoutCustomRoleInput[]
    createMany?: UserCreateManyCustomRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCustomRoleInput = {
    create?: XOR<UserCreateWithoutCustomRoleInput, UserUncheckedCreateWithoutCustomRoleInput> | UserCreateWithoutCustomRoleInput[] | UserUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomRoleInput | UserCreateOrConnectWithoutCustomRoleInput[]
    createMany?: UserCreateManyCustomRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<TenantCreateWithoutRolesInput, TenantUncheckedCreateWithoutRolesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRolesInput
    upsert?: TenantUpsertWithoutRolesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRolesInput, TenantUpdateWithoutRolesInput>, TenantUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateManyWithoutCustomRoleNestedInput = {
    create?: XOR<UserCreateWithoutCustomRoleInput, UserUncheckedCreateWithoutCustomRoleInput> | UserCreateWithoutCustomRoleInput[] | UserUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomRoleInput | UserCreateOrConnectWithoutCustomRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCustomRoleInput | UserUpsertWithWhereUniqueWithoutCustomRoleInput[]
    createMany?: UserCreateManyCustomRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCustomRoleInput | UserUpdateWithWhereUniqueWithoutCustomRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCustomRoleInput | UserUpdateManyWithWhereWithoutCustomRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCustomRoleNestedInput = {
    create?: XOR<UserCreateWithoutCustomRoleInput, UserUncheckedCreateWithoutCustomRoleInput> | UserCreateWithoutCustomRoleInput[] | UserUncheckedCreateWithoutCustomRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomRoleInput | UserCreateOrConnectWithoutCustomRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCustomRoleInput | UserUpsertWithWhereUniqueWithoutCustomRoleInput[]
    createMany?: UserCreateManyCustomRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCustomRoleInput | UserUpdateWithWhereUniqueWithoutCustomRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCustomRoleInput | UserUpdateManyWithWhereWithoutCustomRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type TenantCreateNestedOneWithoutLicensesInput = {
    create?: XOR<TenantCreateWithoutLicensesInput, TenantUncheckedCreateWithoutLicensesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLicensesInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutLicensesNestedInput = {
    create?: XOR<TenantCreateWithoutLicensesInput, TenantUncheckedCreateWithoutLicensesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLicensesInput
    upsert?: TenantUpsertWithoutLicensesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLicensesInput, TenantUpdateWithoutLicensesInput>, TenantUncheckedUpdateWithoutLicensesInput>
  }

  export type TenantCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCategoriesInput
    connect?: TenantWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCategoriesInput
    upsert?: TenantUpsertWithoutCategoriesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCategoriesInput, TenantUpdateWithoutCategoriesInput>, TenantUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutProductsInput = {
    create?: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductsInput
    connect?: TenantWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type InventoryItemCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput> | InventoryMovementCreateWithoutProductInput[] | InventoryMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProductInput | InventoryMovementCreateOrConnectWithoutProductInput[]
    createMany?: InventoryMovementCreateManyProductInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type SupplierProductCreateNestedManyWithoutProductInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput> | InventoryMovementCreateWithoutProductInput[] | InventoryMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProductInput | InventoryMovementCreateOrConnectWithoutProductInput[]
    createMany?: InventoryMovementCreateManyProductInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type SupplierProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus
  }

  export type TenantUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductsInput
    upsert?: TenantUpsertWithoutProductsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutProductsInput, TenantUpdateWithoutProductsInput>, TenantUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type InventoryItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutProductInput | InventoryItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutProductInput | InventoryItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutProductInput | InventoryItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput> | InventoryMovementCreateWithoutProductInput[] | InventoryMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProductInput | InventoryMovementCreateOrConnectWithoutProductInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutProductInput | InventoryMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryMovementCreateManyProductInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutProductInput | InventoryMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutProductInput | InventoryMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type SupplierProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutProductInput | SupplierProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutProductInput | SupplierProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutProductInput | SupplierProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput> | InventoryItemCreateWithoutProductInput[] | InventoryItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutProductInput | InventoryItemCreateOrConnectWithoutProductInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutProductInput | InventoryItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryItemCreateManyProductInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutProductInput | InventoryItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutProductInput | InventoryItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput> | InventoryMovementCreateWithoutProductInput[] | InventoryMovementUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutProductInput | InventoryMovementCreateOrConnectWithoutProductInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutProductInput | InventoryMovementUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryMovementCreateManyProductInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutProductInput | InventoryMovementUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutProductInput | InventoryMovementUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput> | InvoiceItemCreateWithoutProductInput[] | InvoiceItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutProductInput | InvoiceItemCreateOrConnectWithoutProductInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutProductInput | InvoiceItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InvoiceItemCreateManyProductInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutProductInput | InvoiceItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutProductInput | InvoiceItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type SupplierProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput> | SupplierProductCreateWithoutProductInput[] | SupplierProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutProductInput | SupplierProductCreateOrConnectWithoutProductInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutProductInput | SupplierProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SupplierProductCreateManyProductInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutProductInput | SupplierProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutProductInput | SupplierProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutWarehousesInput = {
    create?: XOR<TenantCreateWithoutWarehousesInput, TenantUncheckedCreateWithoutWarehousesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWarehousesInput
    connect?: TenantWhereUniqueInput
  }

  export type InventoryItemCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutFromWarehouseInput = {
    create?: XOR<InventoryMovementCreateWithoutFromWarehouseInput, InventoryMovementUncheckedCreateWithoutFromWarehouseInput> | InventoryMovementCreateWithoutFromWarehouseInput[] | InventoryMovementUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutFromWarehouseInput | InventoryMovementCreateOrConnectWithoutFromWarehouseInput[]
    createMany?: InventoryMovementCreateManyFromWarehouseInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutToWarehouseInput = {
    create?: XOR<InventoryMovementCreateWithoutToWarehouseInput, InventoryMovementUncheckedCreateWithoutToWarehouseInput> | InventoryMovementCreateWithoutToWarehouseInput[] | InventoryMovementUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutToWarehouseInput | InventoryMovementCreateOrConnectWithoutToWarehouseInput[]
    createMany?: InventoryMovementCreateManyToWarehouseInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<OrderCreateWithoutWarehouseInput, OrderUncheckedCreateWithoutWarehouseInput> | OrderCreateWithoutWarehouseInput[] | OrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWarehouseInput | OrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: OrderCreateManyWarehouseInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutFromWarehouseInput = {
    create?: XOR<InventoryMovementCreateWithoutFromWarehouseInput, InventoryMovementUncheckedCreateWithoutFromWarehouseInput> | InventoryMovementCreateWithoutFromWarehouseInput[] | InventoryMovementUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutFromWarehouseInput | InventoryMovementCreateOrConnectWithoutFromWarehouseInput[]
    createMany?: InventoryMovementCreateManyFromWarehouseInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutToWarehouseInput = {
    create?: XOR<InventoryMovementCreateWithoutToWarehouseInput, InventoryMovementUncheckedCreateWithoutToWarehouseInput> | InventoryMovementCreateWithoutToWarehouseInput[] | InventoryMovementUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutToWarehouseInput | InventoryMovementCreateOrConnectWithoutToWarehouseInput[]
    createMany?: InventoryMovementCreateManyToWarehouseInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<OrderCreateWithoutWarehouseInput, OrderUncheckedCreateWithoutWarehouseInput> | OrderCreateWithoutWarehouseInput[] | OrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWarehouseInput | OrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: OrderCreateManyWarehouseInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type EnumWarehouseTypeFieldUpdateOperationsInput = {
    set?: $Enums.WarehouseType
  }

  export type TenantUpdateOneRequiredWithoutWarehousesNestedInput = {
    create?: XOR<TenantCreateWithoutWarehousesInput, TenantUncheckedCreateWithoutWarehousesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWarehousesInput
    upsert?: TenantUpsertWithoutWarehousesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWarehousesInput, TenantUpdateWithoutWarehousesInput>, TenantUncheckedUpdateWithoutWarehousesInput>
  }

  export type InventoryItemUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutWarehouseInput | InventoryItemUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutFromWarehouseNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutFromWarehouseInput, InventoryMovementUncheckedCreateWithoutFromWarehouseInput> | InventoryMovementCreateWithoutFromWarehouseInput[] | InventoryMovementUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutFromWarehouseInput | InventoryMovementCreateOrConnectWithoutFromWarehouseInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutFromWarehouseInput | InventoryMovementUpsertWithWhereUniqueWithoutFromWarehouseInput[]
    createMany?: InventoryMovementCreateManyFromWarehouseInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutFromWarehouseInput | InventoryMovementUpdateWithWhereUniqueWithoutFromWarehouseInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutFromWarehouseInput | InventoryMovementUpdateManyWithWhereWithoutFromWarehouseInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutToWarehouseNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutToWarehouseInput, InventoryMovementUncheckedCreateWithoutToWarehouseInput> | InventoryMovementCreateWithoutToWarehouseInput[] | InventoryMovementUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutToWarehouseInput | InventoryMovementCreateOrConnectWithoutToWarehouseInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutToWarehouseInput | InventoryMovementUpsertWithWhereUniqueWithoutToWarehouseInput[]
    createMany?: InventoryMovementCreateManyToWarehouseInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutToWarehouseInput | InventoryMovementUpdateWithWhereUniqueWithoutToWarehouseInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutToWarehouseInput | InventoryMovementUpdateManyWithWhereWithoutToWarehouseInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<OrderCreateWithoutWarehouseInput, OrderUncheckedCreateWithoutWarehouseInput> | OrderCreateWithoutWarehouseInput[] | OrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWarehouseInput | OrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWarehouseInput | OrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: OrderCreateManyWarehouseInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWarehouseInput | OrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWarehouseInput | OrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput> | InventoryItemCreateWithoutWarehouseInput[] | InventoryItemUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutWarehouseInput | InventoryItemCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput | InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryItemCreateManyWarehouseInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput | InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutWarehouseInput | InventoryItemUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutFromWarehouseNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutFromWarehouseInput, InventoryMovementUncheckedCreateWithoutFromWarehouseInput> | InventoryMovementCreateWithoutFromWarehouseInput[] | InventoryMovementUncheckedCreateWithoutFromWarehouseInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutFromWarehouseInput | InventoryMovementCreateOrConnectWithoutFromWarehouseInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutFromWarehouseInput | InventoryMovementUpsertWithWhereUniqueWithoutFromWarehouseInput[]
    createMany?: InventoryMovementCreateManyFromWarehouseInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutFromWarehouseInput | InventoryMovementUpdateWithWhereUniqueWithoutFromWarehouseInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutFromWarehouseInput | InventoryMovementUpdateManyWithWhereWithoutFromWarehouseInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutToWarehouseNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutToWarehouseInput, InventoryMovementUncheckedCreateWithoutToWarehouseInput> | InventoryMovementCreateWithoutToWarehouseInput[] | InventoryMovementUncheckedCreateWithoutToWarehouseInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutToWarehouseInput | InventoryMovementCreateOrConnectWithoutToWarehouseInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutToWarehouseInput | InventoryMovementUpsertWithWhereUniqueWithoutToWarehouseInput[]
    createMany?: InventoryMovementCreateManyToWarehouseInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutToWarehouseInput | InventoryMovementUpdateWithWhereUniqueWithoutToWarehouseInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutToWarehouseInput | InventoryMovementUpdateManyWithWhereWithoutToWarehouseInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<OrderCreateWithoutWarehouseInput, OrderUncheckedCreateWithoutWarehouseInput> | OrderCreateWithoutWarehouseInput[] | OrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutWarehouseInput | OrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutWarehouseInput | OrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: OrderCreateManyWarehouseInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutWarehouseInput | OrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutWarehouseInput | OrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<TenantCreateWithoutInventoryItemsInput, TenantUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryItemsInput
    connect?: TenantWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryItemsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<TenantCreateWithoutInventoryItemsInput, TenantUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryItemsInput
    upsert?: TenantUpsertWithoutInventoryItemsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInventoryItemsInput, TenantUpdateWithoutInventoryItemsInput>, TenantUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryItemsInput
    upsert?: ProductUpsertWithoutInventoryItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryItemsInput, ProductUpdateWithoutInventoryItemsInput>, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryItemsInput
    upsert?: WarehouseUpsertWithoutInventoryItemsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutInventoryItemsInput, WarehouseUpdateWithoutInventoryItemsInput>, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type TenantCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<TenantCreateWithoutInventoryMovementsInput, TenantUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryMovementsInput
    connect?: TenantWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<ProductCreateWithoutInventoryMovementsInput, ProductUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryMovementsInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutMovementsFromInput = {
    create?: XOR<WarehouseCreateWithoutMovementsFromInput, WarehouseUncheckedCreateWithoutMovementsFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutMovementsFromInput
    connect?: WarehouseWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutMovementsToInput = {
    create?: XOR<WarehouseCreateWithoutMovementsToInput, WarehouseUncheckedCreateWithoutMovementsToInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutMovementsToInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.MovementType
  }

  export type TenantUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<TenantCreateWithoutInventoryMovementsInput, TenantUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryMovementsInput
    upsert?: TenantUpsertWithoutInventoryMovementsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInventoryMovementsInput, TenantUpdateWithoutInventoryMovementsInput>, TenantUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type ProductUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<ProductCreateWithoutInventoryMovementsInput, ProductUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoryMovementsInput
    upsert?: ProductUpsertWithoutInventoryMovementsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoryMovementsInput, ProductUpdateWithoutInventoryMovementsInput>, ProductUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type WarehouseUpdateOneWithoutMovementsFromNestedInput = {
    create?: XOR<WarehouseCreateWithoutMovementsFromInput, WarehouseUncheckedCreateWithoutMovementsFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutMovementsFromInput
    upsert?: WarehouseUpsertWithoutMovementsFromInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutMovementsFromInput, WarehouseUpdateWithoutMovementsFromInput>, WarehouseUncheckedUpdateWithoutMovementsFromInput>
  }

  export type WarehouseUpdateOneWithoutMovementsToNestedInput = {
    create?: XOR<WarehouseCreateWithoutMovementsToInput, WarehouseUncheckedCreateWithoutMovementsToInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutMovementsToInput
    upsert?: WarehouseUpsertWithoutMovementsToInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutMovementsToInput, WarehouseUpdateWithoutMovementsToInput>, WarehouseUncheckedUpdateWithoutMovementsToInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    upsert?: UserUpsertWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryMovementsInput, UserUpdateWithoutInventoryMovementsInput>, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type TenantCreateNestedOneWithoutCustomersInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumCustomerTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerType
  }

  export type TenantUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    upsert?: TenantUpsertWithoutCustomersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCustomersInput, TenantUpdateWithoutCustomersInput>, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSuppliersInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<OrderCreateWithoutSupplierInput, OrderUncheckedCreateWithoutSupplierInput> | OrderCreateWithoutSupplierInput[] | OrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSupplierInput | OrderCreateOrConnectWithoutSupplierInput[]
    createMany?: OrderCreateManySupplierInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SupplierProductCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<OrderCreateWithoutSupplierInput, OrderUncheckedCreateWithoutSupplierInput> | OrderCreateWithoutSupplierInput[] | OrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSupplierInput | OrderCreateOrConnectWithoutSupplierInput[]
    createMany?: OrderCreateManySupplierInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SupplierProductUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSuppliersInput
    upsert?: TenantUpsertWithoutSuppliersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSuppliersInput, TenantUpdateWithoutSuppliersInput>, TenantUncheckedUpdateWithoutSuppliersInput>
  }

  export type OrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<OrderCreateWithoutSupplierInput, OrderUncheckedCreateWithoutSupplierInput> | OrderCreateWithoutSupplierInput[] | OrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSupplierInput | OrderCreateOrConnectWithoutSupplierInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSupplierInput | OrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: OrderCreateManySupplierInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSupplierInput | OrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSupplierInput | OrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SupplierProductUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutSupplierInput | SupplierProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutSupplierInput | SupplierProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutSupplierInput | SupplierProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<OrderCreateWithoutSupplierInput, OrderUncheckedCreateWithoutSupplierInput> | OrderCreateWithoutSupplierInput[] | OrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSupplierInput | OrderCreateOrConnectWithoutSupplierInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSupplierInput | OrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: OrderCreateManySupplierInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSupplierInput | OrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSupplierInput | OrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput> | SupplierProductCreateWithoutSupplierInput[] | SupplierProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierProductCreateOrConnectWithoutSupplierInput | SupplierProductCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierProductUpsertWithWhereUniqueWithoutSupplierInput | SupplierProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierProductCreateManySupplierInputEnvelope
    set?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    disconnect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    delete?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    connect?: SupplierProductWhereUniqueInput | SupplierProductWhereUniqueInput[]
    update?: SupplierProductUpdateWithWhereUniqueWithoutSupplierInput | SupplierProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierProductUpdateManyWithWhereWithoutSupplierInput | SupplierProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
  }

  export type SupplierCreateNestedOneWithoutSupplierProductsInput = {
    create?: XOR<SupplierCreateWithoutSupplierProductsInput, SupplierUncheckedCreateWithoutSupplierProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSupplierProductsInput
    connect?: SupplierWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSupplierProductsInput = {
    create?: XOR<ProductCreateWithoutSupplierProductsInput, ProductUncheckedCreateWithoutSupplierProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type SupplierUpdateOneRequiredWithoutSupplierProductsNestedInput = {
    create?: XOR<SupplierCreateWithoutSupplierProductsInput, SupplierUncheckedCreateWithoutSupplierProductsInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutSupplierProductsInput
    upsert?: SupplierUpsertWithoutSupplierProductsInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutSupplierProductsInput, SupplierUpdateWithoutSupplierProductsInput>, SupplierUncheckedUpdateWithoutSupplierProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutSupplierProductsNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierProductsInput, ProductUncheckedCreateWithoutSupplierProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierProductsInput
    upsert?: ProductUpsertWithoutSupplierProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSupplierProductsInput, ProductUpdateWithoutSupplierProductsInput>, ProductUncheckedUpdateWithoutSupplierProductsInput>
  }

  export type TenantCreateNestedOneWithoutOrdersInput = {
    create?: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutOrdersInput = {
    create?: XOR<SupplierCreateWithoutOrdersInput, SupplierUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutOrdersShipFromInput = {
    create?: XOR<WarehouseCreateWithoutOrdersShipFromInput, WarehouseUncheckedCreateWithoutOrdersShipFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutOrdersShipFromInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersCreatedInput = {
    create?: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersApprovedInput = {
    create?: XOR<UserCreateWithoutOrdersApprovedInput, UserUncheckedCreateWithoutOrdersApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersApprovedInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type EnumOrderTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderType
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type TenantUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOrdersInput
    upsert?: TenantUpsertWithoutOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOrdersInput, TenantUpdateWithoutOrdersInput>, TenantUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type SupplierUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutOrdersInput, SupplierUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutOrdersInput
    upsert?: SupplierUpsertWithoutOrdersInput
    disconnect?: SupplierWhereInput | boolean
    delete?: SupplierWhereInput | boolean
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutOrdersInput, SupplierUpdateWithoutOrdersInput>, SupplierUncheckedUpdateWithoutOrdersInput>
  }

  export type WarehouseUpdateOneWithoutOrdersShipFromNestedInput = {
    create?: XOR<WarehouseCreateWithoutOrdersShipFromInput, WarehouseUncheckedCreateWithoutOrdersShipFromInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutOrdersShipFromInput
    upsert?: WarehouseUpsertWithoutOrdersShipFromInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutOrdersShipFromInput, WarehouseUpdateWithoutOrdersShipFromInput>, WarehouseUncheckedUpdateWithoutOrdersShipFromInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersCreatedNestedInput = {
    create?: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersCreatedInput
    upsert?: UserUpsertWithoutOrdersCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersCreatedInput, UserUpdateWithoutOrdersCreatedInput>, UserUncheckedUpdateWithoutOrdersCreatedInput>
  }

  export type UserUpdateOneWithoutOrdersApprovedNestedInput = {
    create?: XOR<UserCreateWithoutOrdersApprovedInput, UserUncheckedCreateWithoutOrdersApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersApprovedInput
    upsert?: UserUpsertWithoutOrdersApprovedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersApprovedInput, UserUpdateWithoutOrdersApprovedInput>, UserUncheckedUpdateWithoutOrdersApprovedInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrderInput | InvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrderInput | InvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrderInput | InvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput> | InvoiceCreateWithoutOrderInput[] | InvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput | InvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutOrderInput | InvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: InvoiceCreateManyOrderInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutOrderInput | InvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutOrderInput | InvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type TenantCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoicesInput
    connect?: OrderWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoicesCreatedInput = {
    create?: XOR<UserCreateWithoutInvoicesCreatedInput, UserUncheckedCreateWithoutInvoicesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EInvoiceCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<EInvoiceCreateWithoutInvoiceInput, EInvoiceUncheckedCreateWithoutInvoiceInput> | EInvoiceCreateWithoutInvoiceInput[] | EInvoiceUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutInvoiceInput | EInvoiceCreateOrConnectWithoutInvoiceInput[]
    createMany?: EInvoiceCreateManyInvoiceInputEnvelope
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EInvoiceUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<EInvoiceCreateWithoutInvoiceInput, EInvoiceUncheckedCreateWithoutInvoiceInput> | EInvoiceCreateWithoutInvoiceInput[] | EInvoiceUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutInvoiceInput | EInvoiceCreateOrConnectWithoutInvoiceInput[]
    createMany?: EInvoiceCreateManyInvoiceInputEnvelope
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type TenantUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    upsert?: TenantUpsertWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicesInput, TenantUpdateWithoutInvoicesInput>, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoicesInput
    upsert?: OrderUpsertWithoutInvoicesInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoicesInput, OrderUpdateWithoutInvoicesInput>, OrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvoicesInput
    upsert?: CustomerUpsertWithoutInvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvoicesInput, CustomerUpdateWithoutInvoicesInput>, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateOneRequiredWithoutInvoicesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesCreatedInput, UserUncheckedCreateWithoutInvoicesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesCreatedInput
    upsert?: UserUpsertWithoutInvoicesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesCreatedInput, UserUpdateWithoutInvoicesCreatedInput>, UserUncheckedUpdateWithoutInvoicesCreatedInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EInvoiceUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<EInvoiceCreateWithoutInvoiceInput, EInvoiceUncheckedCreateWithoutInvoiceInput> | EInvoiceCreateWithoutInvoiceInput[] | EInvoiceUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutInvoiceInput | EInvoiceCreateOrConnectWithoutInvoiceInput[]
    upsert?: EInvoiceUpsertWithWhereUniqueWithoutInvoiceInput | EInvoiceUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: EInvoiceCreateManyInvoiceInputEnvelope
    set?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    disconnect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    delete?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    update?: EInvoiceUpdateWithWhereUniqueWithoutInvoiceInput | EInvoiceUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: EInvoiceUpdateManyWithWhereWithoutInvoiceInput | EInvoiceUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: EInvoiceScalarWhereInput | EInvoiceScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<EInvoiceCreateWithoutInvoiceInput, EInvoiceUncheckedCreateWithoutInvoiceInput> | EInvoiceCreateWithoutInvoiceInput[] | EInvoiceUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutInvoiceInput | EInvoiceCreateOrConnectWithoutInvoiceInput[]
    upsert?: EInvoiceUpsertWithWhereUniqueWithoutInvoiceInput | EInvoiceUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: EInvoiceCreateManyInvoiceInputEnvelope
    set?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    disconnect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    delete?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    update?: EInvoiceUpdateWithWhereUniqueWithoutInvoiceInput | EInvoiceUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: EInvoiceUpdateManyWithWhereWithoutInvoiceInput | EInvoiceUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: EInvoiceScalarWhereInput | EInvoiceScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type EInvoiceItemCreateNestedManyWithoutInvoiceItemInput = {
    create?: XOR<EInvoiceItemCreateWithoutInvoiceItemInput, EInvoiceItemUncheckedCreateWithoutInvoiceItemInput> | EInvoiceItemCreateWithoutInvoiceItemInput[] | EInvoiceItemUncheckedCreateWithoutInvoiceItemInput[]
    connectOrCreate?: EInvoiceItemCreateOrConnectWithoutInvoiceItemInput | EInvoiceItemCreateOrConnectWithoutInvoiceItemInput[]
    createMany?: EInvoiceItemCreateManyInvoiceItemInputEnvelope
    connect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
  }

  export type EInvoiceItemUncheckedCreateNestedManyWithoutInvoiceItemInput = {
    create?: XOR<EInvoiceItemCreateWithoutInvoiceItemInput, EInvoiceItemUncheckedCreateWithoutInvoiceItemInput> | EInvoiceItemCreateWithoutInvoiceItemInput[] | EInvoiceItemUncheckedCreateWithoutInvoiceItemInput[]
    connectOrCreate?: EInvoiceItemCreateOrConnectWithoutInvoiceItemInput | EInvoiceItemCreateOrConnectWithoutInvoiceItemInput[]
    createMany?: EInvoiceItemCreateManyInvoiceItemInputEnvelope
    connect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ProductUpsertWithoutInvoiceItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInvoiceItemsInput, ProductUpdateWithoutInvoiceItemsInput>, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type EInvoiceItemUpdateManyWithoutInvoiceItemNestedInput = {
    create?: XOR<EInvoiceItemCreateWithoutInvoiceItemInput, EInvoiceItemUncheckedCreateWithoutInvoiceItemInput> | EInvoiceItemCreateWithoutInvoiceItemInput[] | EInvoiceItemUncheckedCreateWithoutInvoiceItemInput[]
    connectOrCreate?: EInvoiceItemCreateOrConnectWithoutInvoiceItemInput | EInvoiceItemCreateOrConnectWithoutInvoiceItemInput[]
    upsert?: EInvoiceItemUpsertWithWhereUniqueWithoutInvoiceItemInput | EInvoiceItemUpsertWithWhereUniqueWithoutInvoiceItemInput[]
    createMany?: EInvoiceItemCreateManyInvoiceItemInputEnvelope
    set?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    disconnect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    delete?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    connect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    update?: EInvoiceItemUpdateWithWhereUniqueWithoutInvoiceItemInput | EInvoiceItemUpdateWithWhereUniqueWithoutInvoiceItemInput[]
    updateMany?: EInvoiceItemUpdateManyWithWhereWithoutInvoiceItemInput | EInvoiceItemUpdateManyWithWhereWithoutInvoiceItemInput[]
    deleteMany?: EInvoiceItemScalarWhereInput | EInvoiceItemScalarWhereInput[]
  }

  export type EInvoiceItemUncheckedUpdateManyWithoutInvoiceItemNestedInput = {
    create?: XOR<EInvoiceItemCreateWithoutInvoiceItemInput, EInvoiceItemUncheckedCreateWithoutInvoiceItemInput> | EInvoiceItemCreateWithoutInvoiceItemInput[] | EInvoiceItemUncheckedCreateWithoutInvoiceItemInput[]
    connectOrCreate?: EInvoiceItemCreateOrConnectWithoutInvoiceItemInput | EInvoiceItemCreateOrConnectWithoutInvoiceItemInput[]
    upsert?: EInvoiceItemUpsertWithWhereUniqueWithoutInvoiceItemInput | EInvoiceItemUpsertWithWhereUniqueWithoutInvoiceItemInput[]
    createMany?: EInvoiceItemCreateManyInvoiceItemInputEnvelope
    set?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    disconnect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    delete?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    connect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    update?: EInvoiceItemUpdateWithWhereUniqueWithoutInvoiceItemInput | EInvoiceItemUpdateWithWhereUniqueWithoutInvoiceItemInput[]
    updateMany?: EInvoiceItemUpdateManyWithWhereWithoutInvoiceItemInput | EInvoiceItemUpdateManyWithWhereWithoutInvoiceItemInput[]
    deleteMany?: EInvoiceItemScalarWhereInput | EInvoiceItemScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsReceivedInput = {
    create?: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type TenantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    upsert?: TenantUpsertWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentsInput, TenantUpdateWithoutPaymentsInput>, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsInput
    upsert?: CustomerUpsertWithoutPaymentsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentsInput, CustomerUpdateWithoutPaymentsInput>, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsReceivedInput
    upsert?: UserUpsertWithoutPaymentsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsReceivedInput, UserUpdateWithoutPaymentsReceivedInput>, UserUncheckedUpdateWithoutPaymentsReceivedInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantCreateNestedOneWithoutAssetsInput = {
    create?: XOR<TenantCreateWithoutAssetsInput, TenantUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAssetsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumAssetTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssetType
  }

  export type EnumAssetCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AssetCategory
  }

  export type EnumAssetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssetStatus
  }

  export type EnumDepreciationMethodFieldUpdateOperationsInput = {
    set?: $Enums.DepreciationMethod
  }

  export type TenantUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<TenantCreateWithoutAssetsInput, TenantUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAssetsInput
    upsert?: TenantUpsertWithoutAssetsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAssetsInput, TenantUpdateWithoutAssetsInput>, TenantUncheckedUpdateWithoutAssetsInput>
  }

  export type TenantCreateNestedOneWithoutEInvoicesInput = {
    create?: XOR<TenantCreateWithoutEInvoicesInput, TenantUncheckedCreateWithoutEInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutEInvoicesInput = {
    create?: XOR<InvoiceCreateWithoutEInvoicesInput, InvoiceUncheckedCreateWithoutEInvoicesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEInvoicesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EInvoiceCreateNestedOneWithoutRelatedEInvoicesInput = {
    create?: XOR<EInvoiceCreateWithoutRelatedEInvoicesInput, EInvoiceUncheckedCreateWithoutRelatedEInvoicesInput>
    connectOrCreate?: EInvoiceCreateOrConnectWithoutRelatedEInvoicesInput
    connect?: EInvoiceWhereUniqueInput
  }

  export type EInvoiceCreateNestedManyWithoutOriginalEInvoiceInput = {
    create?: XOR<EInvoiceCreateWithoutOriginalEInvoiceInput, EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput> | EInvoiceCreateWithoutOriginalEInvoiceInput[] | EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput | EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput[]
    createMany?: EInvoiceCreateManyOriginalEInvoiceInputEnvelope
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
  }

  export type EInvoiceItemCreateNestedManyWithoutEInvoiceInput = {
    create?: XOR<EInvoiceItemCreateWithoutEInvoiceInput, EInvoiceItemUncheckedCreateWithoutEInvoiceInput> | EInvoiceItemCreateWithoutEInvoiceInput[] | EInvoiceItemUncheckedCreateWithoutEInvoiceInput[]
    connectOrCreate?: EInvoiceItemCreateOrConnectWithoutEInvoiceInput | EInvoiceItemCreateOrConnectWithoutEInvoiceInput[]
    createMany?: EInvoiceItemCreateManyEInvoiceInputEnvelope
    connect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
  }

  export type EInvoiceLogCreateNestedManyWithoutEInvoiceInput = {
    create?: XOR<EInvoiceLogCreateWithoutEInvoiceInput, EInvoiceLogUncheckedCreateWithoutEInvoiceInput> | EInvoiceLogCreateWithoutEInvoiceInput[] | EInvoiceLogUncheckedCreateWithoutEInvoiceInput[]
    connectOrCreate?: EInvoiceLogCreateOrConnectWithoutEInvoiceInput | EInvoiceLogCreateOrConnectWithoutEInvoiceInput[]
    createMany?: EInvoiceLogCreateManyEInvoiceInputEnvelope
    connect?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
  }

  export type EInvoiceUncheckedCreateNestedManyWithoutOriginalEInvoiceInput = {
    create?: XOR<EInvoiceCreateWithoutOriginalEInvoiceInput, EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput> | EInvoiceCreateWithoutOriginalEInvoiceInput[] | EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput | EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput[]
    createMany?: EInvoiceCreateManyOriginalEInvoiceInputEnvelope
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
  }

  export type EInvoiceItemUncheckedCreateNestedManyWithoutEInvoiceInput = {
    create?: XOR<EInvoiceItemCreateWithoutEInvoiceInput, EInvoiceItemUncheckedCreateWithoutEInvoiceInput> | EInvoiceItemCreateWithoutEInvoiceInput[] | EInvoiceItemUncheckedCreateWithoutEInvoiceInput[]
    connectOrCreate?: EInvoiceItemCreateOrConnectWithoutEInvoiceInput | EInvoiceItemCreateOrConnectWithoutEInvoiceInput[]
    createMany?: EInvoiceItemCreateManyEInvoiceInputEnvelope
    connect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
  }

  export type EInvoiceLogUncheckedCreateNestedManyWithoutEInvoiceInput = {
    create?: XOR<EInvoiceLogCreateWithoutEInvoiceInput, EInvoiceLogUncheckedCreateWithoutEInvoiceInput> | EInvoiceLogCreateWithoutEInvoiceInput[] | EInvoiceLogUncheckedCreateWithoutEInvoiceInput[]
    connectOrCreate?: EInvoiceLogCreateOrConnectWithoutEInvoiceInput | EInvoiceLogCreateOrConnectWithoutEInvoiceInput[]
    createMany?: EInvoiceLogCreateManyEInvoiceInputEnvelope
    connect?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
  }

  export type EnumEInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.EInvoiceType
  }

  export type EnumEInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.EInvoiceStatus
  }

  export type TenantUpdateOneRequiredWithoutEInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutEInvoicesInput, TenantUncheckedCreateWithoutEInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEInvoicesInput
    upsert?: TenantUpsertWithoutEInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEInvoicesInput, TenantUpdateWithoutEInvoicesInput>, TenantUncheckedUpdateWithoutEInvoicesInput>
  }

  export type InvoiceUpdateOneRequiredWithoutEInvoicesNestedInput = {
    create?: XOR<InvoiceCreateWithoutEInvoicesInput, InvoiceUncheckedCreateWithoutEInvoicesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutEInvoicesInput
    upsert?: InvoiceUpsertWithoutEInvoicesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutEInvoicesInput, InvoiceUpdateWithoutEInvoicesInput>, InvoiceUncheckedUpdateWithoutEInvoicesInput>
  }

  export type EInvoiceUpdateOneWithoutRelatedEInvoicesNestedInput = {
    create?: XOR<EInvoiceCreateWithoutRelatedEInvoicesInput, EInvoiceUncheckedCreateWithoutRelatedEInvoicesInput>
    connectOrCreate?: EInvoiceCreateOrConnectWithoutRelatedEInvoicesInput
    upsert?: EInvoiceUpsertWithoutRelatedEInvoicesInput
    disconnect?: EInvoiceWhereInput | boolean
    delete?: EInvoiceWhereInput | boolean
    connect?: EInvoiceWhereUniqueInput
    update?: XOR<XOR<EInvoiceUpdateToOneWithWhereWithoutRelatedEInvoicesInput, EInvoiceUpdateWithoutRelatedEInvoicesInput>, EInvoiceUncheckedUpdateWithoutRelatedEInvoicesInput>
  }

  export type EInvoiceUpdateManyWithoutOriginalEInvoiceNestedInput = {
    create?: XOR<EInvoiceCreateWithoutOriginalEInvoiceInput, EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput> | EInvoiceCreateWithoutOriginalEInvoiceInput[] | EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput | EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput[]
    upsert?: EInvoiceUpsertWithWhereUniqueWithoutOriginalEInvoiceInput | EInvoiceUpsertWithWhereUniqueWithoutOriginalEInvoiceInput[]
    createMany?: EInvoiceCreateManyOriginalEInvoiceInputEnvelope
    set?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    disconnect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    delete?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    update?: EInvoiceUpdateWithWhereUniqueWithoutOriginalEInvoiceInput | EInvoiceUpdateWithWhereUniqueWithoutOriginalEInvoiceInput[]
    updateMany?: EInvoiceUpdateManyWithWhereWithoutOriginalEInvoiceInput | EInvoiceUpdateManyWithWhereWithoutOriginalEInvoiceInput[]
    deleteMany?: EInvoiceScalarWhereInput | EInvoiceScalarWhereInput[]
  }

  export type EInvoiceItemUpdateManyWithoutEInvoiceNestedInput = {
    create?: XOR<EInvoiceItemCreateWithoutEInvoiceInput, EInvoiceItemUncheckedCreateWithoutEInvoiceInput> | EInvoiceItemCreateWithoutEInvoiceInput[] | EInvoiceItemUncheckedCreateWithoutEInvoiceInput[]
    connectOrCreate?: EInvoiceItemCreateOrConnectWithoutEInvoiceInput | EInvoiceItemCreateOrConnectWithoutEInvoiceInput[]
    upsert?: EInvoiceItemUpsertWithWhereUniqueWithoutEInvoiceInput | EInvoiceItemUpsertWithWhereUniqueWithoutEInvoiceInput[]
    createMany?: EInvoiceItemCreateManyEInvoiceInputEnvelope
    set?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    disconnect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    delete?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    connect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    update?: EInvoiceItemUpdateWithWhereUniqueWithoutEInvoiceInput | EInvoiceItemUpdateWithWhereUniqueWithoutEInvoiceInput[]
    updateMany?: EInvoiceItemUpdateManyWithWhereWithoutEInvoiceInput | EInvoiceItemUpdateManyWithWhereWithoutEInvoiceInput[]
    deleteMany?: EInvoiceItemScalarWhereInput | EInvoiceItemScalarWhereInput[]
  }

  export type EInvoiceLogUpdateManyWithoutEInvoiceNestedInput = {
    create?: XOR<EInvoiceLogCreateWithoutEInvoiceInput, EInvoiceLogUncheckedCreateWithoutEInvoiceInput> | EInvoiceLogCreateWithoutEInvoiceInput[] | EInvoiceLogUncheckedCreateWithoutEInvoiceInput[]
    connectOrCreate?: EInvoiceLogCreateOrConnectWithoutEInvoiceInput | EInvoiceLogCreateOrConnectWithoutEInvoiceInput[]
    upsert?: EInvoiceLogUpsertWithWhereUniqueWithoutEInvoiceInput | EInvoiceLogUpsertWithWhereUniqueWithoutEInvoiceInput[]
    createMany?: EInvoiceLogCreateManyEInvoiceInputEnvelope
    set?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
    disconnect?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
    delete?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
    connect?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
    update?: EInvoiceLogUpdateWithWhereUniqueWithoutEInvoiceInput | EInvoiceLogUpdateWithWhereUniqueWithoutEInvoiceInput[]
    updateMany?: EInvoiceLogUpdateManyWithWhereWithoutEInvoiceInput | EInvoiceLogUpdateManyWithWhereWithoutEInvoiceInput[]
    deleteMany?: EInvoiceLogScalarWhereInput | EInvoiceLogScalarWhereInput[]
  }

  export type EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceNestedInput = {
    create?: XOR<EInvoiceCreateWithoutOriginalEInvoiceInput, EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput> | EInvoiceCreateWithoutOriginalEInvoiceInput[] | EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput[]
    connectOrCreate?: EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput | EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput[]
    upsert?: EInvoiceUpsertWithWhereUniqueWithoutOriginalEInvoiceInput | EInvoiceUpsertWithWhereUniqueWithoutOriginalEInvoiceInput[]
    createMany?: EInvoiceCreateManyOriginalEInvoiceInputEnvelope
    set?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    disconnect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    delete?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    connect?: EInvoiceWhereUniqueInput | EInvoiceWhereUniqueInput[]
    update?: EInvoiceUpdateWithWhereUniqueWithoutOriginalEInvoiceInput | EInvoiceUpdateWithWhereUniqueWithoutOriginalEInvoiceInput[]
    updateMany?: EInvoiceUpdateManyWithWhereWithoutOriginalEInvoiceInput | EInvoiceUpdateManyWithWhereWithoutOriginalEInvoiceInput[]
    deleteMany?: EInvoiceScalarWhereInput | EInvoiceScalarWhereInput[]
  }

  export type EInvoiceItemUncheckedUpdateManyWithoutEInvoiceNestedInput = {
    create?: XOR<EInvoiceItemCreateWithoutEInvoiceInput, EInvoiceItemUncheckedCreateWithoutEInvoiceInput> | EInvoiceItemCreateWithoutEInvoiceInput[] | EInvoiceItemUncheckedCreateWithoutEInvoiceInput[]
    connectOrCreate?: EInvoiceItemCreateOrConnectWithoutEInvoiceInput | EInvoiceItemCreateOrConnectWithoutEInvoiceInput[]
    upsert?: EInvoiceItemUpsertWithWhereUniqueWithoutEInvoiceInput | EInvoiceItemUpsertWithWhereUniqueWithoutEInvoiceInput[]
    createMany?: EInvoiceItemCreateManyEInvoiceInputEnvelope
    set?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    disconnect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    delete?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    connect?: EInvoiceItemWhereUniqueInput | EInvoiceItemWhereUniqueInput[]
    update?: EInvoiceItemUpdateWithWhereUniqueWithoutEInvoiceInput | EInvoiceItemUpdateWithWhereUniqueWithoutEInvoiceInput[]
    updateMany?: EInvoiceItemUpdateManyWithWhereWithoutEInvoiceInput | EInvoiceItemUpdateManyWithWhereWithoutEInvoiceInput[]
    deleteMany?: EInvoiceItemScalarWhereInput | EInvoiceItemScalarWhereInput[]
  }

  export type EInvoiceLogUncheckedUpdateManyWithoutEInvoiceNestedInput = {
    create?: XOR<EInvoiceLogCreateWithoutEInvoiceInput, EInvoiceLogUncheckedCreateWithoutEInvoiceInput> | EInvoiceLogCreateWithoutEInvoiceInput[] | EInvoiceLogUncheckedCreateWithoutEInvoiceInput[]
    connectOrCreate?: EInvoiceLogCreateOrConnectWithoutEInvoiceInput | EInvoiceLogCreateOrConnectWithoutEInvoiceInput[]
    upsert?: EInvoiceLogUpsertWithWhereUniqueWithoutEInvoiceInput | EInvoiceLogUpsertWithWhereUniqueWithoutEInvoiceInput[]
    createMany?: EInvoiceLogCreateManyEInvoiceInputEnvelope
    set?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
    disconnect?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
    delete?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
    connect?: EInvoiceLogWhereUniqueInput | EInvoiceLogWhereUniqueInput[]
    update?: EInvoiceLogUpdateWithWhereUniqueWithoutEInvoiceInput | EInvoiceLogUpdateWithWhereUniqueWithoutEInvoiceInput[]
    updateMany?: EInvoiceLogUpdateManyWithWhereWithoutEInvoiceInput | EInvoiceLogUpdateManyWithWhereWithoutEInvoiceInput[]
    deleteMany?: EInvoiceLogScalarWhereInput | EInvoiceLogScalarWhereInput[]
  }

  export type EInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<EInvoiceCreateWithoutItemsInput, EInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: EInvoiceCreateOrConnectWithoutItemsInput
    connect?: EInvoiceWhereUniqueInput
  }

  export type InvoiceItemCreateNestedOneWithoutEInvoiceItemsInput = {
    create?: XOR<InvoiceItemCreateWithoutEInvoiceItemsInput, InvoiceItemUncheckedCreateWithoutEInvoiceItemsInput>
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutEInvoiceItemsInput
    connect?: InvoiceItemWhereUniqueInput
  }

  export type EInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<EInvoiceCreateWithoutItemsInput, EInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: EInvoiceCreateOrConnectWithoutItemsInput
    upsert?: EInvoiceUpsertWithoutItemsInput
    connect?: EInvoiceWhereUniqueInput
    update?: XOR<XOR<EInvoiceUpdateToOneWithWhereWithoutItemsInput, EInvoiceUpdateWithoutItemsInput>, EInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceItemUpdateOneWithoutEInvoiceItemsNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutEInvoiceItemsInput, InvoiceItemUncheckedCreateWithoutEInvoiceItemsInput>
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutEInvoiceItemsInput
    upsert?: InvoiceItemUpsertWithoutEInvoiceItemsInput
    disconnect?: InvoiceItemWhereInput | boolean
    delete?: InvoiceItemWhereInput | boolean
    connect?: InvoiceItemWhereUniqueInput
    update?: XOR<XOR<InvoiceItemUpdateToOneWithWhereWithoutEInvoiceItemsInput, InvoiceItemUpdateWithoutEInvoiceItemsInput>, InvoiceItemUncheckedUpdateWithoutEInvoiceItemsInput>
  }

  export type EInvoiceCreateNestedOneWithoutLogsInput = {
    create?: XOR<EInvoiceCreateWithoutLogsInput, EInvoiceUncheckedCreateWithoutLogsInput>
    connectOrCreate?: EInvoiceCreateOrConnectWithoutLogsInput
    connect?: EInvoiceWhereUniqueInput
  }

  export type EInvoiceUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<EInvoiceCreateWithoutLogsInput, EInvoiceUncheckedCreateWithoutLogsInput>
    connectOrCreate?: EInvoiceCreateOrConnectWithoutLogsInput
    upsert?: EInvoiceUpsertWithoutLogsInput
    connect?: EInvoiceWhereUniqueInput
    update?: XOR<XOR<EInvoiceUpdateToOneWithWhereWithoutLogsInput, EInvoiceUpdateWithoutLogsInput>, EInvoiceUncheckedUpdateWithoutLogsInput>
  }

  export type TenantCreateNestedOneWithoutLhdnTokenInput = {
    create?: XOR<TenantCreateWithoutLhdnTokenInput, TenantUncheckedCreateWithoutLhdnTokenInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLhdnTokenInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutLhdnTokenNestedInput = {
    create?: XOR<TenantCreateWithoutLhdnTokenInput, TenantUncheckedCreateWithoutLhdnTokenInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLhdnTokenInput
    upsert?: TenantUpsertWithoutLhdnTokenInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLhdnTokenInput, TenantUpdateWithoutLhdnTokenInput>, TenantUncheckedUpdateWithoutLhdnTokenInput>
  }

  export type TenantCreateNestedOneWithoutLhdnCredentialInput = {
    create?: XOR<TenantCreateWithoutLhdnCredentialInput, TenantUncheckedCreateWithoutLhdnCredentialInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLhdnCredentialInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumLhdnEnvironmentFieldUpdateOperationsInput = {
    set?: $Enums.LhdnEnvironment
  }

  export type TenantUpdateOneRequiredWithoutLhdnCredentialNestedInput = {
    create?: XOR<TenantCreateWithoutLhdnCredentialInput, TenantUncheckedCreateWithoutLhdnCredentialInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLhdnCredentialInput
    upsert?: TenantUpsertWithoutLhdnCredentialInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLhdnCredentialInput, TenantUpdateWithoutLhdnCredentialInput>, TenantUncheckedUpdateWithoutLhdnCredentialInput>
  }

  export type TenantCreateNestedOneWithoutCapabilitiesInput = {
    create?: XOR<TenantCreateWithoutCapabilitiesInput, TenantUncheckedCreateWithoutCapabilitiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCapabilitiesInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCapabilitiesNestedInput = {
    create?: XOR<TenantCreateWithoutCapabilitiesInput, TenantUncheckedCreateWithoutCapabilitiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCapabilitiesInput
    upsert?: TenantUpsertWithoutCapabilitiesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCapabilitiesInput, TenantUpdateWithoutCapabilitiesInput>, TenantUncheckedUpdateWithoutCapabilitiesInput>
  }

  export type TenantCreateNestedOneWithoutPrintAuditsInput = {
    create?: XOR<TenantCreateWithoutPrintAuditsInput, TenantUncheckedCreateWithoutPrintAuditsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPrintAuditsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPrintAuditsInput = {
    create?: XOR<UserCreateWithoutPrintAuditsInput, UserUncheckedCreateWithoutPrintAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrintAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPrintAuditsNestedInput = {
    create?: XOR<TenantCreateWithoutPrintAuditsInput, TenantUncheckedCreateWithoutPrintAuditsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPrintAuditsInput
    upsert?: TenantUpsertWithoutPrintAuditsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPrintAuditsInput, TenantUpdateWithoutPrintAuditsInput>, TenantUncheckedUpdateWithoutPrintAuditsInput>
  }

  export type UserUpdateOneRequiredWithoutPrintAuditsNestedInput = {
    create?: XOR<UserCreateWithoutPrintAuditsInput, UserUncheckedCreateWithoutPrintAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrintAuditsInput
    upsert?: UserUpsertWithoutPrintAuditsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrintAuditsInput, UserUpdateWithoutPrintAuditsInput>, UserUncheckedUpdateWithoutPrintAuditsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTenantStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusFilter<$PrismaModel> | $Enums.TenantStatus
  }

  export type NestedEnumLicenseTierFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseTier | EnumLicenseTierFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseTier[] | ListEnumLicenseTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseTier[] | ListEnumLicenseTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseTierFilter<$PrismaModel> | $Enums.LicenseTier
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumAuthPolicyPrimaryFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyPrimary | EnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyPrimary[] | ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyPrimary[] | ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyPrimaryFilter<$PrismaModel> | $Enums.AuthPolicyPrimary
  }

  export type NestedEnumAuthPolicyMfaFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyMfa | EnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyMfa[] | ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyMfa[] | ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyMfaFilter<$PrismaModel> | $Enums.AuthPolicyMfa
  }

  export type NestedEnumAuthPolicyIdentifierFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyIdentifier | EnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyIdentifier[] | ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyIdentifier[] | ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyIdentifierFilter<$PrismaModel> | $Enums.AuthPolicyIdentifier
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantStatus | EnumTenantStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantStatus[] | ListEnumTenantStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantStatusWithAggregatesFilter<$PrismaModel> | $Enums.TenantStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantStatusFilter<$PrismaModel>
    _max?: NestedEnumTenantStatusFilter<$PrismaModel>
  }

  export type NestedEnumLicenseTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseTier | EnumLicenseTierFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseTier[] | ListEnumLicenseTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.LicenseTier[] | ListEnumLicenseTierFieldRefInput<$PrismaModel>
    not?: NestedEnumLicenseTierWithAggregatesFilter<$PrismaModel> | $Enums.LicenseTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseTierFilter<$PrismaModel>
    _max?: NestedEnumLicenseTierFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAuthPolicyPrimaryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyPrimary | EnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyPrimary[] | ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyPrimary[] | ListEnumAuthPolicyPrimaryFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyPrimaryWithAggregatesFilter<$PrismaModel> | $Enums.AuthPolicyPrimary
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthPolicyPrimaryFilter<$PrismaModel>
    _max?: NestedEnumAuthPolicyPrimaryFilter<$PrismaModel>
  }

  export type NestedEnumAuthPolicyMfaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyMfa | EnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyMfa[] | ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyMfa[] | ListEnumAuthPolicyMfaFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyMfaWithAggregatesFilter<$PrismaModel> | $Enums.AuthPolicyMfa
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthPolicyMfaFilter<$PrismaModel>
    _max?: NestedEnumAuthPolicyMfaFilter<$PrismaModel>
  }

  export type NestedEnumAuthPolicyIdentifierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthPolicyIdentifier | EnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    in?: $Enums.AuthPolicyIdentifier[] | ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthPolicyIdentifier[] | ListEnumAuthPolicyIdentifierFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthPolicyIdentifierWithAggregatesFilter<$PrismaModel> | $Enums.AuthPolicyIdentifier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthPolicyIdentifierFilter<$PrismaModel>
    _max?: NestedEnumAuthPolicyIdentifierFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type NestedEnumWarehouseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WarehouseType | EnumWarehouseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WarehouseType[] | ListEnumWarehouseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WarehouseType[] | ListEnumWarehouseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWarehouseTypeFilter<$PrismaModel> | $Enums.WarehouseType
  }

  export type NestedEnumWarehouseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WarehouseType | EnumWarehouseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WarehouseType[] | ListEnumWarehouseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WarehouseType[] | ListEnumWarehouseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWarehouseTypeWithAggregatesFilter<$PrismaModel> | $Enums.WarehouseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWarehouseTypeFilter<$PrismaModel>
    _max?: NestedEnumWarehouseTypeFilter<$PrismaModel>
  }

  export type NestedEnumMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeFilter<$PrismaModel> | $Enums.MovementType
  }

  export type NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MovementType | EnumMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MovementType[] | ListEnumMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.MovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerType[] | ListEnumCustomerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeFilter<$PrismaModel> | $Enums.AssetType
  }

  export type NestedEnumAssetCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetCategory | EnumAssetCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AssetCategory[] | ListEnumAssetCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetCategory[] | ListEnumAssetCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetCategoryFilter<$PrismaModel> | $Enums.AssetCategory
  }

  export type NestedEnumAssetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusFilter<$PrismaModel> | $Enums.AssetStatus
  }

  export type NestedEnumDepreciationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DepreciationMethod | EnumDepreciationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DepreciationMethod[] | ListEnumDepreciationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepreciationMethod[] | ListEnumDepreciationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDepreciationMethodFilter<$PrismaModel> | $Enums.DepreciationMethod
  }

  export type NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetTypeFilter<$PrismaModel>
  }

  export type NestedEnumAssetCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetCategory | EnumAssetCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AssetCategory[] | ListEnumAssetCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetCategory[] | ListEnumAssetCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AssetCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetCategoryFilter<$PrismaModel>
    _max?: NestedEnumAssetCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetStatus | EnumAssetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetStatus[] | ListEnumAssetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetStatusFilter<$PrismaModel>
    _max?: NestedEnumAssetStatusFilter<$PrismaModel>
  }

  export type NestedEnumDepreciationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepreciationMethod | EnumDepreciationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DepreciationMethod[] | ListEnumDepreciationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepreciationMethod[] | ListEnumDepreciationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumDepreciationMethodWithAggregatesFilter<$PrismaModel> | $Enums.DepreciationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepreciationMethodFilter<$PrismaModel>
    _max?: NestedEnumDepreciationMethodFilter<$PrismaModel>
  }

  export type NestedEnumEInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EInvoiceType | EnumEInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EInvoiceType[] | ListEnumEInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EInvoiceType[] | ListEnumEInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEInvoiceTypeFilter<$PrismaModel> | $Enums.EInvoiceType
  }

  export type NestedEnumEInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EInvoiceStatus | EnumEInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EInvoiceStatus[] | ListEnumEInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EInvoiceStatus[] | ListEnumEInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEInvoiceStatusFilter<$PrismaModel> | $Enums.EInvoiceStatus
  }

  export type NestedEnumEInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EInvoiceType | EnumEInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EInvoiceType[] | ListEnumEInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EInvoiceType[] | ListEnumEInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.EInvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumEInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumEInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EInvoiceStatus | EnumEInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EInvoiceStatus[] | ListEnumEInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EInvoiceStatus[] | ListEnumEInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.EInvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumEInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumLhdnEnvironmentFilter<$PrismaModel = never> = {
    equals?: $Enums.LhdnEnvironment | EnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    in?: $Enums.LhdnEnvironment[] | ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.LhdnEnvironment[] | ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    not?: NestedEnumLhdnEnvironmentFilter<$PrismaModel> | $Enums.LhdnEnvironment
  }

  export type NestedEnumLhdnEnvironmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LhdnEnvironment | EnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    in?: $Enums.LhdnEnvironment[] | ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    notIn?: $Enums.LhdnEnvironment[] | ListEnumLhdnEnvironmentFieldRefInput<$PrismaModel>
    not?: NestedEnumLhdnEnvironmentWithAggregatesFilter<$PrismaModel> | $Enums.LhdnEnvironment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLhdnEnvironmentFilter<$PrismaModel>
    _max?: NestedEnumLhdnEnvironmentFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutTenantInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTenantInput = {
    id?: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTenantInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput>
  }

  export type ProductCreateManyTenantInputEnvelope = {
    data: ProductCreateManyTenantInput | ProductCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutTenantInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTenantInput = {
    id?: string
    parentId?: string | null
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput>
  }

  export type CategoryCreateManyTenantInputEnvelope = {
    data: CategoryCreateManyTenantInput | CategoryCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutTenantInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTenantInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerCreateManyTenantInputEnvelope = {
    data: CustomerCreateManyTenantInput | CustomerCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SupplierCreateWithoutTenantInput = {
    id?: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderCreateNestedManyWithoutSupplierInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutTenantInput = {
    id?: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutSupplierInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput>
  }

  export type SupplierCreateManyTenantInputEnvelope = {
    data: SupplierCreateManyTenantInput | SupplierCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseCreateWithoutTenantInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    movementsFrom?: InventoryMovementCreateNestedManyWithoutFromWarehouseInput
    movementsTo?: InventoryMovementCreateNestedManyWithoutToWarehouseInput
    ordersShipFrom?: OrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutTenantInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    movementsFrom?: InventoryMovementUncheckedCreateNestedManyWithoutFromWarehouseInput
    movementsTo?: InventoryMovementUncheckedCreateNestedManyWithoutToWarehouseInput
    ordersShipFrom?: OrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutTenantInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutTenantInput, WarehouseUncheckedCreateWithoutTenantInput>
  }

  export type WarehouseCreateManyTenantInputEnvelope = {
    data: WarehouseCreateManyTenantInput | WarehouseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InventoryItemCreateWithoutTenantInput = {
    id?: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryItemsInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutTenantInput = {
    id?: string
    productId: string
    warehouseId: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutTenantInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput>
  }

  export type InventoryItemCreateManyTenantInputEnvelope = {
    data: InventoryItemCreateManyTenantInput | InventoryItemCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutTenantInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutInventoryMovementsInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutMovementsFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutMovementsToInput
    user: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutTenantInput = {
    id?: string
    productId: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutTenantInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutTenantInput, InventoryMovementUncheckedCreateWithoutTenantInput>
  }

  export type InventoryMovementCreateManyTenantInputEnvelope = {
    data: InventoryMovementCreateManyTenantInput | InventoryMovementCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    supplier?: SupplierCreateNestedOneWithoutOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutOrdersShipFromInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
    approvedBy?: UserCreateNestedOneWithoutOrdersApprovedInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTenantInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput>
  }

  export type OrderCreateManyTenantInputEnvelope = {
    data: OrderCreateManyTenantInput | OrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    order?: OrderCreateNestedOneWithoutInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    createdBy: UserCreateNestedOneWithoutInvoicesCreatedInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    orderId?: string | null
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutTenantInput = {
    id?: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    customer: CustomerCreateNestedOneWithoutPaymentsInput
    receivedBy: UserCreateNestedOneWithoutPaymentsReceivedInput
  }

  export type PaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceId?: string | null
    customerId: string
    receivedById: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentCreateManyTenantInputEnvelope = {
    data: PaymentCreateManyTenantInput | PaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LicenseCreateWithoutTenantInput = {
    id?: string
    tier: $Enums.LicenseTier
    licenseKey: string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProducts?: number | null
    startsAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseUncheckedCreateWithoutTenantInput = {
    id?: string
    tier: $Enums.LicenseTier
    licenseKey: string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProducts?: number | null
    startsAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseCreateOrConnectWithoutTenantInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutTenantInput, LicenseUncheckedCreateWithoutTenantInput>
  }

  export type LicenseCreateManyTenantInputEnvelope = {
    data: LicenseCreateManyTenantInput | LicenseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutTenantInput = {
    id?: string
    assetTag: string
    name: string
    description?: string | null
    assetType: $Enums.AssetType
    category: $Enums.AssetCategory
    status?: $Enums.AssetStatus
    location: string
    assignedTo?: string | null
    purchaseDate: Date | string
    purchaseCost: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    depreciationMethod?: $Enums.DepreciationMethod
    usefulLifeYears?: number | null
    salvageValue?: Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: Date | string | null
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AssetUncheckedCreateWithoutTenantInput = {
    id?: string
    assetTag: string
    name: string
    description?: string | null
    assetType: $Enums.AssetType
    category: $Enums.AssetCategory
    status?: $Enums.AssetStatus
    location: string
    assignedTo?: string | null
    purchaseDate: Date | string
    purchaseCost: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    depreciationMethod?: $Enums.DepreciationMethod
    usefulLifeYears?: number | null
    salvageValue?: Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: Date | string | null
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AssetCreateOrConnectWithoutTenantInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutTenantInput, AssetUncheckedCreateWithoutTenantInput>
  }

  export type AssetCreateManyTenantInputEnvelope = {
    data: AssetCreateManyTenantInput | AssetCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutTenantInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutCustomRoleInput
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutCustomRoleInput
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutTenantInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput>
  }

  export type RoleCreateManyTenantInputEnvelope = {
    data: RoleCreateManyTenantInput | RoleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type EInvoiceCreateWithoutTenantInput = {
    id?: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutEInvoicesInput
    originalEInvoice?: EInvoiceCreateNestedOneWithoutRelatedEInvoicesInput
    relatedEInvoices?: EInvoiceCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedEInvoices?: EInvoiceUncheckedCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemUncheckedCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogUncheckedCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceCreateOrConnectWithoutTenantInput = {
    where: EInvoiceWhereUniqueInput
    create: XOR<EInvoiceCreateWithoutTenantInput, EInvoiceUncheckedCreateWithoutTenantInput>
  }

  export type EInvoiceCreateManyTenantInputEnvelope = {
    data: EInvoiceCreateManyTenantInput | EInvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LhdnTokenCreateWithoutTenantInput = {
    id?: string
    accessToken: string
    tokenType: string
    expiresAt: Date | string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LhdnTokenUncheckedCreateWithoutTenantInput = {
    id?: string
    accessToken: string
    tokenType: string
    expiresAt: Date | string
    scope?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LhdnTokenCreateOrConnectWithoutTenantInput = {
    where: LhdnTokenWhereUniqueInput
    create: XOR<LhdnTokenCreateWithoutTenantInput, LhdnTokenUncheckedCreateWithoutTenantInput>
  }

  export type LhdnCredentialCreateWithoutTenantInput = {
    id?: string
    clientId: string
    clientSecretEncrypted: string
    tin: string
    brn?: string | null
    idType: string
    idValue: string
    environment?: $Enums.LhdnEnvironment
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LhdnCredentialUncheckedCreateWithoutTenantInput = {
    id?: string
    clientId: string
    clientSecretEncrypted: string
    tin: string
    brn?: string | null
    idType: string
    idValue: string
    environment?: $Enums.LhdnEnvironment
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LhdnCredentialCreateOrConnectWithoutTenantInput = {
    where: LhdnCredentialWhereUniqueInput
    create: XOR<LhdnCredentialCreateWithoutTenantInput, LhdnCredentialUncheckedCreateWithoutTenantInput>
  }

  export type TenantCapabilityCreateWithoutTenantInput = {
    id?: string
    code: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantCapabilityUncheckedCreateWithoutTenantInput = {
    id?: string
    code: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantCapabilityCreateOrConnectWithoutTenantInput = {
    where: TenantCapabilityWhereUniqueInput
    create: XOR<TenantCapabilityCreateWithoutTenantInput, TenantCapabilityUncheckedCreateWithoutTenantInput>
  }

  export type TenantCapabilityCreateManyTenantInputEnvelope = {
    data: TenantCapabilityCreateManyTenantInput | TenantCapabilityCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PrintAuditCreateWithoutTenantInput = {
    id?: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
    user: UserCreateNestedOneWithoutPrintAuditsInput
  }

  export type PrintAuditUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
  }

  export type PrintAuditCreateOrConnectWithoutTenantInput = {
    where: PrintAuditWhereUniqueInput
    create: XOR<PrintAuditCreateWithoutTenantInput, PrintAuditUncheckedCreateWithoutTenantInput>
  }

  export type PrintAuditCreateManyTenantInputEnvelope = {
    data: PrintAuditCreateManyTenantInput | PrintAuditCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: UuidFilter<"User"> | string
    tenantId?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    roleId?: UuidNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    failedLogins?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutTenantInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTenantInput, ProductUncheckedUpdateWithoutTenantInput>
    create: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTenantInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTenantInput, ProductUncheckedUpdateWithoutTenantInput>
  }

  export type ProductUpdateManyWithWhereWithoutTenantInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutTenantInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: UuidFilter<"Product"> | string
    tenantId?: UuidFilter<"Product"> | string
    categoryId?: UuidNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    barcode?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    unit?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    cost?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    minStock?: IntFilter<"Product"> | number
    maxStock?: IntFilter<"Product"> | number
    reorderPoint?: IntFilter<"Product"> | number
    reorderQty?: IntFilter<"Product"> | number
    weight?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"Product">
    images?: JsonFilter<"Product">
    attributes?: JsonFilter<"Product">
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
  }

  export type CategoryUpsertWithWhereUniqueWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutTenantInput, CategoryUncheckedUpdateWithoutTenantInput>
    create: XOR<CategoryCreateWithoutTenantInput, CategoryUncheckedCreateWithoutTenantInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutTenantInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutTenantInput, CategoryUncheckedUpdateWithoutTenantInput>
  }

  export type CategoryUpdateManyWithWhereWithoutTenantInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutTenantInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: UuidFilter<"Category"> | string
    tenantId?: UuidFilter<"Category"> | string
    parentId?: UuidNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    image?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
  }

  export type CustomerUpsertWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
  }

  export type CustomerUpdateManyWithWhereWithoutTenantInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutTenantInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: UuidFilter<"Customer"> | string
    tenantId?: UuidFilter<"Customer"> | string
    code?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    mobile?: StringNullableFilter<"Customer"> | string | null
    fax?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    taxId?: StringNullableFilter<"Customer"> | string | null
    billingAddress?: JsonNullableFilter<"Customer">
    shippingAddress?: JsonNullableFilter<"Customer">
    paymentTerms?: IntFilter<"Customer"> | number
    creditLimit?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Customer"> | string | null
    tags?: JsonFilter<"Customer">
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
  }

  export type SupplierUpsertWithWhereUniqueWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutTenantInput, SupplierUncheckedUpdateWithoutTenantInput>
    create: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutTenantInput, SupplierUncheckedUpdateWithoutTenantInput>
  }

  export type SupplierUpdateManyWithWhereWithoutTenantInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutTenantInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: UuidFilter<"Supplier"> | string
    tenantId?: UuidFilter<"Supplier"> | string
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contactPerson?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    phone?: StringNullableFilter<"Supplier"> | string | null
    mobile?: StringNullableFilter<"Supplier"> | string | null
    fax?: StringNullableFilter<"Supplier"> | string | null
    website?: StringNullableFilter<"Supplier"> | string | null
    taxId?: StringNullableFilter<"Supplier"> | string | null
    address?: JsonNullableFilter<"Supplier">
    bankDetails?: JsonNullableFilter<"Supplier">
    paymentTerms?: IntFilter<"Supplier"> | number
    currency?: StringFilter<"Supplier"> | string
    leadTime?: IntFilter<"Supplier"> | number
    minimumOrder?: DecimalFilter<"Supplier"> | Decimal | DecimalJsLike | number | string
    rating?: IntNullableFilter<"Supplier"> | number | null
    notes?: StringNullableFilter<"Supplier"> | string | null
    tags?: JsonFilter<"Supplier">
    isActive?: BoolFilter<"Supplier"> | boolean
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    updatedAt?: DateTimeFilter<"Supplier"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
  }

  export type WarehouseUpsertWithWhereUniqueWithoutTenantInput = {
    where: WarehouseWhereUniqueInput
    update: XOR<WarehouseUpdateWithoutTenantInput, WarehouseUncheckedUpdateWithoutTenantInput>
    create: XOR<WarehouseCreateWithoutTenantInput, WarehouseUncheckedCreateWithoutTenantInput>
  }

  export type WarehouseUpdateWithWhereUniqueWithoutTenantInput = {
    where: WarehouseWhereUniqueInput
    data: XOR<WarehouseUpdateWithoutTenantInput, WarehouseUncheckedUpdateWithoutTenantInput>
  }

  export type WarehouseUpdateManyWithWhereWithoutTenantInput = {
    where: WarehouseScalarWhereInput
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyWithoutTenantInput>
  }

  export type WarehouseScalarWhereInput = {
    AND?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    OR?: WarehouseScalarWhereInput[]
    NOT?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    id?: UuidFilter<"Warehouse"> | string
    tenantId?: UuidFilter<"Warehouse"> | string
    code?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    phone?: StringNullableFilter<"Warehouse"> | string | null
    email?: StringNullableFilter<"Warehouse"> | string | null
    manager?: StringNullableFilter<"Warehouse"> | string | null
    type?: EnumWarehouseTypeFilter<"Warehouse"> | $Enums.WarehouseType
    isDefault?: BoolFilter<"Warehouse"> | boolean
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Warehouse"> | Date | string | null
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutTenantInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutTenantInput, InventoryItemUncheckedUpdateWithoutTenantInput>
    create: XOR<InventoryItemCreateWithoutTenantInput, InventoryItemUncheckedCreateWithoutTenantInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutTenantInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutTenantInput, InventoryItemUncheckedUpdateWithoutTenantInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutTenantInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutTenantInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: UuidFilter<"InventoryItem"> | string
    tenantId?: UuidFilter<"InventoryItem"> | string
    productId?: UuidFilter<"InventoryItem"> | string
    warehouseId?: UuidFilter<"InventoryItem"> | string
    quantity?: IntFilter<"InventoryItem"> | number
    reservedQty?: IntFilter<"InventoryItem"> | number
    availableQty?: IntFilter<"InventoryItem"> | number
    batchNumber?: StringNullableFilter<"InventoryItem"> | string | null
    lotNumber?: StringNullableFilter<"InventoryItem"> | string | null
    serialNumber?: StringNullableFilter<"InventoryItem"> | string | null
    expiryDate?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    location?: StringNullableFilter<"InventoryItem"> | string | null
    costPrice?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutTenantInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutTenantInput, InventoryMovementUncheckedUpdateWithoutTenantInput>
    create: XOR<InventoryMovementCreateWithoutTenantInput, InventoryMovementUncheckedCreateWithoutTenantInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutTenantInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutTenantInput, InventoryMovementUncheckedUpdateWithoutTenantInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutTenantInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutTenantInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: UuidFilter<"InventoryMovement"> | string
    tenantId?: UuidFilter<"InventoryMovement"> | string
    productId?: UuidFilter<"InventoryMovement"> | string
    fromWarehouseId?: UuidNullableFilter<"InventoryMovement"> | string | null
    toWarehouseId?: UuidNullableFilter<"InventoryMovement"> | string | null
    userId?: UuidFilter<"InventoryMovement"> | string
    type?: EnumMovementTypeFilter<"InventoryMovement"> | $Enums.MovementType
    quantity?: IntFilter<"InventoryMovement"> | number
    unitCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"InventoryMovement"> | Decimal | DecimalJsLike | number | string | null
    reference?: StringNullableFilter<"InventoryMovement"> | string | null
    referenceType?: StringNullableFilter<"InventoryMovement"> | string | null
    batchNumber?: StringNullableFilter<"InventoryMovement"> | string | null
    notes?: StringNullableFilter<"InventoryMovement"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutTenantInput, OrderUncheckedUpdateWithoutTenantInput>
    create: XOR<OrderCreateWithoutTenantInput, OrderUncheckedCreateWithoutTenantInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutTenantInput, OrderUncheckedUpdateWithoutTenantInput>
  }

  export type OrderUpdateManyWithWhereWithoutTenantInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: UuidFilter<"Order"> | string
    tenantId?: UuidFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    type?: EnumOrderTypeFilter<"Order"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    customerId?: UuidNullableFilter<"Order"> | string | null
    supplierId?: UuidNullableFilter<"Order"> | string | null
    warehouseId?: UuidNullableFilter<"Order"> | string | null
    createdById?: UuidFilter<"Order"> | string
    approvedById?: UuidNullableFilter<"Order"> | string | null
    orderDate?: DateTimeFilter<"Order"> | Date | string
    expectedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    shippedDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    shippingAddress?: JsonNullableFilter<"Order">
    billingAddress?: JsonNullableFilter<"Order">
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountType?: StringNullableFilter<"Order"> | string | null
    total?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Order"> | string
    exchangeRate?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    paymentTerms?: IntNullableFilter<"Order"> | number | null
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    internalNotes?: StringNullableFilter<"Order"> | string | null
    tags?: JsonFilter<"Order">
    metadata?: JsonFilter<"Order">
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: UuidFilter<"Invoice"> | string
    tenantId?: UuidFilter<"Invoice"> | string
    orderId?: UuidNullableFilter<"Invoice"> | string | null
    customerId?: UuidFilter<"Invoice"> | string
    createdById?: UuidFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    exchangeRate?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Invoice"> | string | null
    terms?: StringNullableFilter<"Invoice"> | string | null
    footer?: StringNullableFilter<"Invoice"> | string | null
    metadata?: JsonFilter<"Invoice">
    sentAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    viewedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    tenantId?: UuidFilter<"Payment"> | string
    invoiceId?: UuidNullableFilter<"Payment"> | string | null
    customerId?: UuidFilter<"Payment"> | string
    receivedById?: UuidFilter<"Payment"> | string
    paymentNumber?: StringFilter<"Payment"> | string
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    exchangeRate?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    reference?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type LicenseUpsertWithWhereUniqueWithoutTenantInput = {
    where: LicenseWhereUniqueInput
    update: XOR<LicenseUpdateWithoutTenantInput, LicenseUncheckedUpdateWithoutTenantInput>
    create: XOR<LicenseCreateWithoutTenantInput, LicenseUncheckedCreateWithoutTenantInput>
  }

  export type LicenseUpdateWithWhereUniqueWithoutTenantInput = {
    where: LicenseWhereUniqueInput
    data: XOR<LicenseUpdateWithoutTenantInput, LicenseUncheckedUpdateWithoutTenantInput>
  }

  export type LicenseUpdateManyWithWhereWithoutTenantInput = {
    where: LicenseScalarWhereInput
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyWithoutTenantInput>
  }

  export type LicenseScalarWhereInput = {
    AND?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
    OR?: LicenseScalarWhereInput[]
    NOT?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
    id?: UuidFilter<"License"> | string
    tenantId?: UuidFilter<"License"> | string
    tier?: EnumLicenseTierFilter<"License"> | $Enums.LicenseTier
    licenseKey?: StringFilter<"License"> | string
    features?: JsonFilter<"License">
    maxUsers?: IntFilter<"License"> | number
    maxProducts?: IntNullableFilter<"License"> | number | null
    startsAt?: DateTimeFilter<"License"> | Date | string
    expiresAt?: DateTimeFilter<"License"> | Date | string
    isActive?: BoolFilter<"License"> | boolean
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    tenantId?: UuidFilter<"AuditLog"> | string
    userId?: UuidNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: UuidNullableFilter<"AuditLog"> | string | null
    entityName?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    changedFields?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    requestId?: StringNullableFilter<"AuditLog"> | string | null
    duration?: IntNullableFilter<"AuditLog"> | number | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AssetUpsertWithWhereUniqueWithoutTenantInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutTenantInput, AssetUncheckedUpdateWithoutTenantInput>
    create: XOR<AssetCreateWithoutTenantInput, AssetUncheckedCreateWithoutTenantInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutTenantInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutTenantInput, AssetUncheckedUpdateWithoutTenantInput>
  }

  export type AssetUpdateManyWithWhereWithoutTenantInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutTenantInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: UuidFilter<"Asset"> | string
    tenantId?: UuidFilter<"Asset"> | string
    assetTag?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    assetType?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    category?: EnumAssetCategoryFilter<"Asset"> | $Enums.AssetCategory
    status?: EnumAssetStatusFilter<"Asset"> | $Enums.AssetStatus
    location?: StringFilter<"Asset"> | string
    assignedTo?: StringNullableFilter<"Asset"> | string | null
    purchaseDate?: DateTimeFilter<"Asset"> | Date | string
    purchaseCost?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFilter<"Asset"> | $Enums.DepreciationMethod
    usefulLifeYears?: IntNullableFilter<"Asset"> | number | null
    salvageValue?: DecimalNullableFilter<"Asset"> | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: DateTimeNullableFilter<"Asset"> | Date | string | null
    serialNumber?: StringNullableFilter<"Asset"> | string | null
    manufacturer?: StringNullableFilter<"Asset"> | string | null
    model?: StringNullableFilter<"Asset"> | string | null
    notes?: StringNullableFilter<"Asset"> | string | null
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Asset"> | Date | string | null
  }

  export type RoleUpsertWithWhereUniqueWithoutTenantInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutTenantInput, RoleUncheckedUpdateWithoutTenantInput>
    create: XOR<RoleCreateWithoutTenantInput, RoleUncheckedCreateWithoutTenantInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutTenantInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutTenantInput, RoleUncheckedUpdateWithoutTenantInput>
  }

  export type RoleUpdateManyWithWhereWithoutTenantInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutTenantInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: UuidFilter<"Role"> | string
    tenantId?: UuidFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    displayName?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    color?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
  }

  export type EInvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: EInvoiceWhereUniqueInput
    update: XOR<EInvoiceUpdateWithoutTenantInput, EInvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<EInvoiceCreateWithoutTenantInput, EInvoiceUncheckedCreateWithoutTenantInput>
  }

  export type EInvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: EInvoiceWhereUniqueInput
    data: XOR<EInvoiceUpdateWithoutTenantInput, EInvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type EInvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: EInvoiceScalarWhereInput
    data: XOR<EInvoiceUpdateManyMutationInput, EInvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type EInvoiceScalarWhereInput = {
    AND?: EInvoiceScalarWhereInput | EInvoiceScalarWhereInput[]
    OR?: EInvoiceScalarWhereInput[]
    NOT?: EInvoiceScalarWhereInput | EInvoiceScalarWhereInput[]
    id?: UuidFilter<"EInvoice"> | string
    tenantId?: UuidFilter<"EInvoice"> | string
    invoiceId?: UuidFilter<"EInvoice"> | string
    invoiceType?: EnumEInvoiceTypeFilter<"EInvoice"> | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFilter<"EInvoice"> | $Enums.EInvoiceStatus
    lhdnUuid?: StringNullableFilter<"EInvoice"> | string | null
    lhdnLongId?: StringNullableFilter<"EInvoice"> | string | null
    lhdnSubmissionUid?: StringNullableFilter<"EInvoice"> | string | null
    submittedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    validatedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    requestJson?: JsonNullableFilter<"EInvoice">
    responseJson?: JsonNullableFilter<"EInvoice">
    documentHash?: StringNullableFilter<"EInvoice"> | string | null
    rejectReason?: StringNullableFilter<"EInvoice"> | string | null
    validationErrors?: JsonNullableFilter<"EInvoice">
    retryCount?: IntFilter<"EInvoice"> | number
    lastRetryAt?: DateTimeNullableFilter<"EInvoice"> | Date | string | null
    originalEInvoiceId?: UuidNullableFilter<"EInvoice"> | string | null
    createdAt?: DateTimeFilter<"EInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"EInvoice"> | Date | string
  }

  export type LhdnTokenUpsertWithoutTenantInput = {
    update: XOR<LhdnTokenUpdateWithoutTenantInput, LhdnTokenUncheckedUpdateWithoutTenantInput>
    create: XOR<LhdnTokenCreateWithoutTenantInput, LhdnTokenUncheckedCreateWithoutTenantInput>
    where?: LhdnTokenWhereInput
  }

  export type LhdnTokenUpdateToOneWithWhereWithoutTenantInput = {
    where?: LhdnTokenWhereInput
    data: XOR<LhdnTokenUpdateWithoutTenantInput, LhdnTokenUncheckedUpdateWithoutTenantInput>
  }

  export type LhdnTokenUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    tokenType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnTokenUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    tokenType?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnCredentialUpsertWithoutTenantInput = {
    update: XOR<LhdnCredentialUpdateWithoutTenantInput, LhdnCredentialUncheckedUpdateWithoutTenantInput>
    create: XOR<LhdnCredentialCreateWithoutTenantInput, LhdnCredentialUncheckedCreateWithoutTenantInput>
    where?: LhdnCredentialWhereInput
  }

  export type LhdnCredentialUpdateToOneWithWhereWithoutTenantInput = {
    where?: LhdnCredentialWhereInput
    data: XOR<LhdnCredentialUpdateWithoutTenantInput, LhdnCredentialUncheckedUpdateWithoutTenantInput>
  }

  export type LhdnCredentialUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretEncrypted?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    brn?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: StringFieldUpdateOperationsInput | string
    idValue?: StringFieldUpdateOperationsInput | string
    environment?: EnumLhdnEnvironmentFieldUpdateOperationsInput | $Enums.LhdnEnvironment
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LhdnCredentialUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretEncrypted?: StringFieldUpdateOperationsInput | string
    tin?: StringFieldUpdateOperationsInput | string
    brn?: NullableStringFieldUpdateOperationsInput | string | null
    idType?: StringFieldUpdateOperationsInput | string
    idValue?: StringFieldUpdateOperationsInput | string
    environment?: EnumLhdnEnvironmentFieldUpdateOperationsInput | $Enums.LhdnEnvironment
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCapabilityUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantCapabilityWhereUniqueInput
    update: XOR<TenantCapabilityUpdateWithoutTenantInput, TenantCapabilityUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantCapabilityCreateWithoutTenantInput, TenantCapabilityUncheckedCreateWithoutTenantInput>
  }

  export type TenantCapabilityUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantCapabilityWhereUniqueInput
    data: XOR<TenantCapabilityUpdateWithoutTenantInput, TenantCapabilityUncheckedUpdateWithoutTenantInput>
  }

  export type TenantCapabilityUpdateManyWithWhereWithoutTenantInput = {
    where: TenantCapabilityScalarWhereInput
    data: XOR<TenantCapabilityUpdateManyMutationInput, TenantCapabilityUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantCapabilityScalarWhereInput = {
    AND?: TenantCapabilityScalarWhereInput | TenantCapabilityScalarWhereInput[]
    OR?: TenantCapabilityScalarWhereInput[]
    NOT?: TenantCapabilityScalarWhereInput | TenantCapabilityScalarWhereInput[]
    id?: UuidFilter<"TenantCapability"> | string
    tenantId?: UuidFilter<"TenantCapability"> | string
    code?: StringFilter<"TenantCapability"> | string
    enabled?: BoolFilter<"TenantCapability"> | boolean
    createdAt?: DateTimeFilter<"TenantCapability"> | Date | string
    updatedAt?: DateTimeFilter<"TenantCapability"> | Date | string
  }

  export type PrintAuditUpsertWithWhereUniqueWithoutTenantInput = {
    where: PrintAuditWhereUniqueInput
    update: XOR<PrintAuditUpdateWithoutTenantInput, PrintAuditUncheckedUpdateWithoutTenantInput>
    create: XOR<PrintAuditCreateWithoutTenantInput, PrintAuditUncheckedCreateWithoutTenantInput>
  }

  export type PrintAuditUpdateWithWhereUniqueWithoutTenantInput = {
    where: PrintAuditWhereUniqueInput
    data: XOR<PrintAuditUpdateWithoutTenantInput, PrintAuditUncheckedUpdateWithoutTenantInput>
  }

  export type PrintAuditUpdateManyWithWhereWithoutTenantInput = {
    where: PrintAuditScalarWhereInput
    data: XOR<PrintAuditUpdateManyMutationInput, PrintAuditUncheckedUpdateManyWithoutTenantInput>
  }

  export type PrintAuditScalarWhereInput = {
    AND?: PrintAuditScalarWhereInput | PrintAuditScalarWhereInput[]
    OR?: PrintAuditScalarWhereInput[]
    NOT?: PrintAuditScalarWhereInput | PrintAuditScalarWhereInput[]
    id?: UuidFilter<"PrintAudit"> | string
    tenantId?: UuidFilter<"PrintAudit"> | string
    userId?: UuidFilter<"PrintAudit"> | string
    documentType?: StringFilter<"PrintAudit"> | string
    documentId?: UuidFilter<"PrintAudit"> | string
    documentNumber?: StringNullableFilter<"PrintAudit"> | string | null
    printerName?: StringNullableFilter<"PrintAudit"> | string | null
    paperSize?: StringNullableFilter<"PrintAudit"> | string | null
    copies?: IntFilter<"PrintAudit"> | number
    printMode?: StringNullableFilter<"PrintAudit"> | string | null
    success?: BoolFilter<"PrintAudit"> | boolean
    errorMessage?: StringNullableFilter<"PrintAudit"> | string | null
    ipAddress?: StringNullableFilter<"PrintAudit"> | string | null
    userAgent?: StringNullableFilter<"PrintAudit"> | string | null
    printTimestamp?: DateTimeFilter<"PrintAudit"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutRolesInput
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    tenantId: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutUserInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryMovementsInput
    product: ProductCreateNestedOneWithoutInventoryMovementsInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutMovementsFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutMovementsToInput
  }

  export type InventoryMovementUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    productId: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput>
  }

  export type InventoryMovementCreateManyUserInputEnvelope = {
    data: InventoryMovementCreateManyUserInput | InventoryMovementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCreatedByInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    supplier?: SupplierCreateNestedOneWithoutOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutOrdersShipFromInput
    approvedBy?: UserCreateNestedOneWithoutOrdersApprovedInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCreatedByInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput>
  }

  export type OrderCreateManyCreatedByInputEnvelope = {
    data: OrderCreateManyCreatedByInput | OrderCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutApprovedByInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    supplier?: SupplierCreateNestedOneWithoutOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutOrdersShipFromInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutApprovedByInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutApprovedByInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput>
  }

  export type OrderCreateManyApprovedByInputEnvelope = {
    data: OrderCreateManyApprovedByInput | OrderCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCreatedByInput = {
    id?: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    customerId: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceCreateManyCreatedByInputEnvelope = {
    data: InvoiceCreateManyCreatedByInput | InvoiceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutReceivedByInput = {
    id?: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    customer: CustomerCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutReceivedByInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    customerId: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput>
  }

  export type PaymentCreateManyReceivedByInputEnvelope = {
    data: PaymentCreateManyReceivedByInput | PaymentCreateManyReceivedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PrintAuditCreateWithoutUserInput = {
    id?: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
    tenant: TenantCreateNestedOneWithoutPrintAuditsInput
  }

  export type PrintAuditUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
  }

  export type PrintAuditCreateOrConnectWithoutUserInput = {
    where: PrintAuditWhereUniqueInput
    create: XOR<PrintAuditCreateWithoutUserInput, PrintAuditUncheckedCreateWithoutUserInput>
  }

  export type PrintAuditCreateManyUserInputEnvelope = {
    data: PrintAuditCreateManyUserInput | PrintAuditCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutRolesNestedInput
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: UuidFilter<"RefreshToken"> | string
    userId?: UuidFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutUserInput, InventoryMovementUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutUserInput, InventoryMovementUncheckedUpdateWithoutUserInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutUserInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCreatedByInput, OrderUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OrderCreateWithoutCreatedByInput, OrderUncheckedCreateWithoutCreatedByInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCreatedByInput, OrderUncheckedUpdateWithoutCreatedByInput>
  }

  export type OrderUpdateManyWithWhereWithoutCreatedByInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutApprovedByInput, OrderUncheckedUpdateWithoutApprovedByInput>
    create: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutApprovedByInput, OrderUncheckedUpdateWithoutApprovedByInput>
  }

  export type OrderUpdateManyWithWhereWithoutApprovedByInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InvoiceCreateWithoutCreatedByInput, InvoiceUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCreatedByInput, InvoiceUncheckedUpdateWithoutCreatedByInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCreatedByInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutReceivedByInput, PaymentUncheckedUpdateWithoutReceivedByInput>
    create: XOR<PaymentCreateWithoutReceivedByInput, PaymentUncheckedCreateWithoutReceivedByInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutReceivedByInput, PaymentUncheckedUpdateWithoutReceivedByInput>
  }

  export type PaymentUpdateManyWithWhereWithoutReceivedByInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutReceivedByInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type PrintAuditUpsertWithWhereUniqueWithoutUserInput = {
    where: PrintAuditWhereUniqueInput
    update: XOR<PrintAuditUpdateWithoutUserInput, PrintAuditUncheckedUpdateWithoutUserInput>
    create: XOR<PrintAuditCreateWithoutUserInput, PrintAuditUncheckedCreateWithoutUserInput>
  }

  export type PrintAuditUpdateWithWhereUniqueWithoutUserInput = {
    where: PrintAuditWhereUniqueInput
    data: XOR<PrintAuditUpdateWithoutUserInput, PrintAuditUncheckedUpdateWithoutUserInput>
  }

  export type PrintAuditUpdateManyWithWhereWithoutUserInput = {
    where: PrintAuditScalarWhereInput
    data: XOR<PrintAuditUpdateManyMutationInput, PrintAuditUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlatformAdminRefreshTokenCreateWithoutAdminInput = {
    id?: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput = {
    id?: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PlatformAdminRefreshTokenCreateOrConnectWithoutAdminInput = {
    where: PlatformAdminRefreshTokenWhereUniqueInput
    create: XOR<PlatformAdminRefreshTokenCreateWithoutAdminInput, PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput>
  }

  export type PlatformAdminRefreshTokenCreateManyAdminInputEnvelope = {
    data: PlatformAdminRefreshTokenCreateManyAdminInput | PlatformAdminRefreshTokenCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type PlatformAdminRefreshTokenUpsertWithWhereUniqueWithoutAdminInput = {
    where: PlatformAdminRefreshTokenWhereUniqueInput
    update: XOR<PlatformAdminRefreshTokenUpdateWithoutAdminInput, PlatformAdminRefreshTokenUncheckedUpdateWithoutAdminInput>
    create: XOR<PlatformAdminRefreshTokenCreateWithoutAdminInput, PlatformAdminRefreshTokenUncheckedCreateWithoutAdminInput>
  }

  export type PlatformAdminRefreshTokenUpdateWithWhereUniqueWithoutAdminInput = {
    where: PlatformAdminRefreshTokenWhereUniqueInput
    data: XOR<PlatformAdminRefreshTokenUpdateWithoutAdminInput, PlatformAdminRefreshTokenUncheckedUpdateWithoutAdminInput>
  }

  export type PlatformAdminRefreshTokenUpdateManyWithWhereWithoutAdminInput = {
    where: PlatformAdminRefreshTokenScalarWhereInput
    data: XOR<PlatformAdminRefreshTokenUpdateManyMutationInput, PlatformAdminRefreshTokenUncheckedUpdateManyWithoutAdminInput>
  }

  export type PlatformAdminRefreshTokenScalarWhereInput = {
    AND?: PlatformAdminRefreshTokenScalarWhereInput | PlatformAdminRefreshTokenScalarWhereInput[]
    OR?: PlatformAdminRefreshTokenScalarWhereInput[]
    NOT?: PlatformAdminRefreshTokenScalarWhereInput | PlatformAdminRefreshTokenScalarWhereInput[]
    id?: UuidFilter<"PlatformAdminRefreshToken"> | string
    adminId?: UuidFilter<"PlatformAdminRefreshToken"> | string
    token?: StringFilter<"PlatformAdminRefreshToken"> | string
    userAgent?: StringNullableFilter<"PlatformAdminRefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"PlatformAdminRefreshToken"> | string | null
    expiresAt?: DateTimeFilter<"PlatformAdminRefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"PlatformAdminRefreshToken"> | Date | string
  }

  export type PlatformAdminCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: string
    department?: string | null
    avatar?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformAdminUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: string
    department?: string | null
    avatar?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformAdminCreateOrConnectWithoutRefreshTokensInput = {
    where: PlatformAdminWhereUniqueInput
    create: XOR<PlatformAdminCreateWithoutRefreshTokensInput, PlatformAdminUncheckedCreateWithoutRefreshTokensInput>
  }

  export type PlatformAdminUpsertWithoutRefreshTokensInput = {
    update: XOR<PlatformAdminUpdateWithoutRefreshTokensInput, PlatformAdminUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<PlatformAdminCreateWithoutRefreshTokensInput, PlatformAdminUncheckedCreateWithoutRefreshTokensInput>
    where?: PlatformAdminWhereInput
  }

  export type PlatformAdminUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: PlatformAdminWhereInput
    data: XOR<PlatformAdminUpdateWithoutRefreshTokensInput, PlatformAdminUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type PlatformAdminUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutRolesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRolesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRolesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRolesInput, TenantUncheckedCreateWithoutRolesInput>
  }

  export type UserCreateWithoutCustomRoleInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomRoleInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomRoleInput, UserUncheckedCreateWithoutCustomRoleInput>
  }

  export type UserCreateManyCustomRoleInputEnvelope = {
    data: UserCreateManyCustomRoleInput | UserCreateManyCustomRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutRolesInput = {
    update: XOR<TenantUpdateWithoutRolesInput, TenantUncheckedUpdateWithoutRolesInput>
    create: XOR<TenantCreateWithoutRolesInput, TenantUncheckedCreateWithoutRolesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRolesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRolesInput, TenantUncheckedUpdateWithoutRolesInput>
  }

  export type TenantUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCustomRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCustomRoleInput, UserUncheckedUpdateWithoutCustomRoleInput>
    create: XOR<UserCreateWithoutCustomRoleInput, UserUncheckedCreateWithoutCustomRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCustomRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCustomRoleInput, UserUncheckedUpdateWithoutCustomRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutCustomRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCustomRoleInput>
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: UuidFilter<"RolePermission"> | string
    roleId?: UuidFilter<"RolePermission"> | string
    permissionId?: UuidFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutRolesInput
    users?: UserCreateNestedManyWithoutCustomRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    tenantId: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutCustomRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    module: string
    action: string
    sortOrder?: number
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    module: string
    action: string
    sortOrder?: number
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutRolesNestedInput
    users?: UserUpdateManyWithoutCustomRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutCustomRoleNestedInput
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutLicensesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLicensesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLicensesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLicensesInput, TenantUncheckedCreateWithoutLicensesInput>
  }

  export type TenantUpsertWithoutLicensesInput = {
    update: XOR<TenantUpdateWithoutLicensesInput, TenantUncheckedUpdateWithoutLicensesInput>
    create: XOR<TenantCreateWithoutLicensesInput, TenantUncheckedCreateWithoutLicensesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLicensesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLicensesInput, TenantUncheckedUpdateWithoutLicensesInput>
  }

  export type TenantUpdateWithoutLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCategoriesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    tenantId: string
    parentId?: string | null
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutProductsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    tenantId: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCategoriesInput = {
    update: XOR<TenantUpdateWithoutCategoriesInput, TenantUncheckedUpdateWithoutCategoriesInput>
    create: XOR<TenantCreateWithoutCategoriesInput, TenantUncheckedCreateWithoutCategoriesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCategoriesInput, TenantUncheckedUpdateWithoutCategoriesInput>
  }

  export type TenantUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TenantCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutProductsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    tenantId: string
    parentId?: string | null
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type InventoryItemCreateWithoutProductInput = {
    id?: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryItemsInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutProductInput = {
    id?: string
    tenantId: string
    warehouseId: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput>
  }

  export type InventoryItemCreateManyProductInputEnvelope = {
    data: InventoryItemCreateManyProductInput | InventoryItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutProductInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryMovementsInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutMovementsFromInput
    toWarehouse?: WarehouseCreateNestedOneWithoutMovementsToInput
    user: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutProductInput = {
    id?: string
    tenantId: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutProductInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput>
  }

  export type InventoryMovementCreateManyProductInputEnvelope = {
    data: InventoryMovementCreateManyProductInput | InventoryMovementCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemCreateWithoutProductInput = {
    id?: string
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    eInvoiceItems?: EInvoiceItemCreateNestedManyWithoutInvoiceItemInput
  }

  export type InvoiceItemUncheckedCreateWithoutProductInput = {
    id?: string
    invoiceId: string
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    eInvoiceItems?: EInvoiceItemUncheckedCreateNestedManyWithoutInvoiceItemInput
  }

  export type InvoiceItemCreateOrConnectWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemCreateManyProductInputEnvelope = {
    data: InvoiceItemCreateManyProductInput | InvoiceItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SupplierProductCreateWithoutProductInput = {
    id?: string
    tenantId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutSupplierProductsInput
  }

  export type SupplierProductUncheckedCreateWithoutProductInput = {
    id?: string
    tenantId: string
    supplierId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierProductCreateOrConnectWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    create: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput>
  }

  export type SupplierProductCreateManyProductInputEnvelope = {
    data: SupplierProductCreateManyProductInput | SupplierProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutProductsInput = {
    update: XOR<TenantUpdateWithoutProductsInput, TenantUncheckedUpdateWithoutProductsInput>
    create: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutProductsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutProductsInput, TenantUncheckedUpdateWithoutProductsInput>
  }

  export type TenantUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutProductInput, InventoryItemUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryItemCreateWithoutProductInput, InventoryItemUncheckedCreateWithoutProductInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutProductInput, InventoryItemUncheckedUpdateWithoutProductInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutProductInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutProductInput, InventoryMovementUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryMovementCreateWithoutProductInput, InventoryMovementUncheckedCreateWithoutProductInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutProductInput, InventoryMovementUncheckedUpdateWithoutProductInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutProductInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: UuidFilter<"OrderItem"> | string
    orderId?: UuidFilter<"OrderItem"> | string
    productId?: UuidFilter<"OrderItem"> | string
    sku?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    shippedQty?: IntFilter<"OrderItem"> | number
    receivedQty?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalNullableFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    discountType?: StringNullableFilter<"OrderItem"> | string | null
    taxRate?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"OrderItem"> | string | null
    sortOrder?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
    create: XOR<InvoiceItemCreateWithoutProductInput, InvoiceItemUncheckedCreateWithoutProductInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutProductInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutProductInput, InvoiceItemUncheckedUpdateWithoutProductInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutProductInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutProductInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: UuidFilter<"InvoiceItem"> | string
    invoiceId?: UuidFilter<"InvoiceItem"> | string
    productId?: UuidNullableFilter<"InvoiceItem"> | string | null
    sku?: StringNullableFilter<"InvoiceItem"> | string | null
    name?: StringFilter<"InvoiceItem"> | string
    description?: StringNullableFilter<"InvoiceItem"> | string | null
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFilter<"InvoiceItem"> | number
    createdAt?: DateTimeFilter<"InvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceItem"> | Date | string
  }

  export type SupplierProductUpsertWithWhereUniqueWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    update: XOR<SupplierProductUpdateWithoutProductInput, SupplierProductUncheckedUpdateWithoutProductInput>
    create: XOR<SupplierProductCreateWithoutProductInput, SupplierProductUncheckedCreateWithoutProductInput>
  }

  export type SupplierProductUpdateWithWhereUniqueWithoutProductInput = {
    where: SupplierProductWhereUniqueInput
    data: XOR<SupplierProductUpdateWithoutProductInput, SupplierProductUncheckedUpdateWithoutProductInput>
  }

  export type SupplierProductUpdateManyWithWhereWithoutProductInput = {
    where: SupplierProductScalarWhereInput
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyWithoutProductInput>
  }

  export type SupplierProductScalarWhereInput = {
    AND?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
    OR?: SupplierProductScalarWhereInput[]
    NOT?: SupplierProductScalarWhereInput | SupplierProductScalarWhereInput[]
    id?: UuidFilter<"SupplierProduct"> | string
    tenantId?: UuidFilter<"SupplierProduct"> | string
    supplierId?: UuidFilter<"SupplierProduct"> | string
    productId?: UuidFilter<"SupplierProduct"> | string
    supplierSku?: StringNullableFilter<"SupplierProduct"> | string | null
    unitPrice?: DecimalFilter<"SupplierProduct"> | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFilter<"SupplierProduct"> | number
    leadTime?: IntNullableFilter<"SupplierProduct"> | number | null
    isPreferred?: BoolFilter<"SupplierProduct"> | boolean
    lastOrderAt?: DateTimeNullableFilter<"SupplierProduct"> | Date | string | null
    createdAt?: DateTimeFilter<"SupplierProduct"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierProduct"> | Date | string
  }

  export type TenantCreateWithoutWarehousesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWarehousesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWarehousesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWarehousesInput, TenantUncheckedCreateWithoutWarehousesInput>
  }

  export type InventoryItemCreateWithoutWarehouseInput = {
    id?: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryItemsInput
    product: ProductCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutWarehouseInput = {
    id?: string
    tenantId: string
    productId: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryItemCreateManyWarehouseInputEnvelope = {
    data: InventoryItemCreateManyWarehouseInput | InventoryItemCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutFromWarehouseInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryMovementsInput
    product: ProductCreateNestedOneWithoutInventoryMovementsInput
    toWarehouse?: WarehouseCreateNestedOneWithoutMovementsToInput
    user: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutFromWarehouseInput = {
    id?: string
    tenantId: string
    productId: string
    toWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutFromWarehouseInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutFromWarehouseInput, InventoryMovementUncheckedCreateWithoutFromWarehouseInput>
  }

  export type InventoryMovementCreateManyFromWarehouseInputEnvelope = {
    data: InventoryMovementCreateManyFromWarehouseInput | InventoryMovementCreateManyFromWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutToWarehouseInput = {
    id?: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryMovementsInput
    product: ProductCreateNestedOneWithoutInventoryMovementsInput
    fromWarehouse?: WarehouseCreateNestedOneWithoutMovementsFromInput
    user: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutToWarehouseInput = {
    id?: string
    tenantId: string
    productId: string
    fromWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateOrConnectWithoutToWarehouseInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutToWarehouseInput, InventoryMovementUncheckedCreateWithoutToWarehouseInput>
  }

  export type InventoryMovementCreateManyToWarehouseInputEnvelope = {
    data: InventoryMovementCreateManyToWarehouseInput | InventoryMovementCreateManyToWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutWarehouseInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    supplier?: SupplierCreateNestedOneWithoutOrdersInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
    approvedBy?: UserCreateNestedOneWithoutOrdersApprovedInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutWarehouseInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutWarehouseInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutWarehouseInput, OrderUncheckedCreateWithoutWarehouseInput>
  }

  export type OrderCreateManyWarehouseInputEnvelope = {
    data: OrderCreateManyWarehouseInput | OrderCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutWarehousesInput = {
    update: XOR<TenantUpdateWithoutWarehousesInput, TenantUncheckedUpdateWithoutWarehousesInput>
    create: XOR<TenantCreateWithoutWarehousesInput, TenantUncheckedCreateWithoutWarehousesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWarehousesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWarehousesInput, TenantUncheckedUpdateWithoutWarehousesInput>
  }

  export type TenantUpdateWithoutWarehousesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWarehousesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutWarehouseInput, InventoryItemUncheckedUpdateWithoutWarehouseInput>
    create: XOR<InventoryItemCreateWithoutWarehouseInput, InventoryItemUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutWarehouseInput, InventoryItemUncheckedUpdateWithoutWarehouseInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutWarehouseInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutFromWarehouseInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutFromWarehouseInput, InventoryMovementUncheckedUpdateWithoutFromWarehouseInput>
    create: XOR<InventoryMovementCreateWithoutFromWarehouseInput, InventoryMovementUncheckedCreateWithoutFromWarehouseInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutFromWarehouseInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutFromWarehouseInput, InventoryMovementUncheckedUpdateWithoutFromWarehouseInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutFromWarehouseInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutFromWarehouseInput>
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutToWarehouseInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutToWarehouseInput, InventoryMovementUncheckedUpdateWithoutToWarehouseInput>
    create: XOR<InventoryMovementCreateWithoutToWarehouseInput, InventoryMovementUncheckedCreateWithoutToWarehouseInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutToWarehouseInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutToWarehouseInput, InventoryMovementUncheckedUpdateWithoutToWarehouseInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutToWarehouseInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutToWarehouseInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutWarehouseInput, OrderUncheckedUpdateWithoutWarehouseInput>
    create: XOR<OrderCreateWithoutWarehouseInput, OrderUncheckedCreateWithoutWarehouseInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutWarehouseInput, OrderUncheckedUpdateWithoutWarehouseInput>
  }

  export type OrderUpdateManyWithWhereWithoutWarehouseInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type TenantCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInventoryItemsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInventoryItemsInput, TenantUncheckedCreateWithoutInventoryItemsInput>
  }

  export type ProductCreateWithoutInventoryItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    tenantId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
  }

  export type WarehouseCreateWithoutInventoryItemsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutWarehousesInput
    movementsFrom?: InventoryMovementCreateNestedManyWithoutFromWarehouseInput
    movementsTo?: InventoryMovementCreateNestedManyWithoutToWarehouseInput
    ordersShipFrom?: OrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    movementsFrom?: InventoryMovementUncheckedCreateNestedManyWithoutFromWarehouseInput
    movementsTo?: InventoryMovementUncheckedCreateNestedManyWithoutToWarehouseInput
    ordersShipFrom?: OrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutInventoryItemsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
  }

  export type TenantUpsertWithoutInventoryItemsInput = {
    update: XOR<TenantUpdateWithoutInventoryItemsInput, TenantUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<TenantCreateWithoutInventoryItemsInput, TenantUncheckedCreateWithoutInventoryItemsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInventoryItemsInput, TenantUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type TenantUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProductUpsertWithoutInventoryItemsInput = {
    update: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ProductCreateWithoutInventoryItemsInput, ProductUncheckedCreateWithoutInventoryItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryItemsInput, ProductUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ProductUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutInventoryItemsInput = {
    update: XOR<WarehouseUpdateWithoutInventoryItemsInput, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<WarehouseCreateWithoutInventoryItemsInput, WarehouseUncheckedCreateWithoutInventoryItemsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutInventoryItemsInput, WarehouseUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type WarehouseUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutWarehousesNestedInput
    movementsFrom?: InventoryMovementUpdateManyWithoutFromWarehouseNestedInput
    movementsTo?: InventoryMovementUpdateManyWithoutToWarehouseNestedInput
    ordersShipFrom?: OrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    movementsFrom?: InventoryMovementUncheckedUpdateManyWithoutFromWarehouseNestedInput
    movementsTo?: InventoryMovementUncheckedUpdateManyWithoutToWarehouseNestedInput
    ordersShipFrom?: OrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type TenantCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInventoryMovementsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInventoryMovementsInput, TenantUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type ProductCreateWithoutInventoryMovementsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    tenantId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoryMovementsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoryMovementsInput, ProductUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type WarehouseCreateWithoutMovementsFromInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutWarehousesInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    movementsTo?: InventoryMovementCreateNestedManyWithoutToWarehouseInput
    ordersShipFrom?: OrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutMovementsFromInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    movementsTo?: InventoryMovementUncheckedCreateNestedManyWithoutToWarehouseInput
    ordersShipFrom?: OrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutMovementsFromInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutMovementsFromInput, WarehouseUncheckedCreateWithoutMovementsFromInput>
  }

  export type WarehouseCreateWithoutMovementsToInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutWarehousesInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    movementsFrom?: InventoryMovementCreateNestedManyWithoutFromWarehouseInput
    ordersShipFrom?: OrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutMovementsToInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    movementsFrom?: InventoryMovementUncheckedCreateNestedManyWithoutFromWarehouseInput
    ordersShipFrom?: OrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutMovementsToInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutMovementsToInput, WarehouseUncheckedCreateWithoutMovementsToInput>
  }

  export type UserCreateWithoutInventoryMovementsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInventoryMovementsInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInventoryMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type TenantUpsertWithoutInventoryMovementsInput = {
    update: XOR<TenantUpdateWithoutInventoryMovementsInput, TenantUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<TenantCreateWithoutInventoryMovementsInput, TenantUncheckedCreateWithoutInventoryMovementsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInventoryMovementsInput, TenantUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type TenantUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProductUpsertWithoutInventoryMovementsInput = {
    update: XOR<ProductUpdateWithoutInventoryMovementsInput, ProductUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<ProductCreateWithoutInventoryMovementsInput, ProductUncheckedCreateWithoutInventoryMovementsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoryMovementsInput, ProductUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type ProductUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutMovementsFromInput = {
    update: XOR<WarehouseUpdateWithoutMovementsFromInput, WarehouseUncheckedUpdateWithoutMovementsFromInput>
    create: XOR<WarehouseCreateWithoutMovementsFromInput, WarehouseUncheckedCreateWithoutMovementsFromInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutMovementsFromInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutMovementsFromInput, WarehouseUncheckedUpdateWithoutMovementsFromInput>
  }

  export type WarehouseUpdateWithoutMovementsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutWarehousesNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    movementsTo?: InventoryMovementUpdateManyWithoutToWarehouseNestedInput
    ordersShipFrom?: OrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutMovementsFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    movementsTo?: InventoryMovementUncheckedUpdateManyWithoutToWarehouseNestedInput
    ordersShipFrom?: OrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUpsertWithoutMovementsToInput = {
    update: XOR<WarehouseUpdateWithoutMovementsToInput, WarehouseUncheckedUpdateWithoutMovementsToInput>
    create: XOR<WarehouseCreateWithoutMovementsToInput, WarehouseUncheckedCreateWithoutMovementsToInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutMovementsToInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutMovementsToInput, WarehouseUncheckedUpdateWithoutMovementsToInput>
  }

  export type WarehouseUpdateWithoutMovementsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutWarehousesNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    movementsFrom?: InventoryMovementUpdateManyWithoutFromWarehouseNestedInput
    ordersShipFrom?: OrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutMovementsToInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    movementsFrom?: InventoryMovementUncheckedUpdateManyWithoutFromWarehouseNestedInput
    ordersShipFrom?: OrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type UserUpsertWithoutInventoryMovementsInput = {
    update: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type UserUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutCustomersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCustomersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutOrdersInput
    supplier?: SupplierCreateNestedOneWithoutOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutOrdersShipFromInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
    approvedBy?: UserCreateNestedOneWithoutOrdersApprovedInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutCustomerInput = {
    id?: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    createdBy: UserCreateNestedOneWithoutInvoicesCreatedInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCustomerInput = {
    id?: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
    receivedBy: UserCreateNestedOneWithoutPaymentsReceivedInput
  }

  export type PaymentUncheckedCreateWithoutCustomerInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    receivedById: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentCreateManyCustomerInputEnvelope = {
    data: PaymentCreateManyCustomerInput | PaymentCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCustomersInput = {
    update: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCustomersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type TenantUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TenantCreateWithoutSuppliersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSuppliersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSuppliersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
  }

  export type OrderCreateWithoutSupplierInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutOrdersShipFromInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
    approvedBy?: UserCreateNestedOneWithoutOrdersApprovedInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSupplierInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSupplierInput, OrderUncheckedCreateWithoutSupplierInput>
  }

  export type OrderCreateManySupplierInputEnvelope = {
    data: OrderCreateManySupplierInput | OrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SupplierProductCreateWithoutSupplierInput = {
    id?: string
    tenantId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSupplierProductsInput
  }

  export type SupplierProductUncheckedCreateWithoutSupplierInput = {
    id?: string
    tenantId: string
    productId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierProductCreateOrConnectWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    create: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierProductCreateManySupplierInputEnvelope = {
    data: SupplierProductCreateManySupplierInput | SupplierProductCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutSuppliersInput = {
    update: XOR<TenantUpdateWithoutSuppliersInput, TenantUncheckedUpdateWithoutSuppliersInput>
    create: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSuppliersInput, TenantUncheckedUpdateWithoutSuppliersInput>
  }

  export type TenantUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutSupplierInput, OrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<OrderCreateWithoutSupplierInput, OrderUncheckedCreateWithoutSupplierInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutSupplierInput, OrderUncheckedUpdateWithoutSupplierInput>
  }

  export type OrderUpdateManyWithWhereWithoutSupplierInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierProductUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    update: XOR<SupplierProductUpdateWithoutSupplierInput, SupplierProductUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierProductCreateWithoutSupplierInput, SupplierProductUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierProductUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierProductWhereUniqueInput
    data: XOR<SupplierProductUpdateWithoutSupplierInput, SupplierProductUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierProductUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierProductScalarWhereInput
    data: XOR<SupplierProductUpdateManyMutationInput, SupplierProductUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierCreateWithoutSupplierProductsInput = {
    id?: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutSuppliersInput
    orders?: OrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutSupplierProductsInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutSupplierProductsInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutSupplierProductsInput, SupplierUncheckedCreateWithoutSupplierProductsInput>
  }

  export type ProductCreateWithoutSupplierProductsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSupplierProductsInput = {
    id?: string
    tenantId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSupplierProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSupplierProductsInput, ProductUncheckedCreateWithoutSupplierProductsInput>
  }

  export type SupplierUpsertWithoutSupplierProductsInput = {
    update: XOR<SupplierUpdateWithoutSupplierProductsInput, SupplierUncheckedUpdateWithoutSupplierProductsInput>
    create: XOR<SupplierCreateWithoutSupplierProductsInput, SupplierUncheckedCreateWithoutSupplierProductsInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutSupplierProductsInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutSupplierProductsInput, SupplierUncheckedUpdateWithoutSupplierProductsInput>
  }

  export type SupplierUpdateWithoutSupplierProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
    orders?: OrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutSupplierProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ProductUpsertWithoutSupplierProductsInput = {
    update: XOR<ProductUpdateWithoutSupplierProductsInput, ProductUncheckedUpdateWithoutSupplierProductsInput>
    create: XOR<ProductCreateWithoutSupplierProductsInput, ProductUncheckedCreateWithoutSupplierProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSupplierProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSupplierProductsInput, ProductUncheckedUpdateWithoutSupplierProductsInput>
  }

  export type ProductUpdateWithoutSupplierProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSupplierProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TenantCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCustomersInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type SupplierCreateWithoutOrdersInput = {
    id?: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutSuppliersInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutOrdersInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutOrdersInput, SupplierUncheckedCreateWithoutOrdersInput>
  }

  export type WarehouseCreateWithoutOrdersShipFromInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutWarehousesInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutWarehouseInput
    movementsFrom?: InventoryMovementCreateNestedManyWithoutFromWarehouseInput
    movementsTo?: InventoryMovementCreateNestedManyWithoutToWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutOrdersShipFromInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutWarehouseInput
    movementsFrom?: InventoryMovementUncheckedCreateNestedManyWithoutFromWarehouseInput
    movementsTo?: InventoryMovementUncheckedCreateNestedManyWithoutToWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutOrdersShipFromInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutOrdersShipFromInput, WarehouseUncheckedCreateWithoutOrdersShipFromInput>
  }

  export type UserCreateWithoutOrdersCreatedInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersCreatedInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
  }

  export type UserCreateWithoutOrdersApprovedInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersApprovedInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersApprovedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersApprovedInput, UserUncheckedCreateWithoutOrdersApprovedInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    createdBy: UserCreateNestedOneWithoutInvoicesCreatedInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    tenantId: string
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceCreateManyOrderInputEnvelope = {
    data: InvoiceCreateManyOrderInput | InvoiceCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutOrdersInput = {
    update: XOR<TenantUpdateWithoutOrdersInput, TenantUncheckedUpdateWithoutOrdersInput>
    create: XOR<TenantCreateWithoutOrdersInput, TenantUncheckedCreateWithoutOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOrdersInput, TenantUncheckedUpdateWithoutOrdersInput>
  }

  export type TenantUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SupplierUpsertWithoutOrdersInput = {
    update: XOR<SupplierUpdateWithoutOrdersInput, SupplierUncheckedUpdateWithoutOrdersInput>
    create: XOR<SupplierCreateWithoutOrdersInput, SupplierUncheckedCreateWithoutOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutOrdersInput, SupplierUncheckedUpdateWithoutOrdersInput>
  }

  export type SupplierUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type WarehouseUpsertWithoutOrdersShipFromInput = {
    update: XOR<WarehouseUpdateWithoutOrdersShipFromInput, WarehouseUncheckedUpdateWithoutOrdersShipFromInput>
    create: XOR<WarehouseCreateWithoutOrdersShipFromInput, WarehouseUncheckedCreateWithoutOrdersShipFromInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutOrdersShipFromInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutOrdersShipFromInput, WarehouseUncheckedUpdateWithoutOrdersShipFromInput>
  }

  export type WarehouseUpdateWithoutOrdersShipFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutWarehousesNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    movementsFrom?: InventoryMovementUpdateManyWithoutFromWarehouseNestedInput
    movementsTo?: InventoryMovementUpdateManyWithoutToWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutOrdersShipFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    movementsFrom?: InventoryMovementUncheckedUpdateManyWithoutFromWarehouseNestedInput
    movementsTo?: InventoryMovementUncheckedUpdateManyWithoutToWarehouseNestedInput
  }

  export type UserUpsertWithoutOrdersCreatedInput = {
    update: XOR<UserUpdateWithoutOrdersCreatedInput, UserUncheckedUpdateWithoutOrdersCreatedInput>
    create: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersCreatedInput, UserUncheckedUpdateWithoutOrdersCreatedInput>
  }

  export type UserUpdateWithoutOrdersCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutOrdersApprovedInput = {
    update: XOR<UserUpdateWithoutOrdersApprovedInput, UserUncheckedUpdateWithoutOrdersApprovedInput>
    create: XOR<UserCreateWithoutOrdersApprovedInput, UserUncheckedCreateWithoutOrdersApprovedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersApprovedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersApprovedInput, UserUncheckedUpdateWithoutOrdersApprovedInput>
  }

  export type UserUpdateWithoutOrdersApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutOrderInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    supplier?: SupplierCreateNestedOneWithoutOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutOrdersShipFromInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
    approvedBy?: UserCreateNestedOneWithoutOrdersApprovedInput
    invoices?: InvoiceCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    tenantId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutOrdersShipFromNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    approvedBy?: UserUpdateOneWithoutOrdersApprovedNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TenantCreateWithoutInvoicesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
  }

  export type OrderCreateWithoutInvoicesInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrdersInput
    supplier?: SupplierCreateNestedOneWithoutOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutOrdersShipFromInput
    createdBy: UserCreateNestedOneWithoutOrdersCreatedInput
    approvedBy?: UserCreateNestedOneWithoutOrdersApprovedInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoicesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
  }

  export type CustomerCreateWithoutInvoicesInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    payments?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
  }

  export type UserCreateWithoutInvoicesCreatedInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesCreatedInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesCreatedInput, UserUncheckedCreateWithoutInvoicesCreatedInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
    eInvoiceItems?: EInvoiceItemCreateNestedManyWithoutInvoiceItemInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    productId?: string | null
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    eInvoiceItems?: EInvoiceItemUncheckedCreateNestedManyWithoutInvoiceItemInput
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    customer: CustomerCreateNestedOneWithoutPaymentsInput
    receivedBy: UserCreateNestedOneWithoutPaymentsReceivedInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    customerId: string
    receivedById: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type EInvoiceCreateWithoutInvoiceInput = {
    id?: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEInvoicesInput
    originalEInvoice?: EInvoiceCreateNestedOneWithoutRelatedEInvoicesInput
    relatedEInvoices?: EInvoiceCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tenantId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedEInvoices?: EInvoiceUncheckedCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemUncheckedCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogUncheckedCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceCreateOrConnectWithoutInvoiceInput = {
    where: EInvoiceWhereUniqueInput
    create: XOR<EInvoiceCreateWithoutInvoiceInput, EInvoiceUncheckedCreateWithoutInvoiceInput>
  }

  export type EInvoiceCreateManyInvoiceInputEnvelope = {
    data: EInvoiceCreateManyInvoiceInput | EInvoiceCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutInvoicesInput = {
    update: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type OrderUpsertWithoutInvoicesInput = {
    update: XOR<OrderUpdateWithoutInvoicesInput, OrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<OrderCreateWithoutInvoicesInput, OrderUncheckedCreateWithoutInvoicesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInvoicesInput, OrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type OrderUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutOrdersShipFromNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    approvedBy?: UserUpdateOneWithoutOrdersApprovedNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CustomerUpsertWithoutInvoicesInput = {
    update: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CustomerCreateWithoutInvoicesInput, CustomerUncheckedCreateWithoutInvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvoicesInput, CustomerUncheckedUpdateWithoutInvoicesInput>
  }

  export type CustomerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutInvoicesCreatedInput = {
    update: XOR<UserUpdateWithoutInvoicesCreatedInput, UserUncheckedUpdateWithoutInvoicesCreatedInput>
    create: XOR<UserCreateWithoutInvoicesCreatedInput, UserUncheckedCreateWithoutInvoicesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesCreatedInput, UserUncheckedUpdateWithoutInvoicesCreatedInput>
  }

  export type UserUpdateWithoutInvoicesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type EInvoiceUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: EInvoiceWhereUniqueInput
    update: XOR<EInvoiceUpdateWithoutInvoiceInput, EInvoiceUncheckedUpdateWithoutInvoiceInput>
    create: XOR<EInvoiceCreateWithoutInvoiceInput, EInvoiceUncheckedCreateWithoutInvoiceInput>
  }

  export type EInvoiceUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: EInvoiceWhereUniqueInput
    data: XOR<EInvoiceUpdateWithoutInvoiceInput, EInvoiceUncheckedUpdateWithoutInvoiceInput>
  }

  export type EInvoiceUpdateManyWithWhereWithoutInvoiceInput = {
    where: EInvoiceScalarWhereInput
    data: XOR<EInvoiceUpdateManyMutationInput, EInvoiceUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    createdBy: UserCreateNestedOneWithoutInvoicesCreatedInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutInvoiceItemsInput = {
    id?: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    tenantId: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutProductInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    supplierProducts?: SupplierProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInvoiceItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type EInvoiceItemCreateWithoutInvoiceItemInput = {
    id?: string
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    eInvoice: EInvoiceCreateNestedOneWithoutItemsInput
  }

  export type EInvoiceItemUncheckedCreateWithoutInvoiceItemInput = {
    id?: string
    eInvoiceId: string
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceItemCreateOrConnectWithoutInvoiceItemInput = {
    where: EInvoiceItemWhereUniqueInput
    create: XOR<EInvoiceItemCreateWithoutInvoiceItemInput, EInvoiceItemUncheckedCreateWithoutInvoiceItemInput>
  }

  export type EInvoiceItemCreateManyInvoiceItemInputEnvelope = {
    data: EInvoiceItemCreateManyInvoiceItemInput | EInvoiceItemCreateManyInvoiceItemInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoicesCreatedNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ProductUpsertWithoutInvoiceItemsInput = {
    update: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ProductCreateWithoutInvoiceItemsInput, ProductUncheckedCreateWithoutInvoiceItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInvoiceItemsInput, ProductUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ProductUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type EInvoiceItemUpsertWithWhereUniqueWithoutInvoiceItemInput = {
    where: EInvoiceItemWhereUniqueInput
    update: XOR<EInvoiceItemUpdateWithoutInvoiceItemInput, EInvoiceItemUncheckedUpdateWithoutInvoiceItemInput>
    create: XOR<EInvoiceItemCreateWithoutInvoiceItemInput, EInvoiceItemUncheckedCreateWithoutInvoiceItemInput>
  }

  export type EInvoiceItemUpdateWithWhereUniqueWithoutInvoiceItemInput = {
    where: EInvoiceItemWhereUniqueInput
    data: XOR<EInvoiceItemUpdateWithoutInvoiceItemInput, EInvoiceItemUncheckedUpdateWithoutInvoiceItemInput>
  }

  export type EInvoiceItemUpdateManyWithWhereWithoutInvoiceItemInput = {
    where: EInvoiceItemScalarWhereInput
    data: XOR<EInvoiceItemUpdateManyMutationInput, EInvoiceItemUncheckedUpdateManyWithoutInvoiceItemInput>
  }

  export type EInvoiceItemScalarWhereInput = {
    AND?: EInvoiceItemScalarWhereInput | EInvoiceItemScalarWhereInput[]
    OR?: EInvoiceItemScalarWhereInput[]
    NOT?: EInvoiceItemScalarWhereInput | EInvoiceItemScalarWhereInput[]
    id?: UuidFilter<"EInvoiceItem"> | string
    eInvoiceId?: UuidFilter<"EInvoiceItem"> | string
    invoiceItemId?: UuidNullableFilter<"EInvoiceItem"> | string | null
    classificationCode?: StringFilter<"EInvoiceItem"> | string
    description?: StringFilter<"EInvoiceItem"> | string
    quantity?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    unitCode?: StringFilter<"EInvoiceItem"> | string
    unitPrice?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxType?: StringFilter<"EInvoiceItem"> | string
    taxRate?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    taxExemptReason?: StringNullableFilter<"EInvoiceItem"> | string | null
    subtotal?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"EInvoiceItem"> | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFilter<"EInvoiceItem"> | number
    createdAt?: DateTimeFilter<"EInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"EInvoiceItem"> | Date | string
  }

  export type TenantCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    createdBy: UserCreateNestedOneWithoutInvoicesCreatedInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type CustomerCreateWithoutPaymentsInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCustomersInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsReceivedInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsReceivedInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
  }

  export type TenantUpsertWithoutPaymentsInput = {
    update: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoicesCreatedNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerUpsertWithoutPaymentsInput = {
    update: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CustomerCreateWithoutPaymentsInput, CustomerUncheckedCreateWithoutPaymentsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentsInput, CustomerUncheckedUpdateWithoutPaymentsInput>
  }

  export type CustomerUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutPaymentsReceivedInput = {
    update: XOR<UserUpdateWithoutPaymentsReceivedInput, UserUncheckedUpdateWithoutPaymentsReceivedInput>
    create: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsReceivedInput, UserUncheckedUpdateWithoutPaymentsReceivedInput>
  }

  export type UserUpdateWithoutPaymentsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    printAudits?: PrintAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutAssetsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAssetsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAssetsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAssetsInput, TenantUncheckedCreateWithoutAssetsInput>
  }

  export type TenantUpsertWithoutAssetsInput = {
    update: XOR<TenantUpdateWithoutAssetsInput, TenantUncheckedUpdateWithoutAssetsInput>
    create: XOR<TenantCreateWithoutAssetsInput, TenantUncheckedCreateWithoutAssetsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAssetsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAssetsInput, TenantUncheckedUpdateWithoutAssetsInput>
  }

  export type TenantUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutEInvoicesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEInvoicesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEInvoicesInput, TenantUncheckedCreateWithoutEInvoicesInput>
  }

  export type InvoiceCreateWithoutEInvoicesInput = {
    id?: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    order?: OrderCreateNestedOneWithoutInvoicesInput
    customer: CustomerCreateNestedOneWithoutInvoicesInput
    createdBy: UserCreateNestedOneWithoutInvoicesCreatedInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutEInvoicesInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutEInvoicesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutEInvoicesInput, InvoiceUncheckedCreateWithoutEInvoicesInput>
  }

  export type EInvoiceCreateWithoutRelatedEInvoicesInput = {
    id?: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEInvoicesInput
    invoice: InvoiceCreateNestedOneWithoutEInvoicesInput
    originalEInvoice?: EInvoiceCreateNestedOneWithoutRelatedEInvoicesInput
    items?: EInvoiceItemCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceUncheckedCreateWithoutRelatedEInvoicesInput = {
    id?: string
    tenantId: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: EInvoiceItemUncheckedCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogUncheckedCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceCreateOrConnectWithoutRelatedEInvoicesInput = {
    where: EInvoiceWhereUniqueInput
    create: XOR<EInvoiceCreateWithoutRelatedEInvoicesInput, EInvoiceUncheckedCreateWithoutRelatedEInvoicesInput>
  }

  export type EInvoiceCreateWithoutOriginalEInvoiceInput = {
    id?: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEInvoicesInput
    invoice: InvoiceCreateNestedOneWithoutEInvoicesInput
    relatedEInvoices?: EInvoiceCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput = {
    id?: string
    tenantId: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedEInvoices?: EInvoiceUncheckedCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemUncheckedCreateNestedManyWithoutEInvoiceInput
    logs?: EInvoiceLogUncheckedCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceCreateOrConnectWithoutOriginalEInvoiceInput = {
    where: EInvoiceWhereUniqueInput
    create: XOR<EInvoiceCreateWithoutOriginalEInvoiceInput, EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput>
  }

  export type EInvoiceCreateManyOriginalEInvoiceInputEnvelope = {
    data: EInvoiceCreateManyOriginalEInvoiceInput | EInvoiceCreateManyOriginalEInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type EInvoiceItemCreateWithoutEInvoiceInput = {
    id?: string
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItem?: InvoiceItemCreateNestedOneWithoutEInvoiceItemsInput
  }

  export type EInvoiceItemUncheckedCreateWithoutEInvoiceInput = {
    id?: string
    invoiceItemId?: string | null
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceItemCreateOrConnectWithoutEInvoiceInput = {
    where: EInvoiceItemWhereUniqueInput
    create: XOR<EInvoiceItemCreateWithoutEInvoiceInput, EInvoiceItemUncheckedCreateWithoutEInvoiceInput>
  }

  export type EInvoiceItemCreateManyEInvoiceInputEnvelope = {
    data: EInvoiceItemCreateManyEInvoiceInput | EInvoiceItemCreateManyEInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type EInvoiceLogCreateWithoutEInvoiceInput = {
    id?: string
    action: string
    status: $Enums.EInvoiceStatus
    message?: string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type EInvoiceLogUncheckedCreateWithoutEInvoiceInput = {
    id?: string
    action: string
    status: $Enums.EInvoiceStatus
    message?: string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type EInvoiceLogCreateOrConnectWithoutEInvoiceInput = {
    where: EInvoiceLogWhereUniqueInput
    create: XOR<EInvoiceLogCreateWithoutEInvoiceInput, EInvoiceLogUncheckedCreateWithoutEInvoiceInput>
  }

  export type EInvoiceLogCreateManyEInvoiceInputEnvelope = {
    data: EInvoiceLogCreateManyEInvoiceInput | EInvoiceLogCreateManyEInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutEInvoicesInput = {
    update: XOR<TenantUpdateWithoutEInvoicesInput, TenantUncheckedUpdateWithoutEInvoicesInput>
    create: XOR<TenantCreateWithoutEInvoicesInput, TenantUncheckedCreateWithoutEInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEInvoicesInput, TenantUncheckedUpdateWithoutEInvoicesInput>
  }

  export type TenantUpdateWithoutEInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithoutEInvoicesInput = {
    update: XOR<InvoiceUpdateWithoutEInvoicesInput, InvoiceUncheckedUpdateWithoutEInvoicesInput>
    create: XOR<InvoiceCreateWithoutEInvoicesInput, InvoiceUncheckedCreateWithoutEInvoicesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutEInvoicesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutEInvoicesInput, InvoiceUncheckedUpdateWithoutEInvoicesInput>
  }

  export type InvoiceUpdateWithoutEInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoicesCreatedNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutEInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type EInvoiceUpsertWithoutRelatedEInvoicesInput = {
    update: XOR<EInvoiceUpdateWithoutRelatedEInvoicesInput, EInvoiceUncheckedUpdateWithoutRelatedEInvoicesInput>
    create: XOR<EInvoiceCreateWithoutRelatedEInvoicesInput, EInvoiceUncheckedCreateWithoutRelatedEInvoicesInput>
    where?: EInvoiceWhereInput
  }

  export type EInvoiceUpdateToOneWithWhereWithoutRelatedEInvoicesInput = {
    where?: EInvoiceWhereInput
    data: XOR<EInvoiceUpdateWithoutRelatedEInvoicesInput, EInvoiceUncheckedUpdateWithoutRelatedEInvoicesInput>
  }

  export type EInvoiceUpdateWithoutRelatedEInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEInvoicesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEInvoicesNestedInput
    originalEInvoice?: EInvoiceUpdateOneWithoutRelatedEInvoicesNestedInput
    items?: EInvoiceItemUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateWithoutRelatedEInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: EInvoiceItemUncheckedUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUncheckedUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUpsertWithWhereUniqueWithoutOriginalEInvoiceInput = {
    where: EInvoiceWhereUniqueInput
    update: XOR<EInvoiceUpdateWithoutOriginalEInvoiceInput, EInvoiceUncheckedUpdateWithoutOriginalEInvoiceInput>
    create: XOR<EInvoiceCreateWithoutOriginalEInvoiceInput, EInvoiceUncheckedCreateWithoutOriginalEInvoiceInput>
  }

  export type EInvoiceUpdateWithWhereUniqueWithoutOriginalEInvoiceInput = {
    where: EInvoiceWhereUniqueInput
    data: XOR<EInvoiceUpdateWithoutOriginalEInvoiceInput, EInvoiceUncheckedUpdateWithoutOriginalEInvoiceInput>
  }

  export type EInvoiceUpdateManyWithWhereWithoutOriginalEInvoiceInput = {
    where: EInvoiceScalarWhereInput
    data: XOR<EInvoiceUpdateManyMutationInput, EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceInput>
  }

  export type EInvoiceItemUpsertWithWhereUniqueWithoutEInvoiceInput = {
    where: EInvoiceItemWhereUniqueInput
    update: XOR<EInvoiceItemUpdateWithoutEInvoiceInput, EInvoiceItemUncheckedUpdateWithoutEInvoiceInput>
    create: XOR<EInvoiceItemCreateWithoutEInvoiceInput, EInvoiceItemUncheckedCreateWithoutEInvoiceInput>
  }

  export type EInvoiceItemUpdateWithWhereUniqueWithoutEInvoiceInput = {
    where: EInvoiceItemWhereUniqueInput
    data: XOR<EInvoiceItemUpdateWithoutEInvoiceInput, EInvoiceItemUncheckedUpdateWithoutEInvoiceInput>
  }

  export type EInvoiceItemUpdateManyWithWhereWithoutEInvoiceInput = {
    where: EInvoiceItemScalarWhereInput
    data: XOR<EInvoiceItemUpdateManyMutationInput, EInvoiceItemUncheckedUpdateManyWithoutEInvoiceInput>
  }

  export type EInvoiceLogUpsertWithWhereUniqueWithoutEInvoiceInput = {
    where: EInvoiceLogWhereUniqueInput
    update: XOR<EInvoiceLogUpdateWithoutEInvoiceInput, EInvoiceLogUncheckedUpdateWithoutEInvoiceInput>
    create: XOR<EInvoiceLogCreateWithoutEInvoiceInput, EInvoiceLogUncheckedCreateWithoutEInvoiceInput>
  }

  export type EInvoiceLogUpdateWithWhereUniqueWithoutEInvoiceInput = {
    where: EInvoiceLogWhereUniqueInput
    data: XOR<EInvoiceLogUpdateWithoutEInvoiceInput, EInvoiceLogUncheckedUpdateWithoutEInvoiceInput>
  }

  export type EInvoiceLogUpdateManyWithWhereWithoutEInvoiceInput = {
    where: EInvoiceLogScalarWhereInput
    data: XOR<EInvoiceLogUpdateManyMutationInput, EInvoiceLogUncheckedUpdateManyWithoutEInvoiceInput>
  }

  export type EInvoiceLogScalarWhereInput = {
    AND?: EInvoiceLogScalarWhereInput | EInvoiceLogScalarWhereInput[]
    OR?: EInvoiceLogScalarWhereInput[]
    NOT?: EInvoiceLogScalarWhereInput | EInvoiceLogScalarWhereInput[]
    id?: UuidFilter<"EInvoiceLog"> | string
    eInvoiceId?: UuidFilter<"EInvoiceLog"> | string
    action?: StringFilter<"EInvoiceLog"> | string
    status?: EnumEInvoiceStatusFilter<"EInvoiceLog"> | $Enums.EInvoiceStatus
    message?: StringNullableFilter<"EInvoiceLog"> | string | null
    requestData?: JsonNullableFilter<"EInvoiceLog">
    responseData?: JsonNullableFilter<"EInvoiceLog">
    errorCode?: StringNullableFilter<"EInvoiceLog"> | string | null
    errorMessage?: StringNullableFilter<"EInvoiceLog"> | string | null
    ipAddress?: StringNullableFilter<"EInvoiceLog"> | string | null
    userAgent?: StringNullableFilter<"EInvoiceLog"> | string | null
    createdAt?: DateTimeFilter<"EInvoiceLog"> | Date | string
  }

  export type EInvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEInvoicesInput
    invoice: InvoiceCreateNestedOneWithoutEInvoicesInput
    originalEInvoice?: EInvoiceCreateNestedOneWithoutRelatedEInvoicesInput
    relatedEInvoices?: EInvoiceCreateNestedManyWithoutOriginalEInvoiceInput
    logs?: EInvoiceLogCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedEInvoices?: EInvoiceUncheckedCreateNestedManyWithoutOriginalEInvoiceInput
    logs?: EInvoiceLogUncheckedCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceCreateOrConnectWithoutItemsInput = {
    where: EInvoiceWhereUniqueInput
    create: XOR<EInvoiceCreateWithoutItemsInput, EInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceItemCreateWithoutEInvoiceItemsInput = {
    id?: string
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutEInvoiceItemsInput = {
    id?: string
    invoiceId: string
    productId?: string | null
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutEInvoiceItemsInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutEInvoiceItemsInput, InvoiceItemUncheckedCreateWithoutEInvoiceItemsInput>
  }

  export type EInvoiceUpsertWithoutItemsInput = {
    update: XOR<EInvoiceUpdateWithoutItemsInput, EInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<EInvoiceCreateWithoutItemsInput, EInvoiceUncheckedCreateWithoutItemsInput>
    where?: EInvoiceWhereInput
  }

  export type EInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: EInvoiceWhereInput
    data: XOR<EInvoiceUpdateWithoutItemsInput, EInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type EInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEInvoicesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEInvoicesNestedInput
    originalEInvoice?: EInvoiceUpdateOneWithoutRelatedEInvoicesNestedInput
    relatedEInvoices?: EInvoiceUpdateManyWithoutOriginalEInvoiceNestedInput
    logs?: EInvoiceLogUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEInvoices?: EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceNestedInput
    logs?: EInvoiceLogUncheckedUpdateManyWithoutEInvoiceNestedInput
  }

  export type InvoiceItemUpsertWithoutEInvoiceItemsInput = {
    update: XOR<InvoiceItemUpdateWithoutEInvoiceItemsInput, InvoiceItemUncheckedUpdateWithoutEInvoiceItemsInput>
    create: XOR<InvoiceItemCreateWithoutEInvoiceItemsInput, InvoiceItemUncheckedCreateWithoutEInvoiceItemsInput>
    where?: InvoiceItemWhereInput
  }

  export type InvoiceItemUpdateToOneWithWhereWithoutEInvoiceItemsInput = {
    where?: InvoiceItemWhereInput
    data: XOR<InvoiceItemUpdateWithoutEInvoiceItemsInput, InvoiceItemUncheckedUpdateWithoutEInvoiceItemsInput>
  }

  export type InvoiceItemUpdateWithoutEInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutEInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceCreateWithoutLogsInput = {
    id?: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEInvoicesInput
    invoice: InvoiceCreateNestedOneWithoutEInvoicesInput
    originalEInvoice?: EInvoiceCreateNestedOneWithoutRelatedEInvoicesInput
    relatedEInvoices?: EInvoiceCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceUncheckedCreateWithoutLogsInput = {
    id?: string
    tenantId: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedEInvoices?: EInvoiceUncheckedCreateNestedManyWithoutOriginalEInvoiceInput
    items?: EInvoiceItemUncheckedCreateNestedManyWithoutEInvoiceInput
  }

  export type EInvoiceCreateOrConnectWithoutLogsInput = {
    where: EInvoiceWhereUniqueInput
    create: XOR<EInvoiceCreateWithoutLogsInput, EInvoiceUncheckedCreateWithoutLogsInput>
  }

  export type EInvoiceUpsertWithoutLogsInput = {
    update: XOR<EInvoiceUpdateWithoutLogsInput, EInvoiceUncheckedUpdateWithoutLogsInput>
    create: XOR<EInvoiceCreateWithoutLogsInput, EInvoiceUncheckedCreateWithoutLogsInput>
    where?: EInvoiceWhereInput
  }

  export type EInvoiceUpdateToOneWithWhereWithoutLogsInput = {
    where?: EInvoiceWhereInput
    data: XOR<EInvoiceUpdateWithoutLogsInput, EInvoiceUncheckedUpdateWithoutLogsInput>
  }

  export type EInvoiceUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEInvoicesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEInvoicesNestedInput
    originalEInvoice?: EInvoiceUpdateOneWithoutRelatedEInvoicesNestedInput
    relatedEInvoices?: EInvoiceUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEInvoices?: EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUncheckedUpdateManyWithoutEInvoiceNestedInput
  }

  export type TenantCreateWithoutLhdnTokenInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLhdnTokenInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLhdnTokenInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLhdnTokenInput, TenantUncheckedCreateWithoutLhdnTokenInput>
  }

  export type TenantUpsertWithoutLhdnTokenInput = {
    update: XOR<TenantUpdateWithoutLhdnTokenInput, TenantUncheckedUpdateWithoutLhdnTokenInput>
    create: XOR<TenantCreateWithoutLhdnTokenInput, TenantUncheckedCreateWithoutLhdnTokenInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLhdnTokenInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLhdnTokenInput, TenantUncheckedUpdateWithoutLhdnTokenInput>
  }

  export type TenantUpdateWithoutLhdnTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLhdnTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutLhdnCredentialInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLhdnCredentialInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLhdnCredentialInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLhdnCredentialInput, TenantUncheckedCreateWithoutLhdnCredentialInput>
  }

  export type TenantUpsertWithoutLhdnCredentialInput = {
    update: XOR<TenantUpdateWithoutLhdnCredentialInput, TenantUncheckedUpdateWithoutLhdnCredentialInput>
    create: XOR<TenantCreateWithoutLhdnCredentialInput, TenantUncheckedCreateWithoutLhdnCredentialInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLhdnCredentialInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLhdnCredentialInput, TenantUncheckedUpdateWithoutLhdnCredentialInput>
  }

  export type TenantUpdateWithoutLhdnCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLhdnCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutCapabilitiesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    printAudits?: PrintAuditCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCapabilitiesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    printAudits?: PrintAuditUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCapabilitiesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCapabilitiesInput, TenantUncheckedCreateWithoutCapabilitiesInput>
  }

  export type TenantUpsertWithoutCapabilitiesInput = {
    update: XOR<TenantUpdateWithoutCapabilitiesInput, TenantUncheckedUpdateWithoutCapabilitiesInput>
    create: XOR<TenantCreateWithoutCapabilitiesInput, TenantUncheckedCreateWithoutCapabilitiesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCapabilitiesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCapabilitiesInput, TenantUncheckedUpdateWithoutCapabilitiesInput>
  }

  export type TenantUpdateWithoutCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    printAudits?: PrintAuditUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCapabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutPrintAuditsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    categories?: CategoryCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutTenantInput
    orders?: OrderCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    licenses?: LicenseCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    assets?: AssetCreateNestedManyWithoutTenantInput
    roles?: RoleCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPrintAuditsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    status?: $Enums.TenantStatus
    tier?: $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    authPolicyPrimary?: $Enums.AuthPolicyPrimary
    authPolicyMfa?: $Enums.AuthPolicyMfa
    authPolicyIdentifier?: $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: boolean
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    categories?: CategoryUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutTenantInput
    orders?: OrderUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    assets?: AssetUncheckedCreateNestedManyWithoutTenantInput
    roles?: RoleUncheckedCreateNestedManyWithoutTenantInput
    eInvoices?: EInvoiceUncheckedCreateNestedManyWithoutTenantInput
    lhdnToken?: LhdnTokenUncheckedCreateNestedOneWithoutTenantInput
    lhdnCredential?: LhdnCredentialUncheckedCreateNestedOneWithoutTenantInput
    capabilities?: TenantCapabilityUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPrintAuditsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPrintAuditsInput, TenantUncheckedCreateWithoutPrintAuditsInput>
  }

  export type UserCreateWithoutPrintAuditsInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutUsersInput
    customRole?: RoleCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPrintAuditsInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatedByInput
    ordersApproved?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    invoicesCreated?: InvoiceUncheckedCreateNestedManyWithoutCreatedByInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceivedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPrintAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrintAuditsInput, UserUncheckedCreateWithoutPrintAuditsInput>
  }

  export type TenantUpsertWithoutPrintAuditsInput = {
    update: XOR<TenantUpdateWithoutPrintAuditsInput, TenantUncheckedUpdateWithoutPrintAuditsInput>
    create: XOR<TenantCreateWithoutPrintAuditsInput, TenantUncheckedCreateWithoutPrintAuditsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPrintAuditsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPrintAuditsInput, TenantUncheckedUpdateWithoutPrintAuditsInput>
  }

  export type TenantUpdateWithoutPrintAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    categories?: CategoryUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutTenantNestedInput
    orders?: OrderUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    assets?: AssetUpdateManyWithoutTenantNestedInput
    roles?: RoleUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPrintAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTenantStatusFieldUpdateOperationsInput | $Enums.TenantStatus
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    authPolicyPrimary?: EnumAuthPolicyPrimaryFieldUpdateOperationsInput | $Enums.AuthPolicyPrimary
    authPolicyMfa?: EnumAuthPolicyMfaFieldUpdateOperationsInput | $Enums.AuthPolicyMfa
    authPolicyIdentifier?: EnumAuthPolicyIdentifierFieldUpdateOperationsInput | $Enums.AuthPolicyIdentifier
    authPolicyAllowFallback?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    warehouses?: WarehouseUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutTenantNestedInput
    orders?: OrderUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    assets?: AssetUncheckedUpdateManyWithoutTenantNestedInput
    roles?: RoleUncheckedUpdateManyWithoutTenantNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    lhdnToken?: LhdnTokenUncheckedUpdateOneWithoutTenantNestedInput
    lhdnCredential?: LhdnCredentialUncheckedUpdateOneWithoutTenantNestedInput
    capabilities?: TenantCapabilityUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutPrintAuditsInput = {
    update: XOR<UserUpdateWithoutPrintAuditsInput, UserUncheckedUpdateWithoutPrintAuditsInput>
    create: XOR<UserCreateWithoutPrintAuditsInput, UserUncheckedCreateWithoutPrintAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrintAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrintAuditsInput, UserUncheckedUpdateWithoutPrintAuditsInput>
  }

  export type UserUpdateWithoutPrintAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPrintAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    roleId?: string | null
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductCreateManyTenantInput = {
    id?: string
    categoryId?: string | null
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CategoryCreateManyTenantInput = {
    id?: string
    parentId?: string | null
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerCreateManyTenantInput = {
    id?: string
    code: string
    name: string
    type?: $Enums.CustomerType
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    creditLimit?: Decimal | DecimalJsLike | number | string
    currentBalance?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SupplierCreateManyTenantInput = {
    id?: string
    code: string
    name: string
    contactPerson?: string | null
    email?: string | null
    phone?: string | null
    mobile?: string | null
    fax?: string | null
    website?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: number
    currency?: string
    leadTime?: number
    minimumOrder?: Decimal | DecimalJsLike | number | string
    rating?: number | null
    notes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WarehouseCreateManyTenantInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    manager?: string | null
    type?: $Enums.WarehouseType
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InventoryItemCreateManyTenantInput = {
    id?: string
    productId: string
    warehouseId: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryMovementCreateManyTenantInput = {
    id?: string
    productId: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type OrderCreateManyTenantInput = {
    id?: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    orderId?: string | null
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentCreateManyTenantInput = {
    id?: string
    invoiceId?: string | null
    customerId: string
    receivedById: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseCreateManyTenantInput = {
    id?: string
    tier: $Enums.LicenseTier
    licenseKey: string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: number
    maxProducts?: number | null
    startsAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type AssetCreateManyTenantInput = {
    id?: string
    assetTag: string
    name: string
    description?: string | null
    assetType: $Enums.AssetType
    category: $Enums.AssetCategory
    status?: $Enums.AssetStatus
    location: string
    assignedTo?: string | null
    purchaseDate: Date | string
    purchaseCost: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    depreciationMethod?: $Enums.DepreciationMethod
    usefulLifeYears?: number | null
    salvageValue?: Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: Date | string | null
    serialNumber?: string | null
    manufacturer?: string | null
    model?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RoleCreateManyTenantInput = {
    id?: string
    name: string
    displayName: string
    description?: string | null
    color?: string | null
    isSystem?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EInvoiceCreateManyTenantInput = {
    id?: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantCapabilityCreateManyTenantInput = {
    id?: string
    code: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrintAuditCreateManyTenantInput = {
    id?: string
    userId: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customRole?: RoleUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    creditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentBalance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUpdateManyWithoutSupplierNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutSupplierNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    bankDetails?: NullableJsonNullValueInput | InputJsonValue
    paymentTerms?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    leadTime?: IntFieldUpdateOperationsInput | number
    minimumOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarehouseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUpdateManyWithoutWarehouseNestedInput
    movementsFrom?: InventoryMovementUpdateManyWithoutFromWarehouseNestedInput
    movementsTo?: InventoryMovementUpdateManyWithoutToWarehouseNestedInput
    ordersShipFrom?: OrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutWarehouseNestedInput
    movementsFrom?: InventoryMovementUncheckedUpdateManyWithoutFromWarehouseNestedInput
    movementsTo?: InventoryMovementUncheckedUpdateManyWithoutToWarehouseNestedInput
    ordersShipFrom?: OrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWarehouseTypeFieldUpdateOperationsInput | $Enums.WarehouseType
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryItemUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutInventoryMovementsNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutMovementsFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutMovementsToNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutOrdersShipFromNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    approvedBy?: UserUpdateOneWithoutOrdersApprovedNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoicesCreatedNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    licenseKey?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    licenseKey?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: EnumLicenseTierFieldUpdateOperationsInput | $Enums.LicenseTier
    licenseKey?: StringFieldUpdateOperationsInput | string
    features?: JsonNullValueInput | InputJsonValue
    maxUsers?: IntFieldUpdateOperationsInput | number
    maxProducts?: NullableIntFieldUpdateOperationsInput | number | null
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetTag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    category?: EnumAssetCategoryFieldUpdateOperationsInput | $Enums.AssetCategory
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFieldUpdateOperationsInput | $Enums.DepreciationMethod
    usefulLifeYears?: NullableIntFieldUpdateOperationsInput | number | null
    salvageValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetTag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    category?: EnumAssetCategoryFieldUpdateOperationsInput | $Enums.AssetCategory
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFieldUpdateOperationsInput | $Enums.DepreciationMethod
    usefulLifeYears?: NullableIntFieldUpdateOperationsInput | number | null
    salvageValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetTag?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assetType?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    category?: EnumAssetCategoryFieldUpdateOperationsInput | $Enums.AssetCategory
    status?: EnumAssetStatusFieldUpdateOperationsInput | $Enums.AssetStatus
    location?: StringFieldUpdateOperationsInput | string
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    depreciationMethod?: EnumDepreciationMethodFieldUpdateOperationsInput | $Enums.DepreciationMethod
    usefulLifeYears?: NullableIntFieldUpdateOperationsInput | number | null
    salvageValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    warrantyExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutCustomRoleNestedInput
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutCustomRoleNestedInput
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EInvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutEInvoicesNestedInput
    originalEInvoice?: EInvoiceUpdateOneWithoutRelatedEInvoicesNestedInput
    relatedEInvoices?: EInvoiceUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEInvoices?: EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUncheckedUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUncheckedUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCapabilityUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCapabilityUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCapabilityUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintAuditUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPrintAuditsNestedInput
  }

  export type PrintAuditUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintAuditUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type InventoryMovementCreateManyUserInput = {
    id?: string
    tenantId: string
    productId: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type OrderCreateManyCreatedByInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderCreateManyApprovedByInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InvoiceCreateManyCreatedByInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    customerId: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentCreateManyReceivedByInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    customerId: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tenantId: string
    action: string
    entityType: string
    entityId?: string | null
    entityName?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    duration?: number | null
    createdAt?: Date | string
  }

  export type PrintAuditCreateManyUserInput = {
    id?: string
    tenantId: string
    documentType: string
    documentId: string
    documentNumber?: string | null
    printerName?: string | null
    paperSize?: string | null
    copies?: number
    printMode?: string | null
    success?: boolean
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    printTimestamp?: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryMovementsNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutMovementsFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutMovementsToNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutOrdersShipFromNestedInput
    approvedBy?: UserUpdateOneWithoutOrdersApprovedNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutOrdersShipFromNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    entityName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintAuditUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPrintAuditsNestedInput
  }

  export type PrintAuditUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintAuditUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    documentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    printerName?: NullableStringFieldUpdateOperationsInput | string | null
    paperSize?: NullableStringFieldUpdateOperationsInput | string | null
    copies?: IntFieldUpdateOperationsInput | number
    printMode?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    printTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminRefreshTokenCreateManyAdminInput = {
    id?: string
    token: string
    userAgent?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PlatformAdminRefreshTokenUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminRefreshTokenUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAdminRefreshTokenUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyCustomRoleInput = {
    id?: string
    tenantId: string
    email: string
    name: string
    password: string
    role?: $Enums.UserRole
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLogins?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatedByNestedInput
    ordersApproved?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    invoicesCreated?: InvoiceUncheckedUpdateManyWithoutCreatedByNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceivedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    printAudits?: PrintAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCustomRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLogins?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    tenantId: string
    name: string
    slug: string
    description?: string | null
    image?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    tenantId: string
    sku: string
    barcode?: string | null
    name: string
    description?: string | null
    unit: string
    price: Decimal | DecimalJsLike | number | string
    cost: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    minStock?: number
    maxStock?: number
    reorderPoint?: number
    reorderQty?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCategoriesNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutProductNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutProductNestedInput
    supplierProducts?: SupplierProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minStock?: IntFieldUpdateOperationsInput | number
    maxStock?: IntFieldUpdateOperationsInput | number
    reorderPoint?: IntFieldUpdateOperationsInput | number
    reorderQty?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    images?: JsonNullValueInput | InputJsonValue
    attributes?: JsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InventoryItemCreateManyProductInput = {
    id?: string
    tenantId: string
    warehouseId: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryMovementCreateManyProductInput = {
    id?: string
    tenantId: string
    fromWarehouseId?: string | null
    toWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemCreateManyProductInput = {
    id?: string
    invoiceId: string
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierProductCreateManyProductInput = {
    id?: string
    tenantId: string
    supplierId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryItemsNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryMovementsNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutMovementsFromNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutMovementsToNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    eInvoiceItems?: EInvoiceItemUpdateManyWithoutInvoiceItemNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eInvoiceItems?: EInvoiceItemUncheckedUpdateManyWithoutInvoiceItemNestedInput
  }

  export type InvoiceItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutSupplierProductsNestedInput
  }

  export type SupplierProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyWarehouseInput = {
    id?: string
    tenantId: string
    productId: string
    quantity?: number
    reservedQty?: number
    availableQty?: number
    batchNumber?: string | null
    lotNumber?: string | null
    serialNumber?: string | null
    expiryDate?: Date | string | null
    location?: string | null
    costPrice?: Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryMovementCreateManyFromWarehouseInput = {
    id?: string
    tenantId: string
    productId: string
    toWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type InventoryMovementCreateManyToWarehouseInput = {
    id?: string
    tenantId: string
    productId: string
    fromWarehouseId?: string | null
    userId: string
    type: $Enums.MovementType
    quantity: number
    unitCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    reference?: string | null
    referenceType?: string | null
    batchNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type OrderCreateManyWarehouseInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    supplierId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InventoryItemUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reservedQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutFromWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryMovementsNestedInput
    toWarehouse?: WarehouseUpdateOneWithoutMovementsToNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutFromWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutFromWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    toWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUpdateWithoutToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryMovementsNestedInput
    product?: ProductUpdateOneRequiredWithoutInventoryMovementsNestedInput
    fromWarehouse?: WarehouseUpdateOneWithoutMovementsFromNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryMovementUncheckedUpdateManyWithoutToWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    fromWarehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumMovementTypeFieldUpdateOperationsInput | $Enums.MovementType
    quantity?: IntFieldUpdateOperationsInput | number
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceType?: NullableStringFieldUpdateOperationsInput | string | null
    batchNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutOrdersNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    approvedBy?: UserUpdateOneWithoutOrdersApprovedNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    supplierId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: string
    tenantId: string
    orderId?: string | null
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PaymentCreateManyCustomerInput = {
    id?: string
    tenantId: string
    invoiceId?: string | null
    receivedById: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    supplier?: SupplierUpdateOneWithoutOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutOrdersShipFromNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    approvedBy?: UserUpdateOneWithoutOrdersApprovedNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    order?: OrderUpdateOneWithoutInvoicesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoicesCreatedNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedById?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManySupplierInput = {
    id?: string
    tenantId: string
    orderNumber: string
    type: $Enums.OrderType
    status?: $Enums.OrderStatus
    customerId?: string | null
    warehouseId?: string | null
    createdById: string
    approvedById?: string | null
    orderDate?: Date | string
    expectedDate?: Date | string | null
    shippedDate?: Date | string | null
    deliveredDate?: Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    total: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentTerms?: number | null
    paymentMethod?: string | null
    notes?: string | null
    internalNotes?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SupplierProductCreateManySupplierInput = {
    id?: string
    tenantId: string
    productId: string
    supplierSku?: string | null
    unitPrice: Decimal | DecimalJsLike | number | string
    minOrderQty?: number
    leadTime?: number | null
    isPreferred?: boolean
    lastOrderAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutOrdersShipFromNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    approvedBy?: UserUpdateOneWithoutOrdersApprovedNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    billingAddress?: NullableJsonNullValueInput | InputJsonValue
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentTerms?: NullableIntFieldUpdateOperationsInput | number | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierProductUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSupplierProductsNestedInput
  }

  export type SupplierProductUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierProductUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    supplierSku?: NullableStringFieldUpdateOperationsInput | string | null
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderQty?: IntFieldUpdateOperationsInput | number
    leadTime?: NullableIntFieldUpdateOperationsInput | number | null
    isPreferred?: BoolFieldUpdateOperationsInput | boolean
    lastOrderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    sku: string
    name: string
    description?: string | null
    quantity: number
    shippedQty?: number
    receivedQty?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    unitCost?: Decimal | DecimalJsLike | number | string | null
    discount?: Decimal | DecimalJsLike | number | string
    discountType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    notes?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyOrderInput = {
    id?: string
    tenantId: string
    customerId: string
    createdById: string
    invoiceNumber: string
    type?: $Enums.InvoiceType
    status?: $Enums.InvoiceStatus
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    shippingCost?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string
    balanceDue?: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    notes?: string | null
    terms?: string | null
    footer?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    viewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    shippedQty?: IntFieldUpdateOperationsInput | number
    receivedQty?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutInvoicesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoicesCreatedNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    eInvoices?: EInvoiceUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    footer?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    productId?: string | null
    sku?: string | null
    name: string
    description?: string | null
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    tenantId: string
    customerId: string
    receivedById: string
    paymentNumber: string
    type?: $Enums.PaymentType
    method?: $Enums.PaymentMethod
    status?: $Enums.PaymentStatus
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchangeRate?: Decimal | DecimalJsLike | number | string
    paymentDate?: Date | string
    reference?: string | null
    notes?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceCreateManyInvoiceInput = {
    id?: string
    tenantId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    originalEInvoiceId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutInvoiceItemsNestedInput
    eInvoiceItems?: EInvoiceItemUpdateManyWithoutInvoiceItemNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eInvoiceItems?: EInvoiceItemUncheckedUpdateManyWithoutInvoiceItemNestedInput
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPaymentsNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEInvoicesNestedInput
    originalEInvoice?: EInvoiceUpdateOneWithoutRelatedEInvoicesNestedInput
    relatedEInvoices?: EInvoiceUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEInvoices?: EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUncheckedUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUncheckedUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    originalEInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceItemCreateManyInvoiceItemInput = {
    id?: string
    eInvoiceId: string
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceItemUpdateWithoutInvoiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eInvoice?: EInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type EInvoiceItemUncheckedUpdateWithoutInvoiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    eInvoiceId?: StringFieldUpdateOperationsInput | string
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceItemUncheckedUpdateManyWithoutInvoiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    eInvoiceId?: StringFieldUpdateOperationsInput | string
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceCreateManyOriginalEInvoiceInput = {
    id?: string
    tenantId: string
    invoiceId: string
    invoiceType: $Enums.EInvoiceType
    status?: $Enums.EInvoiceStatus
    lhdnUuid?: string | null
    lhdnLongId?: string | null
    lhdnSubmissionUid?: string | null
    submittedAt?: Date | string | null
    validatedAt?: Date | string | null
    cancelledAt?: Date | string | null
    rejectedAt?: Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: string | null
    rejectReason?: string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: number
    lastRetryAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceItemCreateManyEInvoiceInput = {
    id?: string
    invoiceItemId?: string | null
    classificationCode: string
    description: string
    quantity: Decimal | DecimalJsLike | number | string
    unitCode: string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxType: string
    taxRate: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    taxExemptReason?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    discountRate?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EInvoiceLogCreateManyEInvoiceInput = {
    id?: string
    action: string
    status: $Enums.EInvoiceStatus
    message?: string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: string | null
    errorMessage?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type EInvoiceUpdateWithoutOriginalEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEInvoicesNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutEInvoicesNestedInput
    relatedEInvoices?: EInvoiceUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateWithoutOriginalEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedEInvoices?: EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceNestedInput
    items?: EInvoiceItemUncheckedUpdateManyWithoutEInvoiceNestedInput
    logs?: EInvoiceLogUncheckedUpdateManyWithoutEInvoiceNestedInput
  }

  export type EInvoiceUncheckedUpdateManyWithoutOriginalEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    invoiceType?: EnumEInvoiceTypeFieldUpdateOperationsInput | $Enums.EInvoiceType
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    lhdnUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnLongId?: NullableStringFieldUpdateOperationsInput | string | null
    lhdnSubmissionUid?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestJson?: NullableJsonNullValueInput | InputJsonValue
    responseJson?: NullableJsonNullValueInput | InputJsonValue
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    rejectReason?: NullableStringFieldUpdateOperationsInput | string | null
    validationErrors?: NullableJsonNullValueInput | InputJsonValue
    retryCount?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceItemUpdateWithoutEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItem?: InvoiceItemUpdateOneWithoutEInvoiceItemsNestedInput
  }

  export type EInvoiceItemUncheckedUpdateWithoutEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceItemUncheckedUpdateManyWithoutEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    classificationCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCode?: StringFieldUpdateOperationsInput | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxType?: StringFieldUpdateOperationsInput | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxExemptReason?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceLogUpdateWithoutEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceLogUncheckedUpdateWithoutEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EInvoiceLogUncheckedUpdateManyWithoutEInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: EnumEInvoiceStatusFieldUpdateOperationsInput | $Enums.EInvoiceStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}